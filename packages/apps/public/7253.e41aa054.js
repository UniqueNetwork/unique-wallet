((typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] || []).push([[7253],{

/***/ 857:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ packageInfo)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/api-derive',
  version: '4.13.1'
};

/***/ }),

/***/ 44119:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": () => (/* binding */ setDeriveCache),
/* harmony export */   "G": () => (/* binding */ deriveCache)
/* harmony export */ });
/* harmony import */ var _cacheImpl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62311);
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

const CHACHE_EXPIRY = 7 * (24 * 60) * (60 * 1000);
let deriveCache;

function wrapCache(keyStart, cache) {
  return {
    del: partial => cache.del(`${keyStart}${partial}`),
    forEach: cache.forEach,
    get: partial => {
      const key = `${keyStart}${partial}`;
      const cached = cache.get(key);

      if (cached) {
        cached.x = Date.now();
        cache.set(key, cached);
        return cached.v;
      }

      return undefined;
    },
    set: (partial, v) => {
      cache.set(`${keyStart}${partial}`, {
        v,
        x: Date.now()
      });
    }
  };
}

function clearCache(cache) {
  // clear all expired values
  const now = Date.now();
  const all = [];
  cache.forEach((key, {
    x
  }) => {
    now - x > CHACHE_EXPIRY && all.push(key);
  }); // don't do delete inside loop, just in-case

  all.forEach(key => cache.del(key));
}

function setDeriveCache(prefix = '', cache) {
  deriveCache = cache ? wrapCache(`derive:${prefix}:`, cache) : _cacheImpl_js__WEBPACK_IMPORTED_MODULE_0__/* .deriveNoopCache */ .R;

  if (cache) {
    clearCache(cache);
  }
}
setDeriveCache();


/***/ }),

/***/ 62311:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ deriveMapCache),
/* harmony export */   "R": () => (/* binding */ deriveNoopCache)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const mapCache = new Map();
const deriveMapCache = {
  del: key => {
    mapCache.delete(key);
  },
  forEach: cb => {
    const entries = mapCache.entries();

    for (const entry in entries) {
      cb(entry[0], entry[1]);
    }
  },
  get: key => {
    return mapCache.get(key);
  },
  set: (key, value) => {
    mapCache.set(key, value);
  }
};
const deriveNoopCache = {
  del: () => undefined,
  forEach: () => undefined,
  get: () => undefined,
  set: (_, value) => value
};

/***/ }),

/***/ 77084:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ memo)
/* harmony export */ });
/* harmony import */ var _polkadot_rpc_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54141);
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13948);
/* harmony import */ var _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(365);
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



// Wraps a derive, doing 2 things to optimize calls -
//   1. creates a memo of the inner fn -> Observable, removing when unsubscribed
//   2. wraps the observable in a drr() (which includes an unsub delay)

/** @internal */
function memo(instanceId, inner) {
  const cached = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.memoize)((...params) => new _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(observer => {
    const subscription = inner(...params).subscribe(observer);
    return () => {
      cached.unmemoize(...params);
      subscription.unsubscribe();
    };
  }).pipe((0,_polkadot_rpc_core_util__WEBPACK_IMPORTED_MODULE_2__/* .drr */ .h)()), {
    getInstanceId: () => instanceId
  });
  return cached;
}

/***/ }),

/***/ 87982:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "q": () => (/* binding */ ApiBase)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/accounts/index.js
var accounts_namespaceObject = {};
__webpack_require__.r(accounts_namespaceObject);
__webpack_require__.d(accounts_namespaceObject, {
  "accountId": () => (accountId),
  "flags": () => (flags),
  "hasIdentity": () => (hasIdentity),
  "hasIdentityMulti": () => (hasIdentityMulti),
  "idAndIndex": () => (idAndIndex),
  "idToIndex": () => (idToIndex),
  "identity": () => (identity),
  "indexToId": () => (indexToId),
  "indexes": () => (indexes),
  "info": () => (info)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/balances/index.js
var balances_namespaceObject = {};
__webpack_require__.r(balances_namespaceObject);
__webpack_require__.d(balances_namespaceObject, {
  "account": () => (account),
  "all": () => (all_all),
  "fees": () => (fees),
  "votingBalance": () => (votingBalance),
  "votingBalances": () => (votingBalances)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/bounties/index.js
var api_derive_bounties_namespaceObject = {};
__webpack_require__.r(api_derive_bounties_namespaceObject);
__webpack_require__.d(api_derive_bounties_namespaceObject, {
  "bounties": () => (bounties)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/chain/index.js
var chain_namespaceObject = {};
__webpack_require__.r(chain_namespaceObject);
__webpack_require__.d(chain_namespaceObject, {
  "bestNumber": () => (bestNumber),
  "bestNumberFinalized": () => (bestNumberFinalized),
  "bestNumberLag": () => (bestNumberLag),
  "getBlock": () => (getBlock),
  "getHeader": () => (getHeader),
  "subscribeNewBlocks": () => (subscribeNewBlocks),
  "subscribeNewHeads": () => (subscribeNewHeads)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/contracts/index.js
var contracts_namespaceObject = {};
__webpack_require__.r(contracts_namespaceObject);
__webpack_require__.d(contracts_namespaceObject, {
  "fees": () => (fees_fees)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/council/index.js
var council_namespaceObject = {};
__webpack_require__.r(council_namespaceObject);
__webpack_require__.d(council_namespaceObject, {
  "proposal": () => (proposals_proposal),
  "proposals": () => (proposals_proposals),
  "votes": () => (votes),
  "votesOf": () => (votesOf)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/democracy/index.js
var democracy_namespaceObject = {};
__webpack_require__.r(democracy_namespaceObject);
__webpack_require__.d(democracy_namespaceObject, {
  "_referendumInfo": () => (_referendumInfo),
  "_referendumVotes": () => (_referendumVotes),
  "_referendumsVotes": () => (_referendumsVotes),
  "dispatchQueue": () => (dispatchQueue),
  "locks": () => (locks),
  "nextExternal": () => (nextExternal),
  "preimage": () => (preimage),
  "preimages": () => (preimages),
  "proposals": () => (democracy_proposals_proposals),
  "referendumIds": () => (referendumIds),
  "referendums": () => (referendums),
  "referendumsActive": () => (referendumsActive),
  "referendumsFinished": () => (referendumsFinished),
  "referendumsInfo": () => (referendumsInfo),
  "sqrtElectorate": () => (sqrtElectorate)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/elections/index.js
var elections_namespaceObject = {};
__webpack_require__.r(elections_namespaceObject);
__webpack_require__.d(elections_namespaceObject, {
  "info": () => (info_info)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/imOnline/index.js
var imOnline_namespaceObject = {};
__webpack_require__.r(imOnline_namespaceObject);
__webpack_require__.d(imOnline_namespaceObject, {
  "receivedHeartbeats": () => (receivedHeartbeats)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/membership/index.js
var membership_namespaceObject = {};
__webpack_require__.r(membership_namespaceObject);
__webpack_require__.d(membership_namespaceObject, {
  "proposals": () => (membership_proposals_proposals)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/parachains/index.js
var parachains_namespaceObject = {};
__webpack_require__.r(parachains_namespaceObject);
__webpack_require__.d(parachains_namespaceObject, {
  "info": () => (parachains_info_info),
  "overview": () => (overview)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/session/index.js
var session_namespaceObject = {};
__webpack_require__.r(session_namespaceObject);
__webpack_require__.d(session_namespaceObject, {
  "eraLength": () => (eraLength),
  "eraProgress": () => (eraProgress),
  "indexes": () => (indexes_indexes),
  "info": () => (session_info_info),
  "progress": () => (progress),
  "sessionProgress": () => (sessionProgress)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/society/index.js
var society_namespaceObject = {};
__webpack_require__.r(society_namespaceObject);
__webpack_require__.d(society_namespaceObject, {
  "_members": () => (_members),
  "candidates": () => (candidates),
  "info": () => (society_info_info),
  "member": () => (member),
  "members": () => (members)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/staking/index.js
var staking_namespaceObject = {};
__webpack_require__.r(staking_namespaceObject);
__webpack_require__.d(staking_namespaceObject, {
  "_eraExposure": () => (_eraExposure),
  "_eraPrefs": () => (_eraPrefs),
  "_eraSlashes": () => (_eraSlashes),
  "_erasExposure": () => (_erasExposure),
  "_erasPoints": () => (_erasPoints),
  "_erasPrefs": () => (_erasPrefs),
  "_erasRewards": () => (_erasRewards),
  "_erasSlashes": () => (_erasSlashes),
  "_ownExposures": () => (_ownExposures),
  "_ownSlashes": () => (_ownSlashes),
  "_stakerExposures": () => (_stakerExposures),
  "_stakerPoints": () => (_stakerPoints),
  "_stakerPrefs": () => (_stakerPrefs),
  "_stakerRewards": () => (_stakerRewards),
  "_stakerRewardsEras": () => (_stakerRewardsEras),
  "_stakerSlashes": () => (_stakerSlashes),
  "account": () => (account_account),
  "accounts": () => (accounts),
  "currentPoints": () => (currentPoints),
  "electedInfo": () => (electedInfo),
  "eraExposure": () => (eraExposure),
  "eraPrefs": () => (eraPrefs),
  "eraSlashes": () => (eraSlashes),
  "erasExposure": () => (erasExposure),
  "erasHistoric": () => (erasHistoric),
  "erasPoints": () => (erasPoints),
  "erasPrefs": () => (erasPrefs),
  "erasRewards": () => (erasRewards),
  "erasSlashes": () => (erasSlashes),
  "keys": () => (keys),
  "keysMulti": () => (keysMulti),
  "nextElected": () => (nextElected),
  "overview": () => (overview_overview),
  "ownExposure": () => (ownExposure),
  "ownExposures": () => (ownExposures),
  "ownSlash": () => (ownSlash),
  "ownSlashes": () => (ownSlashes),
  "query": () => (query),
  "queryMulti": () => (queryMulti),
  "stakerExposure": () => (stakerExposure),
  "stakerExposures": () => (stakerExposures),
  "stakerPoints": () => (stakerPoints),
  "stakerPrefs": () => (stakerPrefs),
  "stakerRewards": () => (stakerRewards),
  "stakerRewardsMulti": () => (stakerRewardsMulti),
  "stakerRewardsMultiEras": () => (stakerRewardsMultiEras),
  "stakerSlashes": () => (stakerSlashes),
  "stashes": () => (stashes),
  "validators": () => (validators),
  "waitingInfo": () => (waitingInfo)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/technicalCommittee/index.js
var technicalCommittee_namespaceObject = {};
__webpack_require__.r(technicalCommittee_namespaceObject);
__webpack_require__.d(technicalCommittee_namespaceObject, {
  "proposals": () => (technicalCommittee_proposals_proposals)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/treasury/index.js
var treasury_namespaceObject = {};
__webpack_require__.r(treasury_namespaceObject);
__webpack_require__.d(treasury_namespaceObject, {
  "proposals": () => (treasury_proposals_proposals)
});

// NAMESPACE OBJECT: ../../node_modules/@polkadot/api-derive/tx/index.js
var tx_namespaceObject = {};
__webpack_require__.r(tx_namespaceObject);
__webpack_require__.d(tx_namespaceObject, {
  "events": () => (events),
  "signingInfo": () => (signingInfo)
});

// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
// EXTERNAL MODULE: ../../node_modules/@polkadot/api/packageInfo.js
var packageInfo = __webpack_require__(20762);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
var classPrivateFieldLooseBase = __webpack_require__(89539);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var classPrivateFieldLooseKey = __webpack_require__(38879);
// EXTERNAL MODULE: ../../node_modules/@polkadot/metadata/Metadata.js + 12 modules
var Metadata = __webpack_require__(23594);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/registry.js + 5 modules
var create_registry = __webpack_require__(67795);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types-known/index.js + 17 modules
var types_known = __webpack_require__(80230);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util-crypto@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util-crypto/index.js)
var util_crypto_index_js_ = __webpack_require__(21050);
// EXTERNAL MODULE: consume shared module (default) @polkadot/x-rxjs@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/x-rxjs/index.js)
var x_rxjs_index_js_ = __webpack_require__(365);
// EXTERNAL MODULE: ../../node_modules/@polkadot/x-rxjs/cjs/operators.js
var operators = __webpack_require__(3191);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/capabilities.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


 // the order and types needs to map with the all array setup below

const NumberMap = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten'];

function mapCapabilities({
  accountIdLength,
  refcount1Length,
  refcount2Length,
  refcount3Length
}, [leasePeriodsPerSlot, slotRangeCount], [stakingVersion], [keys, accountInfo]) {
  const types = {}; // AccountInfo

  if (accountInfo) {
    const length = accountInfo.length;

    if (length === refcount1Length) {
      types.AccountInfo = 'AccountInfoWithRefCount';
    } else if (length === refcount2Length) {
      types.AccountInfo = 'AccountInfoWithDualRefCount';
    } else if (length === refcount3Length) {
      types.AccountInfo = 'AccountInfoWithTripleRefCount';
    }
  } // ValidatorPrefs


  if (stakingVersion) {
    if (stakingVersion.index >= 4) {
      // v1 = index 0, V5 = index 4
      types.ValidatorPrefs = 'ValidatorPrefsWithBlocked';
    } else {
      types.ValidatorPrefs = 'ValidatorPrefsWithCommission';
    }
  } // Keys


  if (keys) {
    try {
      const [offset, numItems] = (0,index_js_.compactFromU8a)(keys);
      const tupleLength = (keys.length - offset) / numItems.toNumber();
      const numIds = tupleLength / accountIdLength;
      const numIdsRound = Math.floor(numIds);
      (0,index_js_.assert)(numIds >= 2 && numIds <= 11, () => `Detected ${numIds} in Keys, should be >= 2 and <= 11`);

      if (numIdsRound !== numIds) {
        // Beefy?
        if ((numIdsRound - 1) * accountIdLength + 33 === tupleLength) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          types.Keys = `SessionKeys${numIdsRound - 1}B`;
        } else {
          (0,index_js_.assert)(false, () => `Expected integer number of keys, found ${numIds.toFixed(2)}`);
        }
      } else {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        types.Keys = `SessionKeys${numIds - 1}`;
      }
    } catch {// ignore
    }
  } // auctions


  if (leasePeriodsPerSlot && slotRangeCount) {
    const _enum = [];

    for (let i = 0; leasePeriodsPerSlot.gtn(i); i++) {
      for (let j = i; leasePeriodsPerSlot.gtn(j); j++) {
        _enum.push(`${NumberMap[i]}${NumberMap[j]}`);
      }
    }

    types.SlotRange = {
      _enum
    };
    types.WinningData = `[WinningDataEntry; ${slotRangeCount.toNumber()}]`;
  }

  return types;
}

function filterEntries(original) {
  const included = original.map(c => !!c);
  return {
    filtered: original.filter((_, index) => included[index]),
    included,
    original
  };
}

function extractResults(results, map) {
  let offset = -1;
  return map.included.map(isIncluded => isIncluded ? results[++offset] : null);
}
/**
 * @description Query the chain for the specific capabilities
 */


function detectedCapabilities(api, blockHash) {
  var _api$consts$auctions, _api$consts$auctions2, _api$query$staking, _api$query$session, _api$query$system, _api$query$system$acc;

  const emptyAccountId = api.registry.createType('AccountId');
  const consts = filterEntries([(_api$consts$auctions = api.consts.auctions) === null || _api$consts$auctions === void 0 ? void 0 : _api$consts$auctions.leasePeriodsPerSlot, (_api$consts$auctions2 = api.consts.auctions) === null || _api$consts$auctions2 === void 0 ? void 0 : _api$consts$auctions2.slotRangeCount]);
  const queries = filterEntries([(_api$query$staking = api.query.staking) === null || _api$query$staking === void 0 ? void 0 : _api$query$staking.storageVersion]);
  const raws = filterEntries([(_api$query$session = api.query.session) === null || _api$query$session === void 0 ? void 0 : _api$query$session.queuedKeys.key(), (_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : (_api$query$system$acc = _api$query$system.account) === null || _api$query$system$acc === void 0 ? void 0 : _api$query$system$acc.key(emptyAccountId)]);
  return (0,x_rxjs_index_js_.combineLatest)([consts.filtered.length ? blockHash // FIXME consts don't have .at as of yet...
  ? (0,x_rxjs_index_js_.of)([]) : (0,x_rxjs_index_js_.of)(consts.filtered) : (0,x_rxjs_index_js_.of)([]), queries.filtered.length ? blockHash ? (0,x_rxjs_index_js_.combineLatest)(queries.filtered.map(c => c.at(blockHash))) : api.queryMulti(queries.filtered) : (0,x_rxjs_index_js_.of)([]), raws.filtered.length ? blockHash ? (0,x_rxjs_index_js_.combineLatest)(raws.filtered.map(k => api.rpc.state.getStorage.raw(k, blockHash))) : (0,x_rxjs_index_js_.combineLatest)(raws.filtered.map(k => api.rpc.state.getStorage.raw(k))) : (0,x_rxjs_index_js_.of)([])]).pipe((0,operators/* map */.UI)(([cResults, qResults, rResults]) => mapCapabilities({
    accountIdLength: emptyAccountId.encodedLength,
    refcount1Length: api.registry.createType('AccountInfoWithRefCount').encodedLength,
    refcount2Length: api.registry.createType('AccountInfoWithDualRefCount').encodedLength,
    refcount3Length: api.registry.createType('AccountInfoWithTripleRefCount').encodedLength
  }, extractResults(cResults, consts), extractResults(qResults, queries), extractResults(rResults, raws))), (0,operators/* take */.qn)(1), (0,operators/* catchError */.KQ)(() => (0,x_rxjs_index_js_.of)({})));
}
// EXTERNAL MODULE: ../../node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(62197);
// EXTERNAL MODULE: ../../node_modules/@polkadot/rpc-core/packageInfo.js
var rpc_core_packageInfo = __webpack_require__(67162);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/packageInfo.js
var types_packageInfo = __webpack_require__(31760);
// EXTERNAL MODULE: ../../node_modules/@polkadot/api-derive/packageInfo.js
var api_derive_packageInfo = __webpack_require__(857);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/detectPackage.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





(0,index_js_.detectPackage)(api_derive_packageInfo/* packageInfo */.b, typeof __dirname !== 'undefined' && __dirname, [packageInfo/* packageInfo */.b, rpc_core_packageInfo/* packageInfo */.b, types_packageInfo/* packageInfo */.b]);
// EXTERNAL MODULE: ../../node_modules/@polkadot/api-derive/util/memo.js
var memo = __webpack_require__(77084);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/accountId.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0






function retrieve(api, address) {
  const decoded = (0,index_js_.isU8a)(address) ? address : (0,util_crypto_index_js_.decodeAddress)((address || '').toString());

  if (decoded.length > 8) {
    return (0,x_rxjs_index_js_.of)(api.registry.createType('AccountId', decoded));
  }

  const accountIndex = api.registry.createType('AccountIndex', decoded);
  return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0,operators/* map */.UI)(accountId => (0,index_js_.assertReturn)(accountId, 'Unable to retrieve accountId')));
}
/**
 * @name accountId
 * @param {(Address | AccountId | AccountIndex | string | null)} address - An accounts address in various formats.
 * @description  An [[AccountId]]
 */


function accountId(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, address => retrieve(api, address));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/flags.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function parseFlags(address, [electionsMembers, councilMembers, technicalCommitteeMembers, societyMembers, sudoKey]) {
  const isIncluded = id => address ? id.toString() === address.toString() : false;

  return {
    isCouncil: ((electionsMembers === null || electionsMembers === void 0 ? void 0 : electionsMembers.map(([id]) => id)) || councilMembers || []).some(isIncluded),
    isSociety: (societyMembers || []).some(isIncluded),
    isSudo: (sudoKey === null || sudoKey === void 0 ? void 0 : sudoKey.toString()) === (address === null || address === void 0 ? void 0 : address.toString()),
    isTechCommittee: (technicalCommitteeMembers || []).some(isIncluded)
  };
}
/**
 * @name info
 * @description Returns account membership flags
 */


function flags(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, address => {
    var _api$query$councilSec, _api$query$council, _api$query$technicalC, _api$query$society, _api$query$sudo;

    const councilSection = api.query.phragmenElection ? 'phragmenElection' : api.query.electionsPhragmen ? 'electionsPhragmen' : 'elections';
    return (0,x_rxjs_index_js_.combineLatest)([address && (_api$query$councilSec = api.query[councilSection]) !== null && _api$query$councilSec !== void 0 && _api$query$councilSec.members ? api.query[councilSection].members() : (0,x_rxjs_index_js_.of)(undefined), address && (_api$query$council = api.query.council) !== null && _api$query$council !== void 0 && _api$query$council.members ? api.query.council.members() : (0,x_rxjs_index_js_.of)([]), address && (_api$query$technicalC = api.query.technicalCommittee) !== null && _api$query$technicalC !== void 0 && _api$query$technicalC.members ? api.query.technicalCommittee.members() : (0,x_rxjs_index_js_.of)([]), address && (_api$query$society = api.query.society) !== null && _api$query$society !== void 0 && _api$query$society.members ? api.query.society.members() : (0,x_rxjs_index_js_.of)([]), address && (_api$query$sudo = api.query.sudo) !== null && _api$query$sudo !== void 0 && _api$query$sudo.key ? api.query.sudo.key() : (0,x_rxjs_index_js_.of)(undefined)]).pipe((0,operators/* map */.UI)(result => parseFlags(address, result)));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/idAndIndex.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0






function idAndIndex_retrieve(api, address) {
  try {
    // yes, this can fail, don't care too much, catch will catch it
    const decoded = (0,index_js_.isU8a)(address) ? address : (0,util_crypto_index_js_.decodeAddress)((address || '').toString());

    if (decoded.length > 8) {
      const accountId = api.registry.createType('AccountId', decoded);
      return api.derive.accounts.idToIndex(accountId).pipe((0,operators/* map */.UI)(accountIndex => [accountId, accountIndex]));
    }

    const accountIndex = api.registry.createType('AccountIndex', decoded);
    return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0,operators/* map */.UI)(accountId => [accountId, accountIndex]));
  } catch (error) {
    return (0,x_rxjs_index_js_.of)([undefined, undefined]);
  }
}
/**
 * @name idAndIndex
 * @param {(Address | AccountId | AccountIndex | Uint8Array | string | null)} address - An accounts address in various formats.
 * @description  An array containing the [[AccountId]] and [[AccountIndex]] as optional values.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.idAndIndex('F7Hs', ([id, ix]) => {
 *   console.log(`AccountId #${id} with corresponding AccountIndex ${ix}`);
 * });
 * ```
 */


function idAndIndex(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, address => idAndIndex_retrieve(api, address));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/idToIndex.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name idToIndex
 * @param {( AccountId | string )} accountId - An accounts Id in different formats.
 * @returns Returns the corresponding AccountIndex.
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY';
 * api.derive.accounts.idToIndex(ALICE, (accountIndex) => {
 *   console.log(`The AccountIndex of ${ALICE} is ${accountIndex}`);
 * });
 * ```
 */

function idToIndex(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.derive.accounts.indexes().pipe((0,operators/* map */.UI)(indexes => (indexes || {})[accountId.toString()])));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/identity.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




const UNDEF_HEX = {
  toHex: () => undefined
};

function dataAsString(data) {
  return data.isRaw ? (0,index_js_.u8aToString)(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();
}

function extractOther(additional) {
  return additional.reduce((other, [_key, _value]) => {
    const key = dataAsString(_key);
    const value = dataAsString(_value);

    if (key && value) {
      other[key] = value;
    }

    return other;
  }, {});
}

function extractIdentity(identityOfOpt, superOf) {
  if (!(identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome)) {
    return {
      judgements: []
    };
  }

  const {
    info,
    judgements
  } = identityOfOpt.unwrap();
  const topDisplay = dataAsString(info.display);
  return {
    display: superOf && dataAsString(superOf[1]) || topDisplay,
    displayParent: superOf && topDisplay,
    email: dataAsString(info.email),
    image: dataAsString(info.image),
    judgements,
    legal: dataAsString(info.legal),
    other: extractOther(info.additional),
    parent: superOf && superOf[0],
    pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),
    riot: dataAsString(info.riot),
    twitter: dataAsString(info.twitter),
    web: dataAsString(info.web)
  };
}

function getParent(api, identityOfOpt, superOfOpt) {
  if (identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome) {
    // this identity has something set
    return (0,x_rxjs_index_js_.of)([identityOfOpt, undefined]);
  } else if (superOfOpt !== null && superOfOpt !== void 0 && superOfOpt.isSome) {
    const superOf = superOfOpt.unwrap(); // we have a super

    return (0,x_rxjs_index_js_.combineLatest)([api.query.identity.identityOf(superOf[0]), (0,x_rxjs_index_js_.of)(superOf)]);
  } // nothing of value returned


  return (0,x_rxjs_index_js_.of)([undefined, undefined]);
}

function getBase(api, accountId) {
  var _api$query$identity;

  return accountId && (_api$query$identity = api.query.identity) !== null && _api$query$identity !== void 0 && _api$query$identity.identityOf ? api.queryMulti([[api.query.identity.identityOf, accountId], [api.query.identity.superOf, accountId]]) : (0,x_rxjs_index_js_.of)([undefined, undefined]);
}
/**
 * @name identity
 * @description Returns identity info for an account
 */


function identity(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => getBase(api, accountId).pipe((0,operators/* switchMap */.wt)(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), (0,operators/* map */.UI)(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));
}
function hasIdentity(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.derive.accounts.hasIdentityMulti([accountId]).pipe((0,operators/* map */.UI)(([first]) => first)));
}
function hasIdentityMulti(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountIds => {
    var _api$query$identity2;

    return (_api$query$identity2 = api.query.identity) !== null && _api$query$identity2 !== void 0 && _api$query$identity2.identityOf ? (0,x_rxjs_index_js_.combineLatest)([api.query.identity.identityOf.multi(accountIds), api.query.identity.superOf.multi(accountIds)]).pipe((0,operators/* map */.UI)(([identities, supers]) => identities.map((identityOfOpt, index) => {
      const superOfOpt = supers[index];
      const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : undefined;
      let display;

      if (identityOfOpt && identityOfOpt.isSome) {
        const value = dataAsString(identityOfOpt.unwrap().info.display);

        if (value && !(0,index_js_.isHex)(value)) {
          display = value;
        }
      }

      return {
        display,
        hasIdentity: !!(display || parentId),
        parentId
      };
    }))) : (0,x_rxjs_index_js_.of)(accountIds.map(() => ({
      hasIdentity: false
    })));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/indexToId.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name indexToId
 * @param {( AccountIndex | string )} accountIndex - An accounts index in different formats.
 * @returns Returns the corresponding AccountId.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexToId('F7Hs', (accountId) => {
 *   console.log(`The AccountId of F7Hs is ${accountId}`);
 * });
 * ```
 */

function indexToId(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountIndex => api.query.indices ? api.query.indices.accounts(accountIndex).pipe((0,operators/* map */.UI)(optResult => optResult.unwrapOr([])[0])) : (0,x_rxjs_index_js_.of)(undefined));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/indexes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



let indicesCache = null;

function queryAccounts(api) {
  return api.query.indices.accounts.entries().pipe((0,operators/* map */.UI)(entries => entries.reduce((indexes, [key, idOpt]) => {
    if (idOpt.isSome) {
      indexes[idOpt.unwrap()[0].toString()] = key.args[0];
    }

    return indexes;
  }, {})));
}
/**
 * @name indexes
 * @returns Returns all the indexes on the system.
 * @description This is an unwieldly query since it loops through
 * all of the enumsets and returns all of the values found. This could be up to 32k depending
 * on the number of active accounts in the system
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexes((indexes) => {
 *   console.log('All existing AccountIndexes', indexes);
 * });
 * ```
 */


function indexes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => indicesCache ? (0,x_rxjs_index_js_.of)(indicesCache) : (api.query.indices ? queryAccounts(api).pipe((0,operators/* startWith */.O4)({})) : (0,x_rxjs_index_js_.of)({})).pipe((0,operators/* map */.UI)(indices => {
    indicesCache = indices;
    return indices;
  })));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/info.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function retrieveNick(api, accountId) {
  var _api$query$nicks;

  return (accountId && (_api$query$nicks = api.query.nicks) !== null && _api$query$nicks !== void 0 && _api$query$nicks.nameOf ? api.query.nicks.nameOf(accountId) : (0,x_rxjs_index_js_.of)(undefined)).pipe((0,operators/* map */.UI)(nameOf => nameOf !== null && nameOf !== void 0 && nameOf.isSome ? (0,index_js_.u8aToString)(nameOf.unwrap()[0]).substr(0, api.consts.nicks.maxLength.toNumber()) : undefined));
}
/**
 * @name info
 * @description Returns aux. info with regards to an account, current that includes the accountId, accountIndex and nickname
 */


function info(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, address => api.derive.accounts.idAndIndex(address).pipe((0,operators/* switchMap */.wt)(([accountId, accountIndex]) => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)({
    accountId,
    accountIndex
  }), api.derive.accounts.identity(accountId), retrieveNick(api, accountId)])), (0,operators/* map */.UI)(([{
    accountId,
    accountIndex
  }, identity, nickname]) => ({
    accountId,
    accountIndex,
    identity,
    nickname
  }))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/accounts/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0








;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/balances/all.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





const VESTING_ID = '0x76657374696e6720';

function calcLocked(api, bestNumber, locks) {
  let lockedBalance = api.registry.createType('Balance');
  let lockedBreakdown = [];
  let vestingLocked = api.registry.createType('Balance');
  let allLocked = false;

  if (Array.isArray(locks)) {
    // only get the locks that are valid until passed the current block
    lockedBreakdown = locks.filter(({
      until
    }) => !until || bestNumber && until.gt(bestNumber));
    allLocked = lockedBreakdown.some(({
      amount
    }) => amount && amount.isMax());
    vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(({
      id
    }) => id.eq(VESTING_ID)).reduce((result, {
      amount
    }) => result.iadd(amount), new bn(0))); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699

    const notAll = lockedBreakdown.filter(({
      amount
    }) => amount && !amount.isMax());

    if (notAll.length) {
      lockedBalance = api.registry.createType('Balance', (0,index_js_.bnMax)(...notAll.map(({
        amount
      }) => amount)));
    }
  }

  return {
    allLocked,
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  };
}

function calcShared(api, bestNumber, data, locks) {
  const {
    allLocked,
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  } = calcLocked(api, bestNumber, locks);
  return _objectSpread(_objectSpread({}, data), {}, {
    availableBalance: api.registry.createType('Balance', allLocked ? 0 : (0,index_js_.bnMax)(new bn(0), data.freeBalance.sub(lockedBalance))),
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  });
}

function calcBalances(api, [data, bestNumber, [vesting, allLocks]]) {
  const shared = calcShared(api, bestNumber, data, allLocks[0]); // Calculate the vesting balances,
  //  - offset = balance locked at startingBlock
  //  - perBlock is the unlock amount

  const {
    locked: vestingTotal,
    perBlock,
    startingBlock
  } = vesting || api.registry.createType('VestingInfo');
  const isStarted = bestNumber.gt(startingBlock);
  const vestedNow = isStarted ? perBlock.mul(bestNumber.sub(startingBlock)) : new bn(0);
  const vestedBalance = vestedNow.gt(vestingTotal) ? vestingTotal : api.registry.createType('Balance', vestedNow);
  const isVesting = isStarted && !shared.vestingLocked.isZero();
  return _objectSpread(_objectSpread({}, shared), {}, {
    accountId: data.accountId,
    accountNonce: data.accountNonce,
    additional: allLocks.filter((_, index) => index !== 0).map((l, index) => calcShared(api, bestNumber, data.additional[index], l)),
    isVesting,
    vestedBalance,
    vestedClaimable: api.registry.createType('Balance', isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : 0),
    vestingEndBlock: api.registry.createType('BlockNumber', isVesting ? vestingTotal.div(perBlock).add(startingBlock) : 0),
    vestingPerBlock: perBlock,
    vestingTotal
  });
} // old


function queryOld(api, accountId) {
  return api.queryMulti([[api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]).pipe((0,operators/* map */.UI)(([locks, optVesting]) => {
    let vestingNew = null;

    if (optVesting.isSome) {
      const {
        offset: locked,
        perBlock,
        startingBlock
      } = optVesting.unwrap();
      vestingNew = api.registry.createType('VestingInfo', {
        locked,
        perBlock,
        startingBlock
      });
    }

    return [vestingNew, [locks]];
  }));
}

const isNonNullable = nullable => !!nullable; // current (balances, vesting)


function queryCurrent(api, accountId, balanceInstances = ['balances']) {
  var _api$query$vesting;

  const lockCalls = balanceInstances.map(m => {
    var _m, _api$query;

    return ((_m = api.derive[m]) === null || _m === void 0 ? void 0 : _m.customLocks) || ((_api$query = api.query[m]) === null || _api$query === void 0 ? void 0 : _api$query.locks);
  });
  const lockEmpty = lockCalls.map(c => !c);
  const lockQueries = lockCalls.filter(isNonNullable).map(c => [c, accountId]);
  return ((_api$query$vesting = api.query.vesting) !== null && _api$query$vesting !== void 0 && _api$query$vesting.vesting ? api.queryMulti([[api.query.vesting.vesting, accountId], ...lockQueries]) // TODO We need to check module instances here as well, not only the balances module
  : lockQueries.length ? api.queryMulti(lockQueries).pipe((0,operators/* map */.UI)(locks => [api.registry.createType('Option<VestingInfo>'), ...locks])) : (0,x_rxjs_index_js_.of)([api.registry.createType('Option<VestingInfo>')])).pipe((0,operators/* map */.UI)(([optVesting, ...locks]) => {
    let offset = -1;
    return [optVesting.unwrapOr(null), lockEmpty.map(e => e ? api.registry.createType('Vec<BalanceLock>') : locks[++offset])];
  }));
}
/**
 * @name all
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function all_all(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName.toString(), 'balances');
  return (0,memo/* memo */.X)(instanceId, address => api.derive.balances.account(address).pipe((0,operators/* switchMap */.wt)(account => {
    var _api$query$system, _api$query$balances;

    return !account.accountId.isEmpty ? (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(account), api.derive.chain.bestNumber(), (0,index_js_.isFunction)((_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.account) || (0,index_js_.isFunction)((_api$query$balances = api.query.balances) === null || _api$query$balances === void 0 ? void 0 : _api$query$balances.account) ? queryCurrent(api, account.accountId, balanceInstances) : queryOld(api, account.accountId)]) : (0,x_rxjs_index_js_.of)([account, api.registry.createType('BlockNumber'), [null, []]]);
  }), (0,operators/* map */.UI)(result => calcBalances(api, result))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/balances/account.js


function account_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function account_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { account_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { account_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function getBalance(api, [freeBalance, reservedBalance, frozenFee, frozenMisc]) {
  return {
    freeBalance,
    frozenFee,
    frozenMisc,
    reservedBalance,
    votingBalance: api.registry.createType('Balance', freeBalance.toBn())
  };
}

function account_calcBalances(api, [accountId, [accountNonce, balances]]) {
  const primary = balances[0];
  (0,index_js_.assert)(primary, 'No balances retrieved for account');
  return account_objectSpread({
    accountId,
    accountNonce,
    additional: balances.filter((_, index) => index !== 0).map(b => getBalance(api, b))
  }, getBalance(api, primary));
} // old


function queryBalancesFree(api, accountId) {
  return api.queryMulti([[api.query.balances.freeBalance, accountId], [api.query.balances.reservedBalance, accountId], [api.query.system.accountNonce, accountId]]).pipe((0,operators/* map */.UI)(([freeBalance, reservedBalance, accountNonce]) => [accountNonce, [[freeBalance, reservedBalance, api.registry.createType('Balance'), api.registry.createType('Balance')]]]));
}

function queryBalancesAccount(api, accountId, modules = ['balances']) {
  const balances = modules.map(m => {
    var _m;

    return [((_m = api.derive[m]) === null || _m === void 0 ? void 0 : _m.customAccount) || api.query[m].account, accountId];
  });

  const extract = data => data.map(({
    feeFrozen,
    free,
    miscFrozen,
    reserved
  }) => [free, reserved, feeFrozen, miscFrozen]);

  return (0,index_js_.isFunction)(api.query.system.account) ? api.queryMulti([[api.query.system.account, accountId], ...balances]).pipe((0,operators/* map */.UI)(([{
    nonce
  }, ...balances]) => [nonce, extract(balances)])) : api.queryMulti([[api.query.system.accountNonce, accountId], ...balances]).pipe((0,operators/* map */.UI)(([nonce, ...balances]) => [nonce, extract(balances)]));
}

function account_queryCurrent(api, accountId) {
  // AccountInfo is current, support old, eg. Edgeware
  return api.query.system.account(accountId).pipe((0,operators/* map */.UI)(infoOrTuple => {
    const {
      feeFrozen,
      free,
      miscFrozen,
      reserved
    } = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];
    return [infoOrTuple.nonce || infoOrTuple[0], [[free, reserved, feeFrozen, miscFrozen]]];
  }));
}
/**
 * @name account
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function account(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName.toString(), 'balances');
  return (0,memo/* memo */.X)(instanceId, address => api.derive.accounts.accountId(address).pipe((0,operators/* switchMap */.wt)(accountId => accountId ? (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(accountId), balanceInstances ? queryBalancesAccount(api, accountId, balanceInstances) : (0,index_js_.isFunction)(api.query.system.account) ? account_queryCurrent(api, accountId) : (0,index_js_.isFunction)(api.query.balances.account) ? queryBalancesAccount(api, accountId) : queryBalancesFree(api, accountId)]) : (0,x_rxjs_index_js_.of)([api.registry.createType('AccountId'), [api.registry.createType('Index'), [[api.registry.createType('Balance'), api.registry.createType('Balance'), api.registry.createType('Balance'), api.registry.createType('Balance')]]]])), (0,operators/* map */.UI)(result => account_calcBalances(api, result))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/balances/fees.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name fees
 * @returns An object containing the combined results of the storage queries for
 * all relevant fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.balances.fees(({ creationFee, transferFee }) => {
 *   console.log(`The fee for creating a new account on this chain is ${creationFee} units. The fee required for making a transfer is ${transferFee} units.`);
 * });
 * ```
 */

function fees(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$consts$balances, _api$consts$balances2, _api$consts$balances3, _api$consts$transacti, _api$consts$transacti2;

    return (0,x_rxjs_index_js_.of)([// deprecated - remove
    ((_api$consts$balances = api.consts.balances) === null || _api$consts$balances === void 0 ? void 0 : _api$consts$balances.creationFee) || api.registry.createType('Balance'), ((_api$consts$balances2 = api.consts.balances) === null || _api$consts$balances2 === void 0 ? void 0 : _api$consts$balances2.transferFee) || api.registry.createType('Balance'), // current
    ((_api$consts$balances3 = api.consts.balances) === null || _api$consts$balances3 === void 0 ? void 0 : _api$consts$balances3.existentialDeposit) || api.registry.createType('Balance'), ((_api$consts$transacti = api.consts.transactionPayment) === null || _api$consts$transacti === void 0 ? void 0 : _api$consts$transacti.transactionBaseFee) || api.registry.createType('Balance'), ((_api$consts$transacti2 = api.consts.transactionPayment) === null || _api$consts$transacti2 === void 0 ? void 0 : _api$consts$transacti2.transactionByteFee) || api.registry.createType('Balance')]).pipe((0,operators/* map */.UI)(([creationFee, transferFee, existentialDeposit, transactionBaseFee, transactionByteFee]) => ({
      creationFee,
      existentialDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/balances/votingBalances.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function votingBalances(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, addresses => !addresses || !addresses.length ? (0,x_rxjs_index_js_.of)([]) : (0,x_rxjs_index_js_.combineLatest)(addresses.map(accountId => api.derive.balances.account(accountId))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/balances/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




const votingBalance = all_all;

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/bounties/helpers/filterBountyProposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function filterBountiesProposals(api, allProposals) {
  const bountyTxBase = api.tx.bounties ? api.tx.bounties : api.tx.treasury;
  const bountyProposalCalls = [bountyTxBase.approveBounty, bountyTxBase.closeBounty, bountyTxBase.proposeCurator, bountyTxBase.unassignCurator];
  return allProposals.filter(proposal => bountyProposalCalls.find(bountyCall => bountyCall.is(proposal.proposal)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/bounties/bounties.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function parseResult([maybeBounties, maybeDescriptions, ids, bountyProposals]) {
  const bounties = [];
  maybeBounties.forEach((bounty, index) => {
    if (bounty.isSome) {
      bounties.push({
        bounty: bounty.unwrap(),
        description: maybeDescriptions[index].unwrapOrDefault().toUtf8(),
        index: ids[index],
        proposals: bountyProposals.filter(bountyProposal => ids[index].eq(bountyProposal.proposal.args[0]))
      });
    }
  });
  return bounties;
}

function bounties(instanceId, api) {
  const bountyBase = api.query.bounties || api.query.treasury;
  return (0,memo/* memo */.X)(instanceId, () => (0,x_rxjs_index_js_.combineLatest)([bountyBase.bountyCount(), api.query.council ? api.query.council.proposalCount() : (0,x_rxjs_index_js_.of)(0)]).pipe((0,operators/* switchMap */.wt)(() => (0,x_rxjs_index_js_.combineLatest)([bountyBase.bounties.keys(), api.derive.council ? api.derive.council.proposals() : (0,x_rxjs_index_js_.of)([])])), (0,operators/* switchMap */.wt)(([keys, proposals]) => {
    const ids = keys.map(({
      args: [id]
    }) => id);
    return (0,x_rxjs_index_js_.combineLatest)([bountyBase.bounties.multi(ids), bountyBase.bountyDescriptions.multi(ids), (0,x_rxjs_index_js_.of)(ids), (0,x_rxjs_index_js_.of)(filterBountiesProposals(api, proposals))]);
  }), (0,operators/* map */.UI)(parseResult)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/bounties/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/bestNumber.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name bestNumber
 * @returns The latest block number.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumber((blockNumber) => {
 *   console.log(`the current best block is #${blockNumber}`);
 * });
 * ```
 */

function bestNumber(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.chain.subscribeNewHeads().pipe((0,operators/* map */.UI)(header => header.number.unwrap())));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name bestNumberFinalized
 * @returns A BlockNumber
 * @description Get the latest finalized block number.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumberFinalized((blockNumber) => {
 *   console.log(`the current finalized block is #${blockNumber}`);
 * });
 * ```
 */

function bestNumberFinalized(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.rpc.chain.subscribeFinalizedHeads().pipe((0,operators/* map */.UI)(header => header.number.unwrap())));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/bestNumberLag.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name bestNumberLag
 * @returns A number of blocks
 * @description Calculates the lag between finalized head and best head
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumberLag((lag) => {
 *   console.log(`finalized is ${lag} blocks behind head`);
 * });
 * ```
 */

function bestNumberLag(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => (0,x_rxjs_index_js_.combineLatest)([api.derive.chain.bestNumber(), api.derive.chain.bestNumberFinalized()]).pipe((0,operators/* map */.UI)(([bestNumber, bestNumberFinalized]) => api.registry.createType('BlockNumber', bestNumber.sub(bestNumberFinalized)))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/type/util.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function extractAuthor(digest, sessionValidators = []) {
  const [citem] = digest.logs.filter(({
    type
  }) => type === 'Consensus');
  const [pitem] = digest.logs.filter(({
    type
  }) => type === 'PreRuntime');
  const [sitem] = digest.logs.filter(({
    type
  }) => type === 'Seal');
  let accountId; // This is critical to be first for BABE (before Consensus)
  // If not first, we end up dropping the author at session-end

  if (pitem) {
    try {
      const [engine, data] = pitem.asPreRuntime;
      accountId = engine.extractAuthor(data, sessionValidators);
    } catch {// ignore
    }
  }

  if (!accountId && citem) {
    try {
      const [engine, data] = citem.asConsensus;
      accountId = engine.extractAuthor(data, sessionValidators);
    } catch {// ignore
    }
  } // SEAL, still used in e.g. Kulupu for pow


  if (!accountId && sitem) {
    try {
      const [engine, data] = sitem.asSeal;
      accountId = engine.extractAuthor(data, sessionValidators);
    } catch {// ignore
    }
  }

  return accountId;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/type/HeaderExtended.js


// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

function createHeaderExtended(registry, header, validators) {
  // an instance of the base extrinsic for us to extend
  const HeaderBase = registry.createClass('Header');

  var _author = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("author");

  var _validators = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("validators");

  class Implementation extends HeaderBase {
    constructor(registry, header, validators) {
      super(registry, header);
      Object.defineProperty(this, _author, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _validators, {
        writable: true,
        value: void 0
      });
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _author)[_author] = extractAuthor(this.digest, validators);
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _validators)[_validators] = validators;
      this.createdAtHash = header === null || header === void 0 ? void 0 : header.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */


    get author() {
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _author)[_author];
    }
    /**
     * @description Convenience method, returns the validators for the block
     */


    get validators() {
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _validators)[_validators];
    }

  }

  return new Implementation(registry, header, validators);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/getHeader.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @name getHeader
 * @param {( Uint8Array | string )} hash - A block hash as U8 array or string.
 * @returns An array containing the block header and the block author
 * @description Get a specific block header and extend it with the author
 * @example
 * <BR>
 *
 * ```javascript
 * const { author, number } = await api.derive.chain.getHeader('0x123...456');
 *
 * console.log(`block #${number} was authored by ${author}`);
 * ```
 */

function getHeader(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, hash => (0,x_rxjs_index_js_.combineLatest)([api.rpc.chain.getHeader(hash), api.query.session ? api.query.session.validators.at(hash) : (0,x_rxjs_index_js_.of)([])]).pipe((0,operators/* map */.UI)(([header, validators]) => createHeaderExtended(header.registry, header, validators)), (0,operators/* catchError */.KQ)(() => // where rpc.chain.getHeader throws, we will land here - it can happen that
  // we supplied an invalid hash. (Due to defaults, storeage will have an
  // empty value, so only the RPC is affected). So return undefined
  (0,x_rxjs_index_js_.of)())));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/type/SignedBlockExtended.js


// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function mapExtrinsics(extrinsics, records) {
  return extrinsics.map((extrinsic, index) => {
    let dispatchError;
    let dispatchInfo;
    const events = records.filter(({
      phase
    }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)).map(({
      event
    }) => {
      if (event.section === 'system') {
        if (event.method === 'ExtrinsicSuccess') {
          dispatchInfo = event.data[0];
        } else if (event.method === 'ExtrinsicFailed') {
          dispatchError = event.data[0];
          dispatchInfo = event.data[1];
        }
      }

      return event;
    });
    return {
      dispatchError,
      dispatchInfo,
      events,
      extrinsic
    };
  });
}

function createSignedBlockExtended(registry, block, events, validators) {
  // an instance of the base extrinsic for us to extend
  const SignedBlockBase = registry.createClass('SignedBlock');

  var _author = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("author");

  var _events = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("events");

  var _extrinsics = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extrinsics");

  class Implementation extends SignedBlockBase {
    constructor(registry, block, events, validators) {
      super(registry, block);
      Object.defineProperty(this, _author, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _events, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _extrinsics, {
        writable: true,
        value: void 0
      });
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _author)[_author] = extractAuthor(this.block.header.digest, validators);
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _events)[_events] = events || [];
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _extrinsics)[_extrinsics] = mapExtrinsics(this.block.extrinsics, (0,classPrivateFieldLooseBase/* default */.Z)(this, _events)[_events]);
      this.createdAtHash = block === null || block === void 0 ? void 0 : block.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */


    get author() {
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _author)[_author];
    }
    /**
     * @description Convenience method, returns the events associated with the block
     */


    get events() {
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _events)[_events];
    }
    /**
     * @description Returns the extrinsics and their events, mapped
     */


    get extrinsics() {
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _extrinsics)[_extrinsics];
    }

  }

  return new Implementation(registry, block, events, validators);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/getBlock.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @name getBlock
 * @param {( Uint8Array | string )} hash - A block hash as U8 array or string.
 * @description Get a specific block (e.g. rpc.chain.getBlock) and extend it with the author
 * @example
 * <BR>
 *
 * ```javascript
 * const { author, block } = await api.derive.chain.getBlock('0x123...456');
 *
 * console.log(`block #${block.header.number} was authored by ${author}`);
 * ```
 */

function getBlock(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, hash => (0,x_rxjs_index_js_.combineLatest)([api.rpc.chain.getBlock(hash), api.query.system.events.at(hash), api.query.session ? api.query.session.validators.at(hash) : (0,x_rxjs_index_js_.of)([])]).pipe((0,operators/* map */.UI)(([signedBlock, events, validators]) => createSignedBlockExtended(api.registry, signedBlock, events, validators)), (0,operators/* catchError */.KQ)(() => // where rpc.chain.getHeader throws, we will land here - it can happen that
  // we supplied an invalid hash. (Due to defaults, storage will have an
  // empty value, so only the RPC is affected). So return undefined
  (0,x_rxjs_index_js_.of)())));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/subscribeNewBlocks.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @name subscribeNewBlocks
 * @returns The latest block & events for that block
 */

function subscribeNewBlocks(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.chain.subscribeNewHeads().pipe((0,operators/* switchMap */.wt)(header => {
    const blockHash = header.createdAtHash || header.hash;
    return (0,x_rxjs_index_js_.combineLatest)(api.rpc.chain.getBlock(blockHash), api.query.system.events.at(blockHash), (0,x_rxjs_index_js_.of)(header));
  }), (0,operators/* map */.UI)(([block, events, header]) => createSignedBlockExtended(block.registry, block, events, header.validators))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @name subscribeNewHeads
 * @returns A header with the current header (including extracted author)
 * @description An observable of the current block header and it's author
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.subscribeNewHeads((header) => {
 *   console.log(`block #${header.number} was authored by ${header.author}`);
 * });
 * ```
 */

function subscribeNewHeads(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => (0,x_rxjs_index_js_.combineLatest)([api.rpc.chain.subscribeNewHeads(), api.query.session ? api.query.session.validators() : (0,x_rxjs_index_js_.of)(undefined)]).pipe((0,operators/* map */.UI)(([header, validators]) => {
    header.createdAtHash = header.hash;
    return createHeaderExtended(header.registry, header, validators);
  })));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/chain/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0







;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/contracts/fees.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




// query via constants (current applicable path)
function queryConstants(api) {
  return (0,x_rxjs_index_js_.of)([// deprecated
  api.consts.contracts.callBaseFee || api.registry.createType('Balance'), api.consts.contracts.contractFee || api.registry.createType('Balance'), api.consts.contracts.creationFee || api.registry.createType('Balance'), api.consts.contracts.transactionBaseFee || api.registry.createType('Balance'), api.consts.contracts.transactionByteFee || api.registry.createType('Balance'), api.consts.contracts.transferFee || api.registry.createType('Balance'), // current
  api.consts.contracts.rentByteFee, api.consts.contracts.rentDepositOffset, api.consts.contracts.surchargeReward, api.consts.contracts.tombstoneDeposit]);
}
/**
 * @name fees
 * @returns An object containing the combined results of the queries for
 * all relevant contract fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.contracts.fees(([creationFee, transferFee]) => {
 *   console.log(`The fee for creating a new contract on this chain is ${creationFee} units. The fee required to call this contract is ${transferFee} units.`);
 * });
 * ```
 */


function fees_fees(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    return queryConstants(api).pipe((0,operators/* map */.UI)(([callBaseFee, contractFee, creationFee, transactionBaseFee, transactionByteFee, transferFee, rentByteFee, rentDepositOffset, surchargeReward, tombstoneDeposit]) => ({
      callBaseFee,
      contractFee,
      creationFee,
      rentByteFee,
      rentDepositOffset,
      surchargeReward,
      tombstoneDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/contracts/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/collective/proposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function parse(api, [hashes, proposals, votes]) {
  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {
    hash: api.registry.createType('Hash', hashes[index]),
    proposal: proposalOpt.unwrap(),
    votes: votes[index].unwrapOr(null)
  } : null).filter(proposal => !!proposal);
}

function _proposalsFrom(instanceId, api, section) {
  return (0,memo/* memo */.X)(instanceId, hashes => {
    var _api$query$section;

    return ((0,index_js_.isFunction)((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(hashes), (0,x_rxjs_index_js_.combineLatest)(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),
    // however we have had cases on Edgeware where the indices have moved around after an
    // upgrade, which results in invalid on-chain data
    api.query[section].proposalOf(hash).pipe((0,operators/* catchError */.KQ)(() => (0,x_rxjs_index_js_.of)(null))))), api.query[section].voting.multi(hashes)]) : (0,x_rxjs_index_js_.of)([[], [], []])).pipe((0,operators/* map */.UI)(result => parse(api, result)));
  });
}

function proposals(instanceId, api, section) {
  const proposalsFrom = _proposalsFrom(instanceId, api, section);

  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$section2;

    return (0,index_js_.isFunction)((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals) ? api.query[section].proposals().pipe((0,operators/* switchMap */.wt)(proposalsFrom)) : (0,x_rxjs_index_js_.of)([]);
  });
}
function proposal(instanceId, api, section) {
  const proposalsFrom = _proposalsFrom(instanceId, api, section);

  return (0,memo/* memo */.X)(instanceId, hash => {
    var _api$query$section3;

    return (0,index_js_.isFunction)((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? proposalsFrom([hash]).pipe((0,operators/* map */.UI)(([proposal]) => proposal)) : (0,x_rxjs_index_js_.of)(null);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/council/proposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function proposals_proposal(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, proposal(instanceId, api, 'council'));
}
function proposals_proposals(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, proposals(instanceId, api, 'council'));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/council/votes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


 // Voter is current tuple is 2.x-era

function isVoter(value) {
  return !Array.isArray(value);
}

function retrieveStakeOf(api) {
  return (api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections).stakeOf.entries().pipe((0,operators/* map */.UI)(entries => entries.map(([{
    args: [accountId]
  }, stake]) => [accountId, stake])));
}

function retrieveVoteOf(api) {
  return (api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections).votesOf.entries().pipe((0,operators/* map */.UI)(entries => entries.map(([{
    args: [accountId]
  }, votes]) => [accountId, votes])));
}

function retrievePrev(api) {
  return (0,x_rxjs_index_js_.combineLatest)([retrieveStakeOf(api), retrieveVoteOf(api)]).pipe((0,operators/* map */.UI)(([stakes, votes]) => {
    const result = [];
    votes.forEach(([voter, votes]) => {
      result.push([voter, {
        stake: api.registry.createType('Balance'),
        votes
      }]);
    });
    stakes.forEach(([staker, stake]) => {
      const entry = result.find(([voter]) => voter.eq(staker));

      if (entry) {
        entry[1].stake = stake;
      } else {
        result.push([staker, {
          stake,
          votes: []
        }]);
      }
    });
    return result;
  }));
}

function retrieveCurrent(api) {
  const elections = api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections;
  return elections.voting.entries().pipe((0,operators/* map */.UI)(entries => entries.map(([{
    args: [accountId]
  }, value]) => [accountId, isVoter(value) ? {
    stake: value.stake,
    votes: value.votes
  } : {
    stake: value[0],
    votes: value[1]
  }])));
}

function votes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => (api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections).stakeOf ? retrievePrev(api) : retrieveCurrent(api));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/council/votesOf.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function votesOf(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.derive.council.votes().pipe((0,operators/* map */.UI)(votes => (votes.find(([from]) => from.eq(accountId)) || [null, {
    stake: api.registry.createType('Balance'),
    votes: []
  }])[1])));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/council/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/dispatchQueue.js


function dispatchQueue_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function dispatchQueue_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dispatchQueue_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dispatchQueue_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




const DEMOCRACY_ID = (0,index_js_.stringToHex)('democrac');

function queryQueue(api) {
  return api.query.democracy.dispatchQueue().pipe((0,operators/* switchMap */.wt)(dispatches => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), (0,operators/* map */.UI)(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({
    at,
    image: images[dispatchIndex],
    imageHash,
    index
  }))));
}

function schedulerEntries(api) {
  // We don't get entries, but rather we get the keys (triggered via finished referendums) and
  // the subscribe to those keys - this means we pickup when the schedulers actually executes
  // at a block, the entry for that block will become empty
  return api.derive.democracy.referendumsFinished().pipe((0,operators/* switchMap */.wt)(() => api.query.scheduler.agenda.keys()), (0,operators/* switchMap */.wt)(keys => {
    const blockNumbers = keys.map(({
      args: [blockNumber]
    }) => blockNumber);
    return (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(blockNumbers), api.query.scheduler.agenda.multi(blockNumbers)]);
  }));
}

function queryScheduler(api) {
  return schedulerEntries(api).pipe((0,operators/* switchMap */.wt)(([blockNumbers, agendas]) => {
    const result = [];
    blockNumbers.forEach((at, index) => {
      agendas[index].filter(optScheduled => optScheduled.isSome).forEach(optScheduled => {
        const scheduled = optScheduled.unwrap();

        if (scheduled.maybeId.isSome) {
          const id = scheduled.maybeId.unwrap().toHex();

          if (id.startsWith(DEMOCRACY_ID)) {
            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);
            const imageHash = scheduled.call.args[0];
            result.push({
              at,
              imageHash,
              index
            });
          }
        }
      });
    });
    return (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(result), api.derive.democracy.preimages(result.map(({
      imageHash
    }) => imageHash))]);
  }), (0,operators/* map */.UI)(([infos, images]) => infos.map((info, index) => dispatchQueue_objectSpread(dispatchQueue_objectSpread({}, info), {}, {
    image: images[index]
  }))));
}

function dispatchQueue(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$scheduler;

    return (0,index_js_.isFunction)((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : (0,x_rxjs_index_js_.of)([]);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/locks.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




const LOCKUPS = [0, 1, 2, 4, 8, 16, 32];

function parseEnd(api, vote, {
  approved,
  end
}) {
  return [end, approved.isTrue && vote.isAye || approved.isFalse && vote.isNay ? end.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[vote.conviction.index])) : index_js_.BN_ZERO];
}

function parseLock(api, [referendumId, accountVote], referendum) {
  const {
    balance,
    vote
  } = accountVote.asStandard;
  const [referendumEnd, unlockAt] = referendum.isFinished ? parseEnd(api, vote, referendum.asFinished) : [index_js_.BN_ZERO, index_js_.BN_ZERO];
  return {
    balance,
    isDelegated: false,
    isFinished: referendum.isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  };
}

function delegateLocks(api, {
  balance,
  conviction,
  target
}) {
  return api.derive.democracy.locks(target).pipe((0,operators/* map */.UI)(available => available.map(({
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  }) => ({
    balance,
    isDelegated: true,
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[conviction.index])),
    vote: api.registry.createType('Vote', {
      aye: vote.isAye,
      conviction
    })
  }))));
}

function directLocks(api, {
  votes
}) {
  if (!votes.length) {
    return (0,x_rxjs_index_js_.of)([]);
  }

  return api.query.democracy.referendumInfoOf.multi(votes.map(([referendumId]) => referendumId)).pipe((0,operators/* map */.UI)(referendums => votes.map((vote, index) => [vote, referendums[index].unwrapOr(null)]).filter(item => !!item[1] && (0,index_js_.isUndefined)(item[1].end) && item[0][1].isStandard).map(([directVote, referendum]) => parseLock(api, directVote, referendum))));
}

function locks(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId).pipe((0,operators/* switchMap */.wt)(voting => voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : (0,x_rxjs_index_js_.of)([]))) : (0,x_rxjs_index_js_.of)([]));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/nextExternal.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function withImage(api, nextOpt) {
  if (nextOpt.isNone) {
    return (0,x_rxjs_index_js_.of)(null);
  }

  const [imageHash, threshold] = nextOpt.unwrap();
  return api.derive.democracy.preimage(imageHash).pipe((0,operators/* map */.UI)(image => ({
    image,
    imageHash,
    threshold
  })));
}

function nextExternal(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$democracy;

    return (_api$query$democracy = api.query.democracy) !== null && _api$query$democracy !== void 0 && _api$query$democracy.nextExternal ? api.query.democracy.nextExternal().pipe((0,operators/* switchMap */.wt)(nextOpt => withImage(api, nextOpt))) : (0,x_rxjs_index_js_.of)(null);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/util.js


function util_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function util_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { util_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { util_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function isOldInfo(info) {
  return !!info.proposalHash;
}

function isCurrentStatus(status) {
  return !!status.tally;
}

function isCurrentPreimage(api, imageOpt) {
  return !!imageOpt && !api.query.democracy.dispatchQueue;
}

function compareRationals(n1, d1, n2, d2) {
  while (true) {
    const q1 = n1.div(d1);
    const q2 = n2.div(d2);

    if (q1.lt(q2)) {
      return true;
    } else if (q2.lt(q1)) {
      return false;
    }

    const r1 = n1.mod(d1);
    const r2 = n2.mod(d2);

    if (r2.isZero()) {
      return false;
    } else if (r1.isZero()) {
      return true;
    }

    n1 = d2;
    n2 = d1;
    d1 = r2;
    d2 = r1;
  }
}

function calcPassingOther(threshold, sqrtElectorate, {
  votedAye,
  votedNay,
  votedTotal
}) {
  const sqrtVoters = (0,index_js_.bnSqrt)(votedTotal);
  return sqrtVoters.isZero() ? false : threshold.isSupermajorityapproval ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate) : compareRationals(votedNay, sqrtElectorate, votedAye, sqrtVoters);
}

function calcPassing(threshold, sqrtElectorate, state) {
  return threshold.isSimplemajority ? state.votedAye.gt(state.votedNay) : calcPassingOther(threshold, sqrtElectorate, state);
}

function calcVotesPrev(votesFor) {
  return votesFor.reduce((state, derived) => {
    const {
      balance,
      vote
    } = derived;
    const isDefault = vote.conviction.index === 0;
    const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);

    if (vote.isAye) {
      state.allAye.push(derived);
      state.voteCountAye++;
      state.votedAye.iadd(counted);
    } else {
      state.allNay.push(derived);
      state.voteCountNay++;
      state.votedNay.iadd(counted);
    }

    state.voteCount++;
    state.votedTotal.iadd(counted);
    return state;
  }, {
    allAye: [],
    allNay: [],
    voteCount: 0,
    voteCountAye: 0,
    voteCountNay: 0,
    votedAye: new bn(0),
    votedNay: new bn(0),
    votedTotal: new bn(0)
  });
}

function calcVotesCurrent(tally, votes) {
  const allAye = [];
  const allNay = [];
  votes.forEach(derived => {
    if (derived.vote.isAye) {
      allAye.push(derived);
    } else {
      allNay.push(derived);
    }
  });
  return {
    allAye,
    allNay,
    voteCount: allAye.length + allNay.length,
    voteCountAye: allAye.length,
    voteCountNay: allNay.length,
    votedAye: tally.ayes,
    votedNay: tally.nays,
    votedTotal: tally.turnout
  };
}

function calcVotes(sqrtElectorate, referendum, votes) {
  const state = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes) : calcVotesPrev(votes);
  return util_objectSpread(util_objectSpread({}, state), {}, {
    isPassing: calcPassing(referendum.status.threshold, sqrtElectorate, state),
    votes
  });
}
function getStatus(info) {
  if (info.isNone) {
    return null;
  }

  const unwrapped = info.unwrap();

  if (isOldInfo(unwrapped)) {
    return unwrapped;
  } else if (unwrapped.isOngoing) {
    return unwrapped.asOngoing;
  } // done, we don't include it here... only currently active


  return null;
}

function constructProposal(api, [bytes, proposer, balance, at]) {
  let proposal;

  try {
    proposal = api.registry.createType('Proposal', bytes.toU8a(true));
  } catch (error) {
    console.error(error);
  }

  return {
    at,
    balance,
    proposal,
    proposer
  };
}

function parseImage(api, imageOpt) {
  if (imageOpt.isNone) {
    return;
  }

  if (isCurrentPreimage(api, imageOpt)) {
    const status = imageOpt.unwrap();

    if (status.isMissing) {
      return;
    }

    const {
      data,
      deposit,
      provider,
      since
    } = status.asAvailable;
    return constructProposal(api, [data, provider, deposit, since]);
  }

  return constructProposal(api, imageOpt.unwrap());
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/preimage.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function preimage(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, hash => api.query.democracy.preimages(hash).pipe((0,operators/* map */.UI)(imageOpt => parseImage(api, imageOpt))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/preimages.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function preimages(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, hashes => api.query.democracy.preimages.multi(hashes).pipe((0,operators/* map */.UI)(images => images.map(imageOpt => parseImage(api, imageOpt)))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/proposals.js


function proposals_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function proposals_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { proposals_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { proposals_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





// eslint-disable-next-line @typescript-eslint/no-unused-vars
function isNewDepositors(depositors) {
  // Detect balance...
  // eslint-disable-next-line @typescript-eslint/unbound-method
  return (0,index_js_.isFunction)(depositors[1].mul);
}

function proposals_parse([proposals, images, optDepositors]) {
  return proposals.filter(([,, proposer], index) => {
    var _optDepositors$index;

    return !!((_optDepositors$index = optDepositors[index]) !== null && _optDepositors$index !== void 0 && _optDepositors$index.isSome) && !proposer.isEmpty;
  }).map(([index, imageHash, proposer], proposalIndex) => {
    const depositors = optDepositors[proposalIndex].unwrap();
    return proposals_objectSpread(proposals_objectSpread({}, isNewDepositors(depositors) ? {
      balance: depositors[1],
      seconds: depositors[0]
    } : {
      balance: depositors[0],
      seconds: depositors[1]
    }), {}, {
      image: images[proposalIndex],
      imageHash,
      index,
      proposer
    });
  });
}

function democracy_proposals_proposals(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$democracy, _api$query$democracy2;

    return (0,index_js_.isFunction)((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.publicProps) && (0,index_js_.isFunction)((_api$query$democracy2 = api.query.democracy) === null || _api$query$democracy2 === void 0 ? void 0 : _api$query$democracy2.preimages) ? api.query.democracy.publicProps().pipe((0,operators/* switchMap */.wt)(proposals => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(proposals), api.derive.democracy.preimages(proposals.map(([, hash]) => hash)), api.query.democracy.depositOf.multi(proposals.map(([index]) => index))])), (0,operators/* map */.UI)(proposals_parse)) : (0,x_rxjs_index_js_.of)([]);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/referendumIds.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function referendumIds(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$democracy;

    return (_api$query$democracy = api.query.democracy) !== null && _api$query$democracy !== void 0 && _api$query$democracy.lowestUnbaked ? api.queryMulti([api.query.democracy.lowestUnbaked, api.query.democracy.referendumCount]).pipe((0,operators/* map */.UI)(([first, total]) => total.gt(first) // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    ? [...Array(total.sub(first).toNumber())].map((_, i) => first.addn(i)) : [])) : (0,x_rxjs_index_js_.of)([]);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/referendums.js


function referendums_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function referendums_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { referendums_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { referendums_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function referendums(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.democracy.referendumsActive().pipe((0,operators/* switchMap */.wt)(referendums => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(referendums), api.derive.democracy._referendumsVotes(referendums)])), (0,operators/* map */.UI)(([referendums, votes]) => referendums.map((referendum, index) => referendums_objectSpread(referendums_objectSpread({}, referendum), votes[index])))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/referendumsActive.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function referendumsActive(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.democracy.referendumIds().pipe((0,operators/* switchMap */.wt)(ids => ids.length ? api.derive.democracy.referendumsInfo(ids) : (0,x_rxjs_index_js_.of)([]))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/referendumsFinished.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function referendumsFinished(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.democracy.referendumIds().pipe((0,operators/* switchMap */.wt)(ids => api.query.democracy.referendumInfoOf.multi(ids)), (0,operators/* map */.UI)(infos => infos.filter(optInfo => optInfo.isSome).map(optInfo => optInfo.unwrap()).filter(info => info.isFinished).map(info => info.asFinished))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/referendumsInfo.js


function referendumsInfo_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function referendumsInfo_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { referendumsInfo_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { referendumsInfo_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0






function votesPrev(api, referendumId) {
  return api.query.democracy.votersFor(referendumId).pipe((0,operators/* switchMap */.wt)(votersFor => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(votersFor), votersFor.length ? api.query.democracy.voteOf.multi(votersFor.map(accountId => [referendumId, accountId])) : (0,x_rxjs_index_js_.of)([]), api.derive.balances.votingBalances(votersFor)])), (0,operators/* map */.UI)(([votersFor, votes, balances]) => votersFor.map((accountId, index) => ({
    accountId,
    balance: balances[index].votingBalance || api.registry.createType('Balance'),
    isDelegating: false,
    vote: votes[index] || api.registry.createType('Vote')
  }))));
}

function extractVotes(mapped, referendumId) {
  return mapped.filter(([, voting]) => voting.isDirect).map(([accountId, voting]) => [accountId, voting.asDirect.votes.filter(([idx]) => idx.eq(referendumId))]).filter(([, directVotes]) => !!directVotes.length).reduce((result, [accountId, votes]) => // FIXME We are ignoring split votes
  votes.reduce((result, [, vote]) => {
    if (vote.isStandard) {
      result.push(referendumsInfo_objectSpread({
        accountId,
        isDelegating: false
      }, vote.asStandard));
    }

    return result;
  }, result), []);
}

function votesCurr(api, referendumId) {
  return api.query.democracy.votingOf.entries().pipe((0,operators/* map */.UI)(allVoting => {
    const mapped = allVoting.map(([{
      args: [accountId]
    }, voting]) => [accountId, voting]);
    const votes = extractVotes(mapped, referendumId);
    const delegations = mapped.filter(([, voting]) => voting.isDelegating).map(([accountId, voting]) => [accountId, voting.asDelegating]); // add delegations

    delegations.forEach(([accountId, {
      balance,
      conviction,
      target
    }]) => {
      // Are we delegating to a delegator
      const toDelegator = delegations.find(([accountId]) => accountId.eq(target));
      const to = votes.find(({
        accountId
      }) => accountId.eq(toDelegator ? toDelegator[0] : target)); // this delegation has a target

      if (to) {
        votes.push({
          accountId,
          balance,
          isDelegating: true,
          vote: api.registry.createType('Vote', {
            aye: to.vote.isAye,
            conviction
          })
        });
      }
    });
    return votes;
  }));
}

function _referendumVotes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, referendum => (0,x_rxjs_index_js_.combineLatest)([api.derive.democracy.sqrtElectorate(), (0,index_js_.isFunction)(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)]).pipe((0,operators/* map */.UI)(([sqrtElectorate, votes]) => calcVotes(sqrtElectorate, referendum, votes))));
}
function _referendumsVotes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, referendums => referendums.length ? (0,x_rxjs_index_js_.combineLatest)(referendums.map(referendum => api.derive.democracy._referendumVotes(referendum))) : (0,x_rxjs_index_js_.of)([]));
}
function _referendumInfo(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (index, info) => {
    const status = getStatus(info);
    return status ? api.query.democracy.preimages(status.proposalHash).pipe((0,operators/* map */.UI)(preimage => ({
      image: parseImage(api, preimage),
      imageHash: status.proposalHash,
      index: api.registry.createType('ReferendumIndex', index),
      status
    }))) : (0,x_rxjs_index_js_.of)(null);
  });
}
function referendumsInfo(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, ids => ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe((0,operators/* switchMap */.wt)(infos => (0,x_rxjs_index_js_.combineLatest)(ids.map((id, index) => api.derive.democracy._referendumInfo(id, infos[index])))), (0,operators/* map */.UI)(infos => infos.filter(referendum => !!referendum))) : (0,x_rxjs_index_js_.of)([]));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function sqrtElectorate(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.balances.totalIssuance().pipe((0,operators/* map */.UI)(totalIssuance => (0,index_js_.bnSqrt)(totalIssuance))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/democracy/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0












;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/elections/info.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

 // SeatHolder is current tuple is 2.x-era Substrate

function isSeatHolder(value) {
  return !Array.isArray(value);
}

function isCandidateTuple(value) {
  return Array.isArray(value);
}

function getAccountTuple(value) {
  return isSeatHolder(value) ? [value.who, value.stake] : value;
}

function getCandidate(value) {
  return isCandidateTuple(value) ? value[0] : value;
}

function sortAccounts([, balanceA], [, balanceB]) {
  return balanceB.cmp(balanceA);
}

function queryElections(api) {
  const section = api.query.phragmenElection ? 'phragmenElection' : api.query.electionsPhragmen ? 'electionsPhragmen' : 'elections';
  return api.queryMulti([api.query.council.members, api.query[section].candidates, api.query[section].members, api.query[section].runnersUp]).pipe((0,operators/* map */.UI)(([councilMembers, candidates, members, runnersUp]) => ({
    candidacyBond: api.consts[section].candidacyBond,
    candidateCount: api.registry.createType('u32', candidates.length),
    candidates: candidates.map(getCandidate),
    desiredRunnersUp: api.consts[section].desiredRunnersUp,
    desiredSeats: api.consts[section].desiredMembers,
    members: members.length ? members.map(getAccountTuple).sort(sortAccounts) : councilMembers.map(accountId => [accountId, api.registry.createType('Balance')]),
    runnersUp: runnersUp.map(getAccountTuple).sort(sortAccounts),
    termDuration: api.consts[section].termDuration,
    votingBond: api.consts[section].votingBond
  })));
}
/**
 * @name info
 * @returns An object containing the combined results of the storage queries for
 * all relevant election module properties.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.elections.info(({ members, candidates }) => {
 *   console.log(`There are currently ${members.length} council members and ${candidates.length} prospective council candidates.`);
 * });
 * ```
 */


function info_info(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => queryElections(api));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/elections/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function mapResult([result, validators, heartbeats, numBlocks]) {
  validators.forEach((validator, index) => {
    const validatorId = validator.toString();
    const blockCount = numBlocks[index];
    const hasMessage = !heartbeats[index].isEmpty;
    const prev = result[validatorId];

    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {
      result[validatorId] = {
        blockCount,
        hasMessage,
        isOnline: hasMessage || blockCount.gt(index_js_.BN_ZERO)
      };
    }
  });
  return result;
}
/**
 * @description Return a boolean array indicating whether the passed accounts had received heartbeats in the current session
 */


function receivedHeartbeats(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$imOnline;

    return (_api$query$imOnline = api.query.imOnline) !== null && _api$query$imOnline !== void 0 && _api$query$imOnline.receivedHeartbeats ? api.derive.staking.overview().pipe((0,operators/* switchMap */.wt)(({
      currentIndex,
      validators
    }) => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)({}), (0,x_rxjs_index_js_.of)(validators), api.query.imOnline.receivedHeartbeats.multi(validators.map((_address, index) => [currentIndex, index])), api.query.imOnline.authoredBlocks.multi(validators.map(address => [currentIndex, address]))])), (0,operators/* map */.UI)(mapResult)) : (0,x_rxjs_index_js_.of)({});
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/imOnline/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/membership/proposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function membership_proposals_proposals(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, proposals(instanceId, api, 'membership'));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/membership/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/parachains/util.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function didUpdateToBool(didUpdate, id) {
  return didUpdate.isSome ? didUpdate.unwrap().some(paraId => paraId.eq(id)) : false;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/parachains/info.js


function info_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function info_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { info_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { info_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function parseActive(id, active) {
  const found = active.find(([paraId]) => paraId === id);

  if (found && found[1].isSome) {
    const [collatorId, retriable] = found[1].unwrap();
    return info_objectSpread({
      collatorId
    }, retriable.isWithRetries ? {
      isRetriable: true,
      retries: retriable.asWithRetries.toNumber()
    } : {
      isRetriable: false,
      retries: 0
    });
  }

  return null;
}

function parseCollators(id, collatorQueue) {
  return collatorQueue.map(queue => {
    const found = queue.find(([paraId]) => paraId === id);
    return found ? found[1] : null;
  });
}

function info_parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {
  if (info.isNone) {
    return null;
  }

  return {
    active: parseActive(id, active),
    didUpdate: didUpdateToBool(didUpdate, id),
    heads,
    id,
    info: info_objectSpread({
      id
    }, info.unwrap()),
    pendingSwapId: pendingSwap.unwrapOr(null),
    relayDispatchQueue,
    retryCollators: parseCollators(id, retryQueue),
    selectedCollators: parseCollators(id, selectedThreads)
  };
}

function parachains_info_info(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, id => api.query.registrar && api.query.parachains ? api.queryMulti([api.query.registrar.active, api.query.registrar.retryQueue, api.query.registrar.selectedThreads, api.query.parachains.didUpdate, [api.query.registrar.paras, id], [api.query.registrar.pendingSwap, id], [api.query.parachains.heads, id], [api.query.parachains.relayDispatchQueue, id]]).pipe((0,operators/* map */.UI)(result => info_parse(api.registry.createType('ParaId', id), result))) : (0,x_rxjs_index_js_.of)(null));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/parachains/overview.js


function overview_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function overview_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { overview_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { overview_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function overview_parse([ids, didUpdate, infos, pendingSwaps, relayDispatchQueueSizes]) {
  return ids.map((id, index) => ({
    didUpdate: didUpdateToBool(didUpdate, id),
    id,
    info: overview_objectSpread({
      id
    }, infos[index].unwrapOr(null)),
    pendingSwapId: pendingSwaps[index].unwrapOr(null),
    relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()
  }));
}

function overview(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => {
    var _api$query$registrar;

    return (_api$query$registrar = api.query.registrar) !== null && _api$query$registrar !== void 0 && _api$query$registrar.parachains && api.query.parachains ? api.query.registrar.parachains().pipe((0,operators/* switchMap */.wt)(paraIds => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(paraIds), api.query.parachains.didUpdate(), api.query.registrar.paras.multi(paraIds), api.query.registrar.pendingSwap.multi(paraIds), api.query.parachains.relayDispatchQueueSize.multi(paraIds)])), (0,operators/* map */.UI)(overview_parse)) : (0,x_rxjs_index_js_.of)([]);
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/parachains/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/eraLength.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function eraLength(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.session.info().pipe((0,operators/* map */.UI)(info => info.eraLength)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/eraProgress.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function eraProgress(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.session.progress().pipe((0,operators/* map */.UI)(info => info.eraProgress)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/indexes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


 // parse into Indexes

function indexes_parse([currentIndex, activeEra, activeEraStart, currentEra, validatorCount]) {
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    validatorCount
  };
} // query based on latest


function queryStaking(api) {
  return api.queryMulti([api.query.session.currentIndex, api.query.staking.activeEra, api.query.staking.currentEra, api.query.staking.validatorCount]).pipe((0,operators/* map */.UI)(([currentIndex, activeOpt, currentEra, validatorCount]) => {
    const {
      index,
      start
    } = activeOpt.unwrapOrDefault();
    return indexes_parse([currentIndex, index, start, currentEra.unwrapOrDefault(), validatorCount]);
  }));
} // query based on latest


function querySession(api) {
  return api.query.session.currentIndex().pipe((0,operators/* map */.UI)(currentIndex => indexes_parse([currentIndex, api.registry.createType('EraIndex'), api.registry.createType('Option<Moment>'), api.registry.createType('EraIndex'), api.registry.createType('u32')])));
} // empty set when none is available


function empty(api) {
  return (0,x_rxjs_index_js_.of)(indexes_parse([api.registry.createType('SessionIndex', 1), api.registry.createType('EraIndex'), api.registry.createType('Option<Moment>'), api.registry.createType('EraIndex'), api.registry.createType('u32')]));
}

function indexes_indexes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.session ? api.query.staking ? queryStaking(api) : querySession(api) : empty(api));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/info.js


function session_info_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function session_info_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { session_info_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { session_info_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */

function session_info_info(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.session.indexes().pipe((0,operators/* map */.UI)(indexes => {
    var _api$consts, _api$consts$babe, _api$consts2, _api$consts2$staking;

    const sessionLength = ((_api$consts = api.consts) === null || _api$consts === void 0 ? void 0 : (_api$consts$babe = _api$consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.epochDuration) || api.registry.createType('u64', 1);
    const sessionsPerEra = ((_api$consts2 = api.consts) === null || _api$consts2 === void 0 ? void 0 : (_api$consts2$staking = _api$consts2.staking) === null || _api$consts2$staking === void 0 ? void 0 : _api$consts2$staking.sessionsPerEra) || api.registry.createType('SessionIndex', 1);
    return session_info_objectSpread(session_info_objectSpread({}, indexes), {}, {
      eraLength: api.registry.createType('BlockNumber', sessionsPerEra.mul(sessionLength)),
      isEpoch: !!api.query.babe,
      sessionLength,
      sessionsPerEra
    });
  })));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/progress.js


function progress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function progress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { progress_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { progress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function createDerive(api, info, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]) {
  const epochStartSlot = epochIndex.mul(info.sessionLength).iadd(epochOrGenesisStartSlot);
  const sessionProgress = currentSlot.sub(epochStartSlot);
  const eraProgress = info.currentIndex.sub(activeEraStartSessionIndex).imul(info.sessionLength).iadd(sessionProgress);
  return progress_objectSpread(progress_objectSpread({}, info), {}, {
    eraProgress: api.registry.createType('BlockNumber', eraProgress),
    sessionProgress: api.registry.createType('BlockNumber', sessionProgress)
  });
}

function queryAura(api) {
  return api.derive.session.info().pipe((0,operators/* map */.UI)(info => progress_objectSpread(progress_objectSpread({}, info), {}, {
    eraProgress: api.registry.createType('BlockNumber'),
    sessionProgress: api.registry.createType('BlockNumber')
  })));
}

function queryBabe(api) {
  return api.derive.session.info().pipe((0,operators/* switchMap */.wt)(info => {
    var _api$query$staking;

    return (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(info), // we may have no staking, but have babe (permissioned)
    (_api$query$staking = api.query.staking) !== null && _api$query$staking !== void 0 && _api$query$staking.erasStartSessionIndex ? api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, [api.query.staking.erasStartSessionIndex, info.activeEra]]) : api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot])]);
  }), (0,operators/* map */.UI)(([info, [currentSlot, epochIndex, genesisSlot, optStartIndex]]) => [info, [currentSlot, epochIndex, genesisSlot, optStartIndex && optStartIndex.isSome ? optStartIndex.unwrap() : api.registry.createType('SessionIndex', 1)]]));
}
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */


function progress(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.babe ? queryBabe(api).pipe((0,operators/* map */.UI)(([info, slots]) => createDerive(api, info, slots))) : queryAura(api));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/sessionProgress.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function sessionProgress(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.session.progress().pipe((0,operators/* map */.UI)(info => info.sessionProgress)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/session/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0






;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/society/candidates.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @description Get the candidate info for a society
 */
function candidates(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.society.candidates().pipe((0,operators/* switchMap */.wt)(candidates => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(candidates), api.query.society.suspendedCandidates.multi(candidates.map(({
    who
  }) => who))])), (0,operators/* map */.UI)(([candidates, suspended]) => candidates.map(({
    kind,
    value,
    who
  }, index) => ({
    accountId: who,
    isSuspended: suspended[index].isSome,
    kind,
    value
  })))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/society/info.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @description Get the overall info for a society
 */
function society_info_info(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.queryMulti([api.query.society.bids, api.query.society.defender, api.query.society.founder, api.query.society.head, api.query.society.maxMembers, api.query.society.pot]).pipe((0,operators/* map */.UI)(([bids, defender, founder, head, maxMembers, pot]) => ({
    bids,
    defender: defender.unwrapOr(undefined),
    founder: founder.unwrapOr(undefined),
    hasDefender: defender.isSome && head.isSome && !head.eq(defender) || false,
    head: head.unwrapOr(undefined),
    maxMembers,
    pot
  }))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/society/member.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @description Get the member info for a society
 */

function member(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.derive.society._members([accountId]).pipe((0,operators/* map */.UI)(([result]) => result)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/society/members.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function _members(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountIds => (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(accountIds), api.query.society.payouts.multi(accountIds), api.query.society.strikes.multi(accountIds), api.query.society.defenderVotes.multi(accountIds), api.query.society.suspendedMembers.multi(accountIds), api.query.society.vouching.multi(accountIds)]).pipe((0,operators/* map */.UI)(([accountIds, payouts, strikes, defenderVotes, suspended, vouching]) => accountIds.map((accountId, index) => ({
    accountId,
    isDefenderVoter: defenderVotes[index].isSome,
    isSuspended: suspended[index].isTrue,
    payouts: payouts[index],
    strikes: strikes[index],
    vote: defenderVotes[index].unwrapOr(undefined),
    vouching: vouching[index].unwrapOr(undefined)
  })))));
}
/**
 * @description Get the member info for a society
 */

function members(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.society.members().pipe((0,operators/* switchMap */.wt)(members => api.derive.society._members(members))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/society/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/account.js


function staking_account_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function staking_account_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { staking_account_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { staking_account_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





const QUERY_OPTS = {
  withDestination: true,
  withLedger: true,
  withNominations: true,
  withPrefs: true
};

function groupByEra(list) {
  return list.reduce((map, {
    era,
    value
  }) => {
    const key = era.toString();
    map[key] = (map[key] || index_js_.BN_ZERO).add(value.unwrap());
    return map;
  }, {});
}

function calculateUnlocking(api, stakingLedger, sessionInfo) {
  const results = Object.entries(groupByEra(((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).filter(({
    era
  }) => era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value]) => ({
    remainingEras: new bn(eraString).isub(sessionInfo.activeEra),
    value: api.registry.createType('Balance', value)
  }));
  return results.length ? results : undefined;
}

function redeemableSum(api, stakingLedger, sessionInfo) {
  return api.registry.createType('Balance', ((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).reduce((total, {
    era,
    value
  }) => {
    return sessionInfo.activeEra.gte(era.unwrap()) ? total.iadd(value.unwrap()) : total;
  }, new bn(0)));
}

function account_parseResult(api, sessionInfo, keys, query) {
  return staking_account_objectSpread(staking_account_objectSpread(staking_account_objectSpread({}, keys), query), {}, {
    redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),
    unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)
  });
}
/**
 * @description From a list of stashes, fill in all the relevant staking details
 */


function accounts(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountIds => api.derive.session.info().pipe((0,operators/* switchMap */.wt)(sessionInfo => (0,x_rxjs_index_js_.combineLatest)([api.derive.staking.keysMulti(accountIds), api.derive.staking.queryMulti(accountIds, QUERY_OPTS)]).pipe((0,operators/* map */.UI)(([keys, queries]) => queries.map((query, index) => account_parseResult(api, sessionInfo, keys[index], query)))))));
}
/**
 * @description From a stash, retrieve the controllerId and fill in all the relevant staking details
 */

function account_account(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, accountId => api.derive.staking.accounts([accountId]).pipe((0,operators/* map */.UI)(([first]) => first)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/currentPoints.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @description Retrieve the staking overview, including elected and points earned
 */

function currentPoints(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.derive.session.indexes().pipe((0,operators/* switchMap */.wt)(({
    activeEra
  }) => api.query.staking.erasRewardPoints(activeEra))));
}
// EXTERNAL MODULE: ../../node_modules/@polkadot/api-derive/util/cache.js
var cache = __webpack_require__(44119);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasExposure.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



const CACHE_KEY = 'eraExposure';

function mapStakers(era, stakers) {
  const nominators = {};
  const validators = {};
  stakers.forEach(([key, exposure]) => {
    const validatorId = key.args[1].toString();
    validators[validatorId] = exposure;
    exposure.others.forEach(({
      who
    }, validatorIndex) => {
      const nominatorId = who.toString();
      nominators[nominatorId] = nominators[nominatorId] || [];
      nominators[nominatorId].push({
        validatorId,
        validatorIndex
      });
    });
  });
  return {
    era,
    nominators,
    validators
  };
}

function _eraExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : cache/* deriveCache.get */.G.get(cacheKey);
    return cached ? (0,x_rxjs_index_js_.of)(cached) : api.query.staking.erasStakersClipped.entries(era).pipe((0,operators/* map */.UI)(stakers => {
      const value = mapStakers(era, stakers);
      !withActive && cache/* deriveCache.set */.G.set(cacheKey, value);
      return value;
    }));
  });
}
function eraExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, era => api.derive.staking._eraExposure(era, true));
}
function _erasExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => eras.length ? (0,x_rxjs_index_js_.combineLatest)(eras.map(era => api.derive.staking._eraExposure(era, withActive))) : (0,x_rxjs_index_js_.of)([]));
}
function erasExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._erasExposure(eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasHistoric.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function erasHistoric(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, withActive => api.queryMulti([api.query.staking.activeEra, api.query.staking.historyDepth]).pipe((0,operators/* map */.UI)(([activeEraOpt, historyDepth]) => {
    const result = [];
    const max = historyDepth.toNumber();
    const activeEra = activeEraOpt.unwrapOrDefault().index;
    let lastEra = activeEra;

    while (lastEra.gten(0) && result.length < max) {
      if (lastEra !== activeEra || withActive === true) {
        result.push(api.registry.createType('EraIndex', lastEra));
      }

      lastEra = lastEra.subn(1);
    } // go from oldest to newest


    return result.reverse();
  })));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/util.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function filterEras(eras, list) {
  return eras.filter(era => !list.some(entry => era.eq(entry.era)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasPoints.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





const erasPoints_CACHE_KEY = 'eraPoints';

function mapValidators({
  individual
}) {
  return [...individual.entries()].filter(([, points]) => points.gt(index_js_.BN_ZERO)).reduce((result, [validatorId, points]) => {
    result[validatorId.toString()] = points;
    return result;
  }, {});
}

function mapPoints(eras, points) {
  return eras.map((era, index) => ({
    era,
    eraPoints: points[index].total,
    validators: mapValidators(points[index])
  }));
}

function _erasPoints(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0,x_rxjs_index_js_.of)([]);
    }

    const cached = withActive ? [] : eras.map(era => cache/* deriveCache.get */.G.get(`${erasPoints_CACHE_KEY}-${era.toString()}`)).filter(value => !!value);
    const remaining = filterEras(eras, cached);
    return !remaining.length ? (0,x_rxjs_index_js_.of)(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe((0,operators/* map */.UI)(points => {
      const query = mapPoints(remaining, points);
      !withActive && query.forEach(q => cache/* deriveCache.set */.G.set(`${erasPoints_CACHE_KEY}-${q.era.toString()}`, q));
      return eras.map(era => cached.find(cached => era.eq(cached.era)) || query.find(query => era.eq(query.era)));
    }));
  });
}
function erasPoints(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._erasPoints(eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasPrefs.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



const erasPrefs_CACHE_KEY = 'eraPrefs';

function mapPrefs(era, all) {
  const validators = {};
  all.forEach(([key, prefs]) => {
    validators[key.args[1].toString()] = prefs;
  });
  return {
    era,
    validators
  };
}

function _eraPrefs(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (era, withActive) => {
    const cacheKey = `${erasPrefs_CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : cache/* deriveCache.get */.G.get(cacheKey);
    return cached ? (0,x_rxjs_index_js_.of)(cached) : api.query.staking.erasValidatorPrefs.entries(era).pipe((0,operators/* map */.UI)(prefs => {
      const value = mapPrefs(era, prefs);
      !withActive && cache/* deriveCache.set */.G.set(cacheKey, value);
      return value;
    }));
  });
}
function eraPrefs(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, era => api.derive.staking._eraPrefs(era, true));
}
function _erasPrefs(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => eras.length ? (0,x_rxjs_index_js_.combineLatest)(eras.map(era => api.derive.staking._eraPrefs(era, withActive))) : (0,x_rxjs_index_js_.of)([]));
}
function erasPrefs(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._erasPrefs(eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasRewards.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




const erasRewards_CACHE_KEY = 'eraRewards';

function mapRewards(eras, optRewards) {
  return eras.map((era, index) => ({
    era,
    eraReward: optRewards[index].unwrapOrDefault()
  }));
}

function _erasRewards(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0,x_rxjs_index_js_.of)([]);
    }

    const cached = withActive ? [] : eras.map(era => cache/* deriveCache.get */.G.get(`${erasRewards_CACHE_KEY}-${era.toString()}`)).filter(value => !!value);
    const remaining = filterEras(eras, cached);

    if (!remaining.length) {
      return (0,x_rxjs_index_js_.of)(cached);
    }

    return api.query.staking.erasValidatorReward.multi(remaining).pipe((0,operators/* map */.UI)(optRewards => {
      const query = mapRewards(remaining, optRewards);
      !withActive && query.forEach(q => cache/* deriveCache.set */.G.set(`${erasRewards_CACHE_KEY}-${q.era.toString()}`, q));
      return eras.map(era => cached.find(cached => era.eq(cached.era)) || query.find(query => era.eq(query.era)));
    }));
  });
}
function erasRewards(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._erasRewards(eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/erasSlashes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



const erasSlashes_CACHE_KEY = 'eraSlashes';

function mapSlashes(era, noms, vals) {
  const nominators = {};
  const validators = {};
  noms.forEach(([key, optBalance]) => {
    nominators[key.args[1].toString()] = optBalance.unwrap();
  });
  vals.forEach(([key, optRes]) => {
    validators[key.args[1].toString()] = optRes.unwrapOrDefault()[1];
  });
  return {
    era,
    nominators,
    validators
  };
}

function _eraSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (era, withActive) => {
    const cacheKey = `${erasSlashes_CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : cache/* deriveCache.get */.G.get(cacheKey);
    return cached ? (0,x_rxjs_index_js_.of)(cached) : (0,x_rxjs_index_js_.combineLatest)([api.query.staking.nominatorSlashInEra.entries(era), api.query.staking.validatorSlashInEra.entries(era)]).pipe((0,operators/* map */.UI)(([noms, vals]) => {
      const value = mapSlashes(era, noms, vals);
      !withActive && cache/* deriveCache.set */.G.set(cacheKey, value);
      return value;
    }));
  });
}
function eraSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, era => api.derive.staking._eraSlashes(era, true));
}
function _erasSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => eras.length ? (0,x_rxjs_index_js_.combineLatest)(eras.map(era => api.derive.staking._eraSlashes(era, withActive))) : (0,x_rxjs_index_js_.of)([]));
}
function erasSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._erasSlashes(eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/electedInfo.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



const DEFAULT_FLAGS = {
  withController: true,
  withExposure: true,
  withPrefs: true
};

function combineAccounts(nextElected, validators) {
  return (0,index_js_.arrayFlatten)([nextElected, validators.filter(v => !nextElected.find(n => n.eq(v)))]);
}

function electedInfo(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (flags = DEFAULT_FLAGS) => api.derive.staking.validators().pipe((0,operators/* switchMap */.wt)(({
    nextElected,
    validators
  }) => api.derive.staking.queryMulti(combineAccounts(nextElected, validators), flags).pipe((0,operators/* map */.UI)(info => ({
    info,
    nextElected,
    validators
  }))))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/keys.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function extractsIds(stashId, queuedKeys, nextKeys) {
  const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [undefined, []])[1];
  const nextSessionIds = nextKeys.unwrapOr([]);
  return {
    nextSessionIds,
    sessionIds
  };
}

function keys(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, stashId => api.derive.staking.keysMulti([stashId]).pipe((0,operators/* map */.UI)(([first]) => first)));
}
function keysMulti(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, stashIds => stashIds.length ? api.query.session.queuedKeys().pipe((0,operators/* switchMap */.wt)(queuedKeys => {
    var _api$consts$session;

    return (0,x_rxjs_index_js_.combineLatest)([(0,x_rxjs_index_js_.of)(queuedKeys), (_api$consts$session = api.consts.session) !== null && _api$consts$session !== void 0 && _api$consts$session.dedupKeyPrefix ? api.query.session.nextKeys.multi(stashIds.map(stashId => [api.consts.session.dedupKeyPrefix, stashId])) : api.query.session.nextKeys.multi(stashIds)]);
  }), (0,operators/* map */.UI)(([queuedKeys, nextKeys]) => stashIds.map((stashId, index) => extractsIds(stashId, queuedKeys, nextKeys[index])))) : (0,x_rxjs_index_js_.of)([]));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/overview.js


function staking_overview_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function staking_overview_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { staking_overview_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { staking_overview_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @description Retrieve the staking overview, including elected and points earned
 */

function overview_overview(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => (0,x_rxjs_index_js_.combineLatest)([api.derive.session.indexes(), api.derive.staking.validators()]).pipe((0,operators/* map */.UI)(([indexes, {
    nextElected,
    validators
  }]) => staking_overview_objectSpread(staking_overview_objectSpread({}, indexes), {}, {
    nextElected,
    validators
  }))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/ownExposure.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function _ownExposures(instanceId, api) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return (0,memo/* memo */.X)(instanceId, (accountId, eras, _withActive) => eras.length ? api.queryMulti([...eras.map(era => [api.query.staking.erasStakersClipped, [era, accountId]]), ...eras.map(era => [api.query.staking.erasStakers, [era, accountId]])]).pipe((0,operators/* map */.UI)(all => eras.map((era, index) => ({
    clipped: all[index],
    era,
    exposure: all[eras.length + index]
  })))) : (0,x_rxjs_index_js_.of)([]));
}
function ownExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, era) => api.derive.staking._ownExposures(accountId, [era], true).pipe((0,operators/* map */.UI)(([first]) => first)));
}
function ownExposures(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => {
    return api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._ownExposures(accountId, eras, withActive)));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/ownSlashes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function _ownSlashes(instanceId, api) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return (0,memo/* memo */.X)(instanceId, (accountId, eras, _withActive) => eras.length ? api.queryMulti([...eras.map(era => [api.query.staking.validatorSlashInEra, [era, accountId]]), ...eras.map(era => [api.query.staking.nominatorSlashInEra, [era, accountId]])]).pipe((0,operators/* map */.UI)(values => eras.map((era, index) => ({
    era,
    total: values[index].isSome ? values[index].unwrap()[1] : values[index + eras.length].unwrapOrDefault()
  })))) : (0,x_rxjs_index_js_.of)([]));
}
function ownSlash(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, era) => api.derive.staking._ownSlashes(accountId, [era], true).pipe((0,operators/* map */.UI)(([first]) => first)));
}
function ownSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => {
    return api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._ownSlashes(accountId, eras, withActive)));
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/query.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {
  return {
    accountId: stashId,
    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),
    exposure,
    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],
    rewardDestination,
    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
    stashId,
    validatorPrefs
  };
}

function getLedgers(api, optIds, {
  withLedger = false
}) {
  const ids = optIds.filter(opt => withLedger && !!opt && opt.isSome).map(opt => opt.unwrap());
  const emptyLed = api.registry.createType('Option<StakingLedger>');
  return (ids.length ? api.query.staking.ledger.multi(ids) : (0,x_rxjs_index_js_.of)([])).pipe((0,operators/* map */.UI)(optLedgers => {
    let offset = -1;
    return optIds.map(opt => opt && opt.isSome ? optLedgers[++offset] || emptyLed : emptyLed);
  }));
}

function getStashInfo(api, stashIds, activeEra, {
  withController,
  withDestination,
  withExposure,
  withLedger,
  withNominations,
  withPrefs
}) {
  const emptyNoms = api.registry.createType('Option<Nominations>');
  const emptyRewa = api.registry.createType('RewardDestination');
  const emptyExpo = api.registry.createType('Exposure');
  const emptyPrefs = api.registry.createType('ValidatorPrefs');
  return (0,x_rxjs_index_js_.combineLatest)([withController || withLedger ? api.query.staking.bonded.multi(stashIds) : (0,x_rxjs_index_js_.of)(stashIds.map(() => null)), withNominations ? api.query.staking.nominators.multi(stashIds) : (0,x_rxjs_index_js_.of)(stashIds.map(() => emptyNoms)), withDestination ? api.query.staking.payee.multi(stashIds) : (0,x_rxjs_index_js_.of)(stashIds.map(() => emptyRewa)), withPrefs ? api.query.staking.validators.multi(stashIds) : (0,x_rxjs_index_js_.of)(stashIds.map(() => emptyPrefs)), withExposure ? api.query.staking.erasStakers.multi(stashIds.map(stashId => [activeEra, stashId])) : (0,x_rxjs_index_js_.of)(stashIds.map(() => emptyExpo))]);
}

function getBatch(api, activeEra, stashIds, flags) {
  return getStashInfo(api, stashIds, activeEra, flags).pipe((0,operators/* switchMap */.wt)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe((0,operators/* map */.UI)(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));
} //

/**
 * @description From a stash, retrieve the controllerId and all relevant details
 */


function query(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, flags) => api.derive.staking.queryMulti([accountId], flags).pipe((0,operators/* map */.UI)(([first]) => first)));
}
function queryMulti(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, flags) => accountIds.length ? api.derive.session.indexes().pipe((0,operators/* switchMap */.wt)(({
    activeEra
  }) => {
    const stashIds = accountIds.map(accountId => api.registry.createType('AccountId', accountId));
    return getBatch(api, activeEra, stashIds, flags);
  })) : (0,x_rxjs_index_js_.of)([]));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stakerExposure.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function _stakerExposures(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, eras, withActive) => {
    const stakerIds = accountIds.map(a => api.registry.createType('AccountId', a).toString());
    return api.derive.staking._erasExposure(eras, withActive).pipe((0,operators/* map */.UI)(exposures => stakerIds.map(stakerId => exposures.map(({
      era,
      nominators: allNominators,
      validators: allValidators
    }) => {
      const isValidator = !!allValidators[stakerId];
      const validators = {};
      const nominating = allNominators[stakerId] || [];

      if (isValidator) {
        validators[stakerId] = allValidators[stakerId];
      } else if (nominating) {
        nominating.forEach(({
          validatorId
        }) => {
          validators[validatorId] = allValidators[validatorId];
        });
      }

      return {
        era,
        isEmpty: !Object.keys(validators).length,
        isValidator,
        nominating,
        validators
      };
    }))));
  });
}
function stakerExposures(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._stakerExposures(accountIds, eras, withActive))));
}
function stakerExposure(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => api.derive.staking.stakerExposures([accountId, withActive]).pipe((0,operators/* map */.UI)(([first]) => first)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stakerPoints.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function _stakerPoints(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, eras, withActive) => {
    const stakerId = api.registry.createType('AccountId', accountId).toString();
    return api.derive.staking._erasPoints(eras, withActive).pipe((0,operators/* map */.UI)(points => points.map(({
      era,
      eraPoints,
      validators
    }) => ({
      era,
      eraPoints,
      points: validators[stakerId] || api.registry.createType('RewardPoint')
    }))));
  });
}
function stakerPoints(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._stakerPoints(accountId, eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stakerPrefs.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function _stakerPrefs(instanceId, api) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return (0,memo/* memo */.X)(instanceId, (accountId, eras, _withActive) => api.query.staking.erasValidatorPrefs.multi(eras.map(era => [era, accountId])).pipe((0,operators/* map */.UI)(all => all.map((validatorPrefs, index) => ({
    era: eras[index],
    validatorPrefs
  })))));
}
function stakerPrefs(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._stakerPrefs(accountId, eras, withActive))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stakerRewards.js


function stakerRewards_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function stakerRewards_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { stakerRewards_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { stakerRewards_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {
  return exposures.map(({
    era,
    isEmpty,
    isValidator,
    nominating,
    validators: eraValidators
  }) => {
    const {
      eraPoints,
      validators: allValPoints
    } = erasPoints.find(p => p.era.eq(era)) || {
      eraPoints: index_js_.BN_ZERO,
      validators: {}
    };
    const {
      eraReward
    } = erasRewards.find(r => r.era.eq(era)) || {
      eraReward: api.registry.createType('Balance')
    };
    const {
      validators: allValPrefs
    } = erasPrefs.find(p => p.era.eq(era)) || {
      validators: {}
    };
    const validators = {};
    const stakerId = stashId.toString();
    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {
      var _allValPrefs$validato, _exposure$total;

      const valPoints = allValPoints[validatorId] || index_js_.BN_ZERO;
      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || index_js_.BN_ZERO;
      const expTotal = ((_exposure$total = exposure.total) === null || _exposure$total === void 0 ? void 0 : _exposure$total.unwrap()) || index_js_.BN_ZERO;
      let avail = index_js_.BN_ZERO;
      let value;

      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {
        avail = eraReward.mul(valPoints).div(eraPoints);
        const valCut = valComm.mul(avail).div(index_js_.BN_BILLION);
        let staked;

        if (validatorId === stakerId) {
          staked = exposure.own.unwrap();
        } else {
          const stakerExp = exposure.others.find(({
            who
          }) => who.eq(stakerId));
          staked = stakerExp ? stakerExp.value.unwrap() : index_js_.BN_ZERO;
        }

        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : index_js_.BN_ZERO);
      }

      validators[validatorId] = {
        total: api.registry.createType('Balance', avail),
        value: api.registry.createType('Balance', value)
      };
    });
    return {
      era,
      eraReward,
      isEmpty,
      isValidator,
      nominating,
      validators
    };
  });
}

function allUniqValidators(rewards) {
  return rewards.reduce(([all, perStash], rewards) => {
    const uniq = [];
    perStash.push(uniq);
    rewards.forEach(({
      validators
    }) => Object.keys(validators).forEach(validatorId => {
      if (!uniq.includes(validatorId)) {
        uniq.push(validatorId);

        if (!all.includes(validatorId)) {
          all.push(validatorId);
        }
      }
    }));
    return [all, perStash];
  }, [[], []]);
}

function removeClaimed(validators, queryValidators, reward) {
  const rm = [];
  Object.keys(reward.validators).forEach(validatorId => {
    const index = validators.indexOf(validatorId);

    if (index !== -1) {
      const valLedger = queryValidators[index].stakingLedger;

      if (valLedger !== null && valLedger !== void 0 && valLedger.claimedRewards.some(era => reward.era.eq(era))) {
        rm.push(validatorId);
      }
    }
  });
  rm.forEach(validatorId => {
    delete reward.validators[validatorId];
  });
}

function filterRewards(eras, valInfo, {
  rewards,
  stakingLedger
}) {
  const filter = eras.filter(era => !stakingLedger.claimedRewards.some(e => e.eq(era)));
  const validators = valInfo.map(([v]) => v);
  const queryValidators = valInfo.map(([, q]) => q);
  return rewards.filter(({
    isEmpty
  }) => !isEmpty).filter(reward => {
    if (!filter.some(filter => reward.era.eq(filter))) {
      return false;
    }

    reward.isStakerPayout = true;
    removeClaimed(validators, queryValidators, reward);
    return true;
  }).filter(({
    validators
  }) => Object.keys(validators).length !== 0).map(reward => stakerRewards_objectSpread(stakerRewards_objectSpread({}, reward), {}, {
    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])
  }));
}

function _stakerRewardsEras(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (eras, withActive) => (0,x_rxjs_index_js_.combineLatest)([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));
}
function _stakerRewards(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, eras, withActive) => (0,x_rxjs_index_js_.combineLatest)([api.derive.staking.queryMulti(accountIds, {
    withLedger: true
  }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe((0,operators/* switchMap */.wt)(([queries, exposures, erasResult]) => {
    const allRewards = queries.map(({
      stakingLedger,
      stashId
    }, index) => !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]));

    if (withActive) {
      return (0,x_rxjs_index_js_.of)(allRewards);
    }

    const [allValidators, stashValidators] = allUniqValidators(allRewards);
    return api.derive.staking.queryMulti(allValidators, {
      withLedger: true
    }).pipe((0,operators/* map */.UI)(queriedVals => {
      return queries.map(({
        stakingLedger
      }, index) => {
        const rewards = allRewards[index];
        const ownValidators = stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]);
        return filterRewards(eras, ownValidators, {
          rewards,
          stakingLedger
        });
      });
    }));
  })));
}
function stakerRewards(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._stakerRewards([accountId], eras, withActive)), (0,operators/* map */.UI)(([first]) => first)));
}
function stakerRewardsMultiEras(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : (0,x_rxjs_index_js_.of)([]));
}
function stakerRewardsMulti(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stakerSlashes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function _stakerSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, eras, withActive) => {
    const stakerId = api.registry.createType('AccountId', accountId).toString();
    return api.derive.staking._erasSlashes(eras, withActive).pipe((0,operators/* map */.UI)(slashes => slashes.map(({
      era,
      nominators,
      validators
    }) => ({
      era,
      total: nominators[stakerId] || validators[stakerId] || api.registry.createType('Balance')
    }))));
  });
}
function stakerSlashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0,operators/* switchMap */.wt)(eras => api.derive.staking._stakerSlashes(accountId, eras, withActive))));
}
// EXTERNAL MODULE: ../../node_modules/@polkadot/rpc-core/util/drr.js
var drr = __webpack_require__(54141);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/stashes.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function onBondedEvent(api) {
  let current = Date.now();
  return api.query.system.events().pipe((0,operators/* map */.UI)(events => {
    current = events.filter(({
      event,
      phase
    }) => {
      try {
        return phase.isApplyExtrinsic && event.section === 'staking' && event.method === 'Bonded';
      } catch {
        return false;
      }
    }) ? Date.now() : current;
    return current;
  }), (0,operators/* startWith */.O4)(current), (0,drr/* drr */.h)({
    skipTimeout: true
  }));
}
/**
 * @description Retrieve the list of all validator stashes
 */


function stashes(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => onBondedEvent(api).pipe((0,operators/* switchMap */.wt)(() => api.query.staking.validators.keys()), (0,operators/* map */.UI)(keys => keys.map(({
    args: [validatorId]
  }) => validatorId).filter(a => a))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/validators.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function nextElected(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.staking.erasStakers ? api.derive.session.indexes().pipe( // only populate for next era in the last session, so track both here - entries are not
  // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
  (0,operators/* switchMap */.wt)(({
    currentEra
  }) => api.query.staking.erasStakers.keys(currentEra)), (0,operators/* map */.UI)(keys => keys.map(({
    args: [, accountId]
  }) => accountId))) : api.query.staking.currentElected());
}
/**
 * @description Retrieve latest list of validators
 */

function validators(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => // Sadly the node-template is (for some obscure reason) not comprehensive, so while the derive works
  // in all actual real-world deployed chains, it does create some confusion for limited template chains
  (0,x_rxjs_index_js_.combineLatest)([api.query.session ? api.query.session.validators() : (0,x_rxjs_index_js_.of)([]), api.query.staking ? api.derive.staking.nextElected() : (0,x_rxjs_index_js_.of)([])]).pipe((0,operators/* map */.UI)(([validators, nextElected]) => ({
    nextElected: nextElected.length ? nextElected : validators,
    validators
  }))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/waitingInfo.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



const waitingInfo_DEFAULT_FLAGS = {
  withController: true,
  withPrefs: true
};
function waitingInfo(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, (flags = waitingInfo_DEFAULT_FLAGS) => (0,x_rxjs_index_js_.combineLatest)([api.derive.staking.validators(), api.derive.staking.stashes()]).pipe((0,operators/* switchMap */.wt)(([{
    nextElected
  }, stashes]) => {
    const elected = nextElected.map(a => a.toString());
    const waiting = stashes.filter(v => !elected.includes(v.toString()));
    return api.derive.staking.queryMulti(waiting, flags).pipe((0,operators/* map */.UI)(info => ({
      info,
      waiting
    })));
  })));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/staking/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0






















;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/technicalCommittee/proposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


function technicalCommittee_proposals_proposals(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, proposals(instanceId, api, 'technicalCommittee'));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/technicalCommittee/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/treasury/proposals.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




function proposals_parseResult(api, {
  allIds,
  allProposals,
  approvalIds,
  councilProposals,
  proposalCount
}) {
  const approvals = [];
  const proposals = [];
  const councilTreasury = councilProposals.filter(({
    proposal
  }) => api.tx.treasury.approveProposal.is(proposal) || api.tx.treasury.rejectProposal.is(proposal));
  allIds.forEach((id, index) => {
    if (allProposals[index].isSome) {
      const council = councilTreasury.filter(({
        proposal
      }) => id.eq(proposal.args[0])).sort((a, b) => a.proposal.method.localeCompare(b.proposal.method));
      const isApproval = approvalIds.some(approvalId => approvalId.eq(id));
      const derived = {
        council,
        id,
        proposal: allProposals[index].unwrap()
      };

      if (isApproval) {
        approvals.push(derived);
      } else {
        proposals.push(derived);
      }
    }
  });
  return {
    approvals,
    proposalCount,
    proposals
  };
}

function retrieveProposals(api, proposalCount, approvalIds) {
  const proposalIds = [];
  const count = proposalCount.toNumber();

  for (let index = 0; index < count; index++) {
    if (!approvalIds.some(id => id.eqn(index))) {
      proposalIds.push(api.registry.createType('ProposalIndex', index));
    }
  }

  const allIds = [...proposalIds, ...approvalIds];
  return (0,x_rxjs_index_js_.combineLatest)([api.query.treasury.proposals.multi(allIds), api.derive.council ? api.derive.council.proposals() : (0,x_rxjs_index_js_.of)([])]).pipe((0,operators/* map */.UI)(([allProposals, councilProposals]) => proposals_parseResult(api, {
    allIds,
    allProposals,
    approvalIds,
    councilProposals,
    proposalCount
  })));
}
/**
 * @description Retrieve all active and approved treasury proposals, along with their info
 */


function treasury_proposals_proposals(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, () => api.query.treasury ? (0,x_rxjs_index_js_.combineLatest)([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe((0,operators/* switchMap */.wt)(([proposalCount, approvalIds]) => retrieveProposals(api, proposalCount, approvalIds))) : (0,x_rxjs_index_js_.of)({
    approvals: [],
    proposalCount: api.registry.createType('ProposalIndex'),
    proposals: []
  }));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/treasury/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/tx/events.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0



function events(instanceId, api) {
  return (0,memo/* memo */.X)(instanceId, at => (0,x_rxjs_index_js_.combineLatest)([api.query.system.events.at(at), api.rpc.chain.getBlock(at)]).pipe((0,operators/* map */.UI)(([events, block]) => ({
    block,
    events
  }))));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/tx/constants.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

const FALLBACK_MAX_HASH_COUNT = 250; // default here to 5 min eras, adjusted based on the actual blocktime

const FALLBACK_PERIOD = new bn(6 * 1000);
const MAX_FINALITY_LAG = new bn(5);
const MORTAL_PERIOD = new bn(5 * 60 * 1000);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/tx/signingInfo.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0





function latestNonce(api, address) {
  return api.derive.balances.account(address).pipe((0,operators/* map */.UI)(({
    accountNonce
  }) => accountNonce));
}

function nextNonce(api, address) {
  var _api$rpc$system;

  return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);
}

function signingHeader(api) {
  return (0,x_rxjs_index_js_.combineLatest)([api.rpc.chain.getHeader(), api.rpc.chain.getFinalizedHead()]).pipe((0,operators/* switchMap */.wt)(([bestHeader, finHash]) => // retrieve the headers - in the case of the current block, we use the parent
  // to minimize (not completely remove) the impact that forks do have on the system
  // (when at genesis, just return the current header as the last known)
  bestHeader.parentHash.isEmpty ? (0,x_rxjs_index_js_.of)([bestHeader, bestHeader]) : (0,x_rxjs_index_js_.combineLatest)([api.rpc.chain.getHeader(bestHeader.parentHash), api.rpc.chain.getHeader(finHash)])), (0,operators/* map */.UI)(([current, finalized]) => // determine the hash to use, current when lag > max, else finalized
  current.number.unwrap().sub(finalized.number.unwrap()).gt(MAX_FINALITY_LAG) ? current : finalized));
}

function signingInfo(_instanceId, api) {
  // no memo, we want to do this fresh on each run
  return (address, nonce, era) => (0,x_rxjs_index_js_.combineLatest)([// retrieve nonce if none was specified
  (0,index_js_.isUndefined)(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : (0,x_rxjs_index_js_.of)(api.registry.createType('Index', nonce)), // if no era (create) or era > 0 (mortal), do block retrieval
  (0,index_js_.isUndefined)(era) || (0,index_js_.isNumber)(era) && era > 0 ? signingHeader(api) : (0,x_rxjs_index_js_.of)(null)]).pipe((0,operators/* map */.UI)(([nonce, header]) => {
    var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;

    return {
      header,
      mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) === null || _api$consts$system$bl === void 0 ? void 0 : _api$consts$system$bl.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),
      nonce
    };
  }));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/tx/index.js
// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0


;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-derive/index.js


function api_derive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function api_derive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { api_derive_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { api_derive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0




















const derive = {
  accounts: accounts_namespaceObject,
  balances: balances_namespaceObject,
  bounties: api_derive_bounties_namespaceObject,
  chain: chain_namespaceObject,
  contracts: contracts_namespaceObject,
  council: council_namespaceObject,
  democracy: democracy_namespaceObject,
  elections: elections_namespaceObject,
  imOnline: imOnline_namespaceObject,
  membership: membership_namespaceObject,
  parachains: parachains_namespaceObject,
  session: session_namespaceObject,
  society: society_namespaceObject,
  staking: staking_namespaceObject,
  technicalCommittee: technicalCommittee_namespaceObject,
  treasury: treasury_namespaceObject,
  tx: tx_namespaceObject
};
// Enable derive only if some of these modules are available
const deriveAvail = {
  contracts: ['contracts'],
  council: ['council'],
  democracy: ['democracy'],
  elections: ['phragmenElection', 'electionsPhragmen', 'elections'],
  imOnline: ['imOnline'],
  membership: ['membership'],
  parachains: ['parachains', 'registrar'],
  session: ['session'],
  society: ['society'],
  staking: ['staking'],
  technicalCommittee: ['technicalCommittee'],
  treasury: ['treasury']
};
/**
 * Returns an object that will inject `api` into all the functions inside
 * `allSections`, and keep the object architecture of `allSections`.
 */

/** @internal */

function injectFunctions(instanceId, api, allSections) {
  const queryKeys = Object.keys(api.query);
  return Object.keys(allSections).filter(sectionName => !deriveAvail[sectionName] || deriveAvail[sectionName].some(query => queryKeys.includes(query))).reduce((deriveAcc, sectionName) => {
    const section = allSections[sectionName];
    deriveAcc[sectionName] = Object.keys(section).reduce((sectionAcc, _methodName) => {
      const methodName = _methodName; // Not sure what to do here, casting as any. Though the final types are good
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call

      const method = section[methodName](instanceId, api); // idem
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

      sectionAcc[methodName] = method;
      return sectionAcc;
    }, {});
    return deriveAcc;
  }, {});
} // FIXME The return type of this function should be {...ExactDerive, ...DeriveCustom}
// For now we just drop the custom derive typings

/** @internal */


function decorateDerive(instanceId, api, custom = {}) {
  return api_derive_objectSpread(api_derive_objectSpread({}, injectFunctions(instanceId, api, derive)), injectFunctions(instanceId, api, custom));
}
// EXTERNAL MODULE: ../../node_modules/@polkadot/metadata/decorate/constants/index.js
var constants = __webpack_require__(86600);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/errors/index.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0


function isError({
  error,
  index
}, sectionIndex, errorIndex) {
  return index.eq(sectionIndex) && error.eq(errorIndex);
}
/** @internal */


function decorateErrors(_, {
  modules
}, metaVersion) {
  return modules.reduce((result, {
    errors,
    index,
    name
  }, _sectionIndex) => {
    if (!errors.length) {
      return result;
    }

    const sectionIndex = metaVersion >= 12 ? index.toNumber() : _sectionIndex;
    result[(0,index_js_.stringCamelCase)(name)] = errors.reduce((newModule, meta, errorIndex) => {
      // we don't camelCase the error name
      newModule[meta.name.toString()] = {
        is: moduleError => isError(moduleError, sectionIndex, errorIndex),
        meta
      };
      return newModule;
    }, {});
    return result;
  }, {});
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/events/index.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0


function isEvent(event, sectionIndex, eventIndex) {
  return event.index[0] === sectionIndex && event.index[1] === eventIndex;
}
/** @internal */


function decorateEvents(_, {
  modules
}, metaVersion) {
  return modules.filter(({
    events
  }) => events.isSome).reduce((result, {
    events,
    index,
    name
  }, _sectionIndex) => {
    const sectionIndex = metaVersion >= 12 ? index.toNumber() : _sectionIndex;
    result[(0,index_js_.stringCamelCase)(name)] = events.unwrap().reduce((newModule, meta, eventIndex) => {
      // we don't camelCase the event name
      newModule[meta.name.toString()] = {
        is: eventRecord => isEvent(eventRecord, sectionIndex, eventIndex),
        meta
      };
      return newModule;
    }, {});
    return result;
  }, {});
}
// EXTERNAL MODULE: ../../node_modules/@polkadot/metadata/decorate/extrinsics/index.js + 1 modules
var extrinsics = __webpack_require__(29592);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/codec/Raw.js
var Raw = __webpack_require__(90094);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/storage/getHasher.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0



const DEFAULT_FN = data => (0,util_crypto_index_js_.xxhashAsU8a)(data, 128);

const HASHERS = {
  Blake2_128: data => // eslint-disable-line camelcase
  (0,util_crypto_index_js_.blake2AsU8a)(data, 128),
  Blake2_128Concat: data => // eslint-disable-line camelcase
  (0,index_js_.u8aConcat)((0,util_crypto_index_js_.blake2AsU8a)(data, 128), (0,index_js_.u8aToU8a)(data)),
  Blake2_256: data => // eslint-disable-line camelcase
  (0,util_crypto_index_js_.blake2AsU8a)(data, 256),
  Identity: data => (0,index_js_.u8aToU8a)(data),
  Twox128: data => (0,util_crypto_index_js_.xxhashAsU8a)(data, 128),
  Twox256: data => (0,util_crypto_index_js_.xxhashAsU8a)(data, 256),
  Twox64Concat: data => (0,index_js_.u8aConcat)((0,util_crypto_index_js_.xxhashAsU8a)(data, 64), (0,index_js_.u8aToU8a)(data))
};
/** @internal */

function getHasher(hasher) {
  return HASHERS[hasher.type] || DEFAULT_FN;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/storage/createFunction.js


function createFunction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function createFunction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { createFunction_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { createFunction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0





/** @internal */
function createKeyRaw(registry, itemFn, keys, hashers, args) {
  return (0,index_js_.u8aConcat)((0,util_crypto_index_js_.xxhashAsU8a)(itemFn.prefix, 128), (0,util_crypto_index_js_.xxhashAsU8a)(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(type.toString(), args[index]).toU8a())));
}
/** @internal */


function createKey(registry, itemFn, keys, hashers, args) {
  const {
    method,
    section
  } = itemFn;
  (0,index_js_.assert)(Array.isArray(args), () => `Call to ${(0,index_js_.stringCamelCase)(section || 'unknown')}.${(0,index_js_.stringCamelCase)(method || 'unknown')} needs ${keys.length} arguments, provided in tuple format`);
  (0,index_js_.assert)(args.filter(a => !(0,index_js_.isUndefined)(a)).length === keys.length, () => `Call to ${(0,index_js_.stringCamelCase)(section || 'unknown')}.${(0,index_js_.stringCamelCase)(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)

  return (0,index_js_.compactAddLength)(createKeyRaw(registry, itemFn, keys, hashers, args));
}
/** @internal */


function expandWithMeta({
  meta,
  method,
  prefix,
  section
}, _storageFn) {
  const storageFn = _storageFn;
  storageFn.meta = meta;
  storageFn.method = (0,index_js_.stringLowerFirst)(method);
  storageFn.prefix = prefix;
  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it
  // instances (e.g. collective) will not work since it is only matched on param meta

  storageFn.toJSON = () => createFunction_objectSpread(createFunction_objectSpread({}, meta.toJSON()), {}, {
    storage: {
      method,
      prefix,
      section
    }
  });

  return storageFn;
}
/** @internal */


function extendHeadMeta(registry, {
  meta: {
    documentation,
    name,
    type
  },
  section
}, {
  method
}, iterFn) {
  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal
  // meta fallback only applies to actual entry values, create one for head

  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {
    documentation,
    fallback: registry.createType('Bytes', registry.createType(outputType.toString()).toHex()),
    modifier: registry.createType('StorageEntryModifierLatest', 1),
    // required
    name,
    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)
  });
  return (...args) => registry.createType('StorageKey', iterFn(...args), {
    method,
    section
  });
}
/** @internal */


function extendPrefixedMap(registry, itemFn, storageFn) {
  const {
    meta: {
      type
    },
    method,
    section
  } = itemFn;
  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {
    (0,index_js_.assert)(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length === type.asNMap.hashers.length - 1, () => `Iteration ${(0,index_js_.stringCamelCase)(section || 'unknown')}.${(0,index_js_.stringCamelCase)(method || 'unknown')} needs arguments to be one less than the full arguments, found [${args.join(', ')}]`);

    if (args.length) {
      if (type.isDoubleMap) {
        return new Raw/* Raw */.N(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [type.asDoubleMap.hasher], args));
      } else if (type.isNMap) {
        const keys = [...type.asNMap.keyVec];
        const hashers = [...type.asNMap.hashers]; // remove the last entry

        keys.pop();
        hashers.pop();
        return new Raw/* Raw */.N(registry, createKeyRaw(registry, itemFn, keys, hashers, args));
      }
    }

    return new Raw/* Raw */.N(registry, createKeyRaw(registry, itemFn, [], [], []));
  });
  return storageFn;
}
/** @internal */


function createFunction(registry, itemFn, options) {
  const {
    meta: {
      type
    }
  } = itemFn; // Can only have zero or one argument:
  //   - storage.system.account(address)
  //   - storage.timestamp.blockPeriod()
  // For higher-map queries the params are passed in as an tuple, [key1, key2]

  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? (0,index_js_.compactAddLength)((0,index_js_.u8aToU8a)(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [type.asMap.hasher], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [type.asDoubleMap.hasher, type.asDoubleMap.key2Hasher], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers, arg));

  if (type.isMap || type.isDoubleMap || type.isNMap) {
    extendPrefixedMap(registry, itemFn, storageFn);
  }

  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || (0,index_js_.compactStripLength)(storageFn())[1];

  return storageFn;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/storage/substrate.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0


// Small helper function to factorize code on this page.

/** @internal */
function createRuntimeFunction(method, key, {
  documentation,
  type
}) {
  return registry => createFunction(registry, {
    meta: {
      documentation: registry.createType('Vec<Text>', [documentation]),
      modifier: registry.createType('StorageEntryModifierLatest', 1),
      // required
      name: registry.createType('Text', method),
      toJSON: () => key,
      type: registry.createType('StorageEntryTypeLatest', type, 0)
    },
    method,
    prefix: 'Substrate',
    section: 'substrate'
  }, {
    key,
    skipHashing: true
  });
}

const substrate = {
  changesTrieConfig: createRuntimeFunction('changesTrieConfig', ':changes_trie', {
    documentation: ' Changes trie configuration is stored under this key.',
    type: 'u32'
  }),
  childStorageKeyPrefix: createRuntimeFunction('childStorageKeyPrefix', ':child_storage:', {
    documentation: ' Prefix of child storage keys.',
    type: 'u32'
  }),
  code: createRuntimeFunction('code', ':code', {
    documentation: ' Wasm code of the runtime.',
    type: 'Bytes'
  }),
  extrinsicIndex: createRuntimeFunction('extrinsicIndex', ':extrinsic_index', {
    documentation: ' Current extrinsic index (u32) is stored under this key.',
    type: 'u32'
  }),
  heapPages: createRuntimeFunction('heapPages', ':heappages', {
    documentation: ' Number of wasm linear memory pages required for execution of the runtime.',
    type: 'u64'
  })
};
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/storage/getStorage.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */

function getStorage(registry) {
  return {
    substrate: Object.entries(substrate).reduce((storage, [key, fn]) => {
      storage[key] = fn(registry);
      return storage;
    }, {})
  };
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/storage/index.js


function storage_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function storage_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { storage_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { storage_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0



/** @internal */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

function decorateStorage(registry, {
  modules
}, _metaVersion) {
  return modules.reduce((result, moduleMetadata) => {
    if (moduleMetadata.storage.isNone) {
      return result;
    }

    const {
      name
    } = moduleMetadata;
    const section = (0,index_js_.stringCamelCase)(name);
    const unwrapped = moduleMetadata.storage.unwrap();
    const prefix = unwrapped.prefix.toString(); // For access, we change the index names, i.e. System.Account -> system.account

    result[section] = unwrapped.items.reduce((newModule, meta) => {
      const method = meta.name.toString();
      newModule[(0,index_js_.stringLowerFirst)(method)] = createFunction(registry, {
        meta,
        method,
        prefix,
        section
      }, {});
      return newModule;
    }, {});
    return result;
  }, storage_objectSpread({}, getStorage(registry)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/metadata/decorate/index.js
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0







/**
 * Expands the metadata by decoration into consts, query and tx sections
 */

function expandMetadata(registry, metadata) {
  (0,index_js_.assert)(metadata instanceof Metadata/* Metadata */.S, 'You need to pass a valid Metadata instance to Decorated');
  const latest = metadata.asLatest;
  const version = metadata.version;
  return {
    consts: (0,constants/* decorateConstants */.U)(registry, latest, version),
    errors: decorateErrors(registry, latest, version),
    events: decorateEvents(registry, latest, version),
    query: decorateStorage(registry, latest, version),
    tx: (0,extrinsics/* decorateExtrinsics */.Y)(registry, latest, version)
  };
}

// EXTERNAL MODULE: ../../node_modules/@polkadot/metadata/packageInfo.js
var metadata_packageInfo = __webpack_require__(3610);
// EXTERNAL MODULE: ../../node_modules/@polkadot/rpc-provider/packageInfo.js
var rpc_provider_packageInfo = __webpack_require__(11082);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-core/detectPackage.js
// Copyright 2017-2021 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0





(0,index_js_.detectPackage)(rpc_core_packageInfo/* packageInfo */.b, typeof __dirname !== 'undefined' && __dirname, [metadata_packageInfo/* packageInfo */.b, rpc_provider_packageInfo/* packageInfo */.b, types_packageInfo/* packageInfo */.b]);
// EXTERNAL MODULE: consume shared module (default) @polkadot/types@^4.13.1 (strict) (fallback: ../../node_modules/@polkadot/types/index.js)
var types_index_js_ = __webpack_require__(71196);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/createType.js
var createType = __webpack_require__(4779);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/createClass.js
var createClass = __webpack_require__(78698);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/interfaces/jsonrpc.js
var jsonrpc = __webpack_require__(39764);
// EXTERNAL MODULE: ../../node_modules/@polkadot/rpc-core/util/refCountDelay.js
var refCountDelay = __webpack_require__(50192);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-core/index.js




function rpc_core_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function rpc_core_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rpc_core_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rpc_core_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0









const l = (0,index_js_.logger)('rpc-core');
const EMPTY_META = {
  fallback: undefined,
  modifier: {
    isOptional: true
  },
  type: {
    asMap: {
      linked: {
        isTrue: false
      }
    },
    isMap: false
  }
}; // utility method to create a nicely-formatted error

/** @internal */

function logErrorMessage(method, {
  params,
  type
}, error) {
  const inputs = params.map(({
    isOptional,
    name,
    type
  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');
  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);
}

function isTreatAsHex(key) {
  // :code is problematic - it does not have the length attached, which is
  // unlike all other storage entries where it is indeed properly encoded
  return ['0x3a636f6465'].includes(key.toHex());
}
/**
 * @name Rpc
 * @summary The API may use a HTTP or WebSockets provider.
 * @description It allows for querying a Polkadot Client Node.
 * WebSockets provider is recommended since HTTP provider only supports basic querying.
 *
 * ```mermaid
 * graph LR;
 *   A[Api] --> |WebSockets| B[WsProvider];
 *   B --> |endpoint| C[ws://127.0.0.1:9944]
 * ```
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Rpc from '@polkadot/rpc-core';
 * import { WsProvider } from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const rpc = new Rpc(provider);
 * ```
 */


var _instanceId = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("instanceId");

var _registryDefault = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("registryDefault");

var _getBlockRegistry = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("getBlockRegistry");

var _storageCache = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("storageCache");

class RpcCore {
  /**
   * @constructor
   * Default constructor for the Api Object
   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket
   */
  constructor(instanceId, registry, provider, userRpc = {}) {
    Object.defineProperty(this, _instanceId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _registryDefault, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getBlockRegistry, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _storageCache, {
      writable: true,
      value: new Map()
    });
    this.mapping = new Map();
    this.provider = void 0;
    this.sections = [];
    // eslint-disable-next-line @typescript-eslint/unbound-method
    (0,index_js_.assert)(provider && (0,index_js_.isFunction)(provider.send), 'Expected Provider to API create');
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _instanceId)[_instanceId] = instanceId;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _registryDefault)[_registryDefault] = registry;
    this.provider = provider;
    const sectionNames = Object.keys(jsonrpc/* default */.Z); // these are the base keys (i.e. part of jsonrpc)

    this.sections.push(...sectionNames); // decorate all interfaces, defined and user on this instance

    this.addUserInterfaces(userRpc);
  }
  /**
   * @description Returns the connected status of a provider
   */


  get isConnected() {
    return this.provider.isConnected;
  }
  /**
   * @description Manually connect from the attached provider
   */


  connect() {
    return this.provider.connect();
  }
  /**
   * @description Manually disconnect from the attached provider
   */


  disconnect() {
    return this.provider.disconnect();
  }
  /**
   * @description Sets a registry swap (typically from Api)
   */


  setRegistrySwap(registrySwap) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _getBlockRegistry)[_getBlockRegistry] = (0,index_js_.memoize)(registrySwap, {
      getInstanceId: () => (0,classPrivateFieldLooseBase/* default */.Z)(this, _instanceId)[_instanceId]
    });
  }

  addUserInterfaces(userRpc) {
    // add any extra user-defined sections
    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods

    this.sections.forEach(sectionName => {
      var _ref, _ref2;

      (_ref = this)[_ref2 = sectionName] || (_ref[_ref2] = {});
      const section = this[sectionName];
      Object.entries(rpc_core_objectSpread(rpc_core_objectSpread({}, this._createInterface(sectionName, jsonrpc/* default */.Z[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {
        section[key] || (section[key] = value);
      });
    });
  }

  _createInterface(section, methods) {
    return Object.entries(methods).filter(([method, {
      endpoint
    }]) => !this.mapping.has(endpoint || `${section}_${method}`)).reduce((exposed, [method, {
      endpoint
    }]) => {
      const def = methods[method];
      const isSubscription = !!def.pubsub;
      const jsonrpc = endpoint || `${section}_${method}`;
      this.mapping.set(jsonrpc, rpc_core_objectSpread(rpc_core_objectSpread({}, def), {}, {
        isSubscription,
        jsonrpc,
        method,
        section
      }));
      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);
      return exposed;
    }, {});
  }

  _memomize(creator, def) {
    const memoized = (0,index_js_.memoize)(creator('scale'), {
      getInstanceId: () => (0,classPrivateFieldLooseBase/* default */.Z)(this, _instanceId)[_instanceId]
    });
    memoized.json = creator('json');
    memoized.raw = creator('raw');
    memoized.meta = def;
    return memoized;
  }

  _createMethodSend(section, method, def) {
    const rpcName = def.endpoint || `${section}_${method}`;
    const hashIndex = def.params.findIndex(({
      isHistoric
    }) => isHistoric);
    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable

    const callWithRegistry = async (outputAs, values) => {
      const blockHash = hashIndex === -1 ? null : values[hashIndex];
      const {
        registry
      } = outputAs === 'scale' && blockHash && (0,classPrivateFieldLooseBase/* default */.Z)(this, _getBlockRegistry)[_getBlockRegistry] ? await (0,classPrivateFieldLooseBase/* default */.Z)(this, _getBlockRegistry)[_getBlockRegistry]((0,index_js_.u8aToU8a)(blockHash)) : {
        registry: (0,classPrivateFieldLooseBase/* default */.Z)(this, _registryDefault)[_registryDefault]
      };

      const params = this._formatInputs(registry, null, def, values);

      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));
      return outputAs === 'scale' ? this._formatOutput(registry, blockHash, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data);
    };

    const creator = outputAs => (...values) => {
      const isDelayed = outputAs === 'scale' && hashIndex !== -1 && !!values[hashIndex];
      return new x_rxjs_index_js_.Observable(observer => {
        callWithRegistry(outputAs, values).then(value => {
          observer.next(value);
          observer.complete();
        }).catch(error => {
          logErrorMessage(method, def, error);
          observer.error(error);
          observer.complete();
        });
        return () => {
          var _memoized;

          // delete old results from cache
          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.unmemoize(...values);
        };
      }).pipe((0,operators/* publishReplay */._g)(1), // create a Replay(1)
      isDelayed ? (0,refCountDelay/* refCountDelay */.f)() // Unsubscribe after delay
      : (0,operators/* refCount */.Gz)());
    };

    memoized = this._memomize(creator, def);
    return memoized;
  } // create a subscriptor, it subscribes once and resolves with the id as subscribe


  _createSubscriber({
    paramsJson,
    subName,
    subType,
    update
  }, errorHandler) {
    return new Promise((resolve, reject) => {
      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {
        errorHandler(error);
        reject(error);
      });
    });
  }

  _createMethodSubscribe(section, method, def) {
    const [updateType, subMethod, unsubMethod] = def.pubsub;
    const subName = `${section}_${subMethod}`;
    const unsubName = `${section}_${unsubMethod}`;
    const subType = `${section}_${updateType}`;
    let memoized = null;

    const creator = outputAs => (...values) => {
      return new x_rxjs_index_js_.Observable(observer => {
        // Have at least an empty promise, as used in the unsubscribe
        let subscriptionPromise = Promise.resolve(null);

        const registry = (0,classPrivateFieldLooseBase/* default */.Z)(this, _registryDefault)[_registryDefault];

        const errorHandler = error => {
          logErrorMessage(method, def, error);
          observer.error(error);
        };

        try {
          const params = this._formatInputs(registry, null, def, values);

          const paramsJson = params.map(param => param.toJSON());

          const update = (error, result) => {
            if (error) {
              logErrorMessage(method, def, error);
              return;
            }

            try {
              observer.next(outputAs === 'scale' ? this._formatOutput(registry, null, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));
            } catch (error) {
              observer.error(error);
            }
          };

          subscriptionPromise = this._createSubscriber({
            paramsJson,
            subName,
            subType,
            update
          }, errorHandler);
        } catch (error) {
          errorHandler(error);
        } // Teardown logic


        return () => {
          var _memoized2;

          // Delete from cache, so old results don't hang around
          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.unmemoize(...values); // Unsubscribe from provider

          subscriptionPromise.then(subscriptionId => (0,index_js_.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));
        };
      }).pipe((0,drr/* drr */.h)());
    };

    memoized = this._memomize(creator, def);
    return memoized;
  }

  _formatInputs(registry, blockHash, def, inputs) {
    const reqArgCount = def.params.filter(({
      isOptional
    }) => !isOptional).length;
    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;
    (0,index_js_.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, () => `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);
    return inputs.map((input, index) => (0,createType/* createTypeUnsafe */.z)(registry, def.params[index].type, [input], {
      blockHash
    }));
  }

  _formatOutput(registry, blockHash, method, rpc, params, result) {
    if (rpc.type === 'StorageData') {
      const key = params[0];
      return this._formatStorageData(registry, blockHash, key, result);
    } else if (rpc.type === 'StorageChangeSet') {
      const keys = params[0];
      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);
    } else if (rpc.type === 'Vec<StorageChangeSet>') {
      const mapped = result.map(({
        block,
        changes
      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, block, params[0], changes)]); // we only query at a specific block, not a range - flatten

      return method === 'queryStorageAt' ? mapped[0][1] : mapped;
    }

    return (0,createType/* createTypeUnsafe */.z)(registry, rpc.type, [result], {
      blockHash
    });
  }

  _formatStorageData(registry, blockHash, key, value) {
    const isEmpty = (0,index_js_.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all
    // data will be correctly encoded (incl. numbers, excl. :code)

    const input = isEmpty ? null : isTreatAsHex(key) ? value : (0,index_js_.u8aToU8a)(value);
    return this._newType(registry, blockHash, key, input, isEmpty);
  }

  _formatStorageSet(registry, blockHash, keys, changes) {
    // For StorageChangeSet, the changes has the [key, value] mappings
    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values
    // one at a time, all based on the query types. Three values can be returned -
    //   - Codec - There is a valid value, non-empty
    //   - null - The storage key is empty

    return keys.reduce((results, key, index) => {
      results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));
      return results;
    }, []);
  }

  _formatStorageSetEntry(registry, blockHash, key, changes, witCache, entryIndex) {
    const hexKey = key.toHex();
    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback
    //   - in the case of an array of values, fill the hole from the cache
    //   - if a single result value, don't fill - it is not an update hole
    //   - fallback to an empty option in all cases

    const value = (0,index_js_.isUndefined)(found) ? witCache && (0,classPrivateFieldLooseBase/* default */.Z)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];
    const isEmpty = (0,index_js_.isNull)(value);
    const input = isEmpty || isTreatAsHex(key) ? value : (0,index_js_.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no
    // clearing of it, so very long running processes (not just a couple of hours, longer)
    // will increase memory beyond what is allowed.

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _storageCache)[_storageCache].set(hexKey, value);

    return this._newType(registry, blockHash, key, input, isEmpty, entryIndex);
  }

  _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {
    // single return value (via state.getStorage), decode the value based on the
    // outputType that we have specified. Fallback to Raw on nothing
    const type = key.outputType || 'Raw';
    const meta = key.meta || EMPTY_META;
    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;

    try {
      if (meta.modifier.isOptional) {
        let inner = null;

        if (!isEmpty) {
          inner = (0,createType/* createTypeUnsafe */.z)(registry, type, [input], {
            blockHash,
            isPedantic: true
          });
        }

        const option = new types_index_js_.Option(registry, (0,createClass/* createClass */.qH)(registry, type), inner);

        if (blockHash) {
          option.createdAtHash = registry.createType('Hash', blockHash);
        }

        return option;
      }

      return (0,createType/* createTypeUnsafe */.z)(registry, type, [isEmpty ? meta.fallback ? (0,index_js_.hexToU8a)(meta.fallback.toHex()) : undefined : input], {
        blockHash,
        isPedantic: true
      });
    } catch (error) {
      throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);
    }
  }

}
// EXTERNAL MODULE: ../../node_modules/@polkadot/rpc-provider/ws/index.js + 4 modules
var ws = __webpack_require__(73406);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/extrinsic/constants.js
var extrinsic_constants = __webpack_require__(59737);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/primitive/StorageKey.js
var StorageKey = __webpack_require__(53326);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/isKeyringPair.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

function isKeyringPair(account) {
  return (0,index_js_.isFunction)(account.sign);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/logging.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

const logging_l = (0,index_js_.logger)('api/util');
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/filterEvents.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

function filterEvents(extHash, {
  block: {
    extrinsics,
    header
  }
}, allEvents, status) {
  // extrinsics to hashes
  const myHash = extHash.toHex();
  const allHashes = extrinsics.map(ext => ext.hash.toHex()); // find the index of our extrinsic in the block

  const index = allHashes.indexOf(myHash); // if we do get the block after finalized, it _should_ be there

  if (index === -1) {
    // only warn on filtering with isInBlock (finalization finalizes after)
    if (status.isInBlock) {
      logging_l.warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${myHash} inside ${allHashes.join(', ')}`);
    }

    return;
  }

  return allEvents.filter(({
    phase
  }) => // only ApplyExtrinsic has the extrinsic index
  phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(index));
}
// EXTERNAL MODULE: ../../node_modules/@polkadot/api/submittable/Result.js
var Result = __webpack_require__(70242);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/submittable/createClass.js




function createClass_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function createClass_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { createClass_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { createClass_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable no-dupe-class-members */






const createClass_identity = input => input;

function createClass_createClass({
  api,
  apiType,
  decorateMethod
}) {
  // an instance of the base extrinsic for us to extend
  const ExtrinsicBase = api.registry.createClass('Extrinsic');

  var _ignoreStatusCb = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("ignoreStatusCb");

  var _transformResult = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("transformResult");

  var _makeEraOptions = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("makeEraOptions");

  var _makeSignOptions = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("makeSignOptions");

  var _makeSignAndSendOptions = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("makeSignAndSendOptions");

  var _observeSign = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("observeSign");

  var _observeStatus = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("observeStatus");

  var _observeSend = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("observeSend");

  var _observeSubscribe = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("observeSubscribe");

  var _optionsOrNonce = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("optionsOrNonce");

  var _signViaSigner = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("signViaSigner");

  var _updateSigner = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("updateSigner");

  class Submittable extends ExtrinsicBase {
    constructor(registry, extrinsic) {
      super(registry, extrinsic, {
        version: api.extrinsicType
      });
      Object.defineProperty(this, _ignoreStatusCb, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _transformResult, {
        writable: true,
        value: createClass_identity
      });
      Object.defineProperty(this, _makeEraOptions, {
        writable: true,
        value: (options, {
          header,
          mortalLength,
          nonce
        }) => {
          if (!header) {
            if ((0,index_js_.isNumber)(options.era)) {
              // since we have no header, it is immortal, remove any option overrides
              // so we only supply the genesisHash and no era to the construction
              delete options.era;
              delete options.blockHash;
            }

            return (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignOptions)[_makeSignOptions](options, {
              nonce
            });
          }

          return (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignOptions)[_makeSignOptions](options, {
            blockHash: header.hash,
            era: this.registry.createType('ExtrinsicEra', {
              current: header.number,
              period: options.era || mortalLength
            }),
            nonce
          });
        }
      });
      Object.defineProperty(this, _makeSignOptions, {
        writable: true,
        value: (options, extras) => {
          return createClass_objectSpread(createClass_objectSpread(createClass_objectSpread({
            blockHash: api.genesisHash,
            genesisHash: api.genesisHash
          }, options), extras), {}, {
            runtimeVersion: api.runtimeVersion,
            signedExtensions: api.registry.signedExtensions,
            version: api.extrinsicType
          });
        }
      });
      Object.defineProperty(this, _makeSignAndSendOptions, {
        writable: true,
        value: (optionsOrStatus, statusCb) => {
          let options = {};

          if ((0,index_js_.isFunction)(optionsOrStatus)) {
            statusCb = optionsOrStatus;
          } else {
            options = createClass_objectSpread({}, optionsOrStatus);
          }

          return [options, statusCb];
        }
      });
      Object.defineProperty(this, _observeSign, {
        writable: true,
        value: (account, optionsOrNonce) => {
          const address = isKeyringPair(account) ? account.address : account.toString();

          const options = (0,classPrivateFieldLooseBase/* default */.Z)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce);

          let updateId;
          return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0,operators/* first */.Ps)(), (0,operators/* mergeMap */.zg)(async signingInfo => {
            const eraOptions = (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeEraOptions)[_makeEraOptions](options, signingInfo);

            if (isKeyringPair(account)) {
              this.sign(account, eraOptions);
            } else {
              updateId = await (0,classPrivateFieldLooseBase/* default */.Z)(this, _signViaSigner)[_signViaSigner](address, eraOptions, signingInfo.header);
            }
          }), (0,operators/* mapTo */.hZ)(updateId));
        }
      });
      Object.defineProperty(this, _observeStatus, {
        writable: true,
        value: (hash, status) => {
          if (!status.isFinalized && !status.isInBlock) {
            return (0,x_rxjs_index_js_.of)((0,classPrivateFieldLooseBase/* default */.Z)(this, _transformResult)[_transformResult](new Result/* SubmittableResult */.h({
              status
            })));
          }

          const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;
          return api.derive.tx.events(blockHash).pipe((0,operators/* map */.UI)(({
            block,
            events
          }) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _transformResult)[_transformResult](new Result/* SubmittableResult */.h({
            events: filterEvents(hash, block, events, status),
            status
          }))), (0,operators/* catchError */.KQ)(internalError => (0,x_rxjs_index_js_.of)((0,classPrivateFieldLooseBase/* default */.Z)(this, _transformResult)[_transformResult](new Result/* SubmittableResult */.h({
            internalError,
            status
          })))));
        }
      });
      Object.defineProperty(this, _observeSend, {
        writable: true,
        value: (updateId = -1) => {
          return api.rpc.author.submitExtrinsic(this).pipe((0,operators/* tap */.bw)(hash => {
            (0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSigner)[_updateSigner](updateId, hash);
          }));
        }
      });
      Object.defineProperty(this, _observeSubscribe, {
        writable: true,
        value: (updateId = -1) => {
          const hash = this.hash;
          return api.rpc.author.submitAndWatchExtrinsic(this).pipe((0,operators/* switchMap */.wt)(status => (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeStatus)[_observeStatus](hash, status)), (0,operators/* tap */.bw)(status => {
            (0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSigner)[_updateSigner](updateId, status);
          }));
        }
      });
      Object.defineProperty(this, _optionsOrNonce, {
        writable: true,
        value: (optionsOrNonce = {}) => {
          return (0,index_js_.isBn)(optionsOrNonce) || (0,index_js_.isNumber)(optionsOrNonce) ? {
            nonce: optionsOrNonce
          } : optionsOrNonce;
        }
      });
      Object.defineProperty(this, _signViaSigner, {
        writable: true,
        value: async (address, options, header) => {
          const signer = options.signer || api.signer;
          (0,index_js_.assert)(signer, 'No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
          const payload = this.registry.createType('SignerPayload', createClass_objectSpread(createClass_objectSpread({}, options), {}, {
            address,
            blockNumber: header ? header.number : 0,
            method: this.method
          }));
          let result;

          if (signer.signPayload) {
            result = await signer.signPayload(payload.toPayload());
          } else if (signer.signRaw) {
            result = await signer.signRaw(payload.toRaw());
          } else {
            throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');
          } // Here we explicitly call `toPayload()` again instead of working with an object
          // (reference) as passed to the signer. This means that we are sure that the
          // payload data is not modified from our inputs, but the signer


          super.addSignature(address, result.signature, payload.toPayload());
          return result.id;
        }
      });
      Object.defineProperty(this, _updateSigner, {
        writable: true,
        value: (updateId, status) => {
          if (updateId !== -1 && api.signer && api.signer.update) {
            api.signer.update(updateId, status);
          }
        }
      });
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _ignoreStatusCb)[_ignoreStatusCb] = apiType === 'rxjs';
    } // dry run an extrinsic


    dryRun(account, optionsOrHash) {
      if ((0,index_js_.isString)(optionsOrHash) || (0,index_js_.isU8a)(optionsOrHash)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), optionsOrHash));
      } // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call


      return decorateMethod(() => (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSign)[_observeSign](account, optionsOrHash).pipe((0,operators/* switchMap */.wt)(() => api.rpc.system.dryRun(this.toHex()))))();
    } // calculate the payment info for this transaction (if signed and submitted)


    paymentInfo(account, optionsOrHash) {
      if ((0,index_js_.isString)(optionsOrHash) || (0,index_js_.isU8a)(optionsOrHash)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod(() => api.rpc.payment.queryInfo(this.toHex(), optionsOrHash));
      }

      const [allOptions] = (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrHash);

      const address = isKeyringPair(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0,operators/* first */.Ps)(), (0,operators/* switchMap */.wt)(signingInfo => {
        // setup our options (same way as in signAndSend)
        const eraOptions = (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeEraOptions)[_makeEraOptions](allOptions, signingInfo);

        const signOptions = (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignOptions)[_makeSignOptions](eraOptions, {});

        this.signFake(address, signOptions);
        return api.rpc.payment.queryInfo(this.toHex());
      })))();
    } // send with an immediate Hash result


    // send implementation for both immediate Hash and statusCb variants
    send(statusCb) {
      const isSubscription = api.hasSubscriptions && ((0,classPrivateFieldLooseBase/* default */.Z)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(isSubscription ? (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSubscribe)[_observeSubscribe] : (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSend)[_observeSend])(statusCb);
    }
    /**
     * @description Sign a transaction, returning the this to allow chaining, i.e. .sign(...).send(). When options, e.g. nonce/blockHash are not specified, it will be inferred. To retrieve eg. nonce use `signAsync` (the preferred interface, this is provided for backwards compatibility)
     * @deprecated
     */


    sign(account, optionsOrNonce) {
      super.sign(account, (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignOptions)[_makeSignOptions]((0,classPrivateFieldLooseBase/* default */.Z)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce), {}));
      return this;
    }
    /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */


    signAsync(account, optionsOrNonce) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
      return decorateMethod(() => (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSign)[_observeSign](account, optionsOrNonce).pipe((0,operators/* mapTo */.hZ)(this)))();
    } // signAndSend with an immediate Hash result


    // signAndSend implementation for all 3 cases above
    signAndSend(account, optionsOrStatus, optionalStatusCb) {
      const [options, statusCb] = (0,classPrivateFieldLooseBase/* default */.Z)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrStatus, optionalStatusCb);

      const isSubscription = api.hasSubscriptions && ((0,classPrivateFieldLooseBase/* default */.Z)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSign)[_observeSign](account, options).pipe((0,operators/* switchMap */.wt)(updateId => isSubscription ? (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSubscribe)[_observeSubscribe](updateId) : (0,classPrivateFieldLooseBase/* default */.Z)(this, _observeSend)[_observeSend](updateId))) // FIXME This is wrong, SubmittableResult is _not_ a codec
      )(statusCb);
    } // adds a transform to the result, applied before result is returned


    withResultTransform(transform) {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _transformResult)[_transformResult] = transform;
      return this;
    }

  }

  return Submittable;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/submittable/createSubmittable.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

function createSubmittable(apiType, api, decorateMethod) {
  const Submittable = createClass_createClass({
    api,
    apiType,
    decorateMethod
  });
  return extrinsic => new Submittable(api.registry, extrinsic);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/augmentObject.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

const augmentObject_l = (0,index_js_.logger)('api/augment');

function logLength(type, values, and = []) {
  return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';
}

function logValues(type, values) {
  return values.length ? `\n\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';
} // log details to console


function warn(prefix, type, [added, removed]) {
  if (added.length || removed.length) {
    augmentObject_l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);
  }
}

function extractKeys(src, dst) {
  return [Object.keys(src), Object.keys(dst)];
}

function findSectionExcludes(a, b) {
  return a.filter(section => !b.includes(section));
}

function extractSections(src, dst) {
  const [srcSections, dstSections] = extractKeys(src, dst);
  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];
}

function findMethodExcludes(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = Object.keys(dst);
  return dstSections.filter(section => srcSections.includes(section)).reduce((rmMethods, section) => {
    const srcMethods = Object.keys(src[section]);
    return rmMethods.concat(...Object.keys(dst[section]).filter(method => !srcMethods.includes(method)).map(method => `${section}.${method}`));
  }, []);
}

function extractMethods(src, dst) {
  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];
}
/**
 * Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is
 * already available, but rather just adds new missing ites into the result object.
 * @internal
 */


function augmentObject(prefix, src, dst, fromEmpty = false) {
  if (fromEmpty) {
    Object.keys(dst).forEach(key => {
      delete dst[key];
    });
  }

  if (prefix && Object.keys(dst).length) {
    warn(prefix, 'modules', extractSections(src, dst));
    warn(prefix, 'calls', extractMethods(src, dst));
  }

  return Object.keys(src).reduce((newSection, sectionName) => {
    const section = src[sectionName];
    newSection[sectionName] = Object.keys(section).reduce((result, methodName) => {
      // TODO When it does match, check the actual details and warn when there are differences
      if (!result[methodName]) {
        result[methodName] = section[methodName];
      }

      return result;
    }, dst[sectionName] || {});
    return newSection;
  }, dst);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/decorate.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Most generic typings for `api.derive.*.*`
// Exact typings for a particular section `api.derive.section.*`
// Exact typings for all sections `api.derive.*.*`
// A technically unsafe version of Object.keys(obj) that assumes that
// obj only has known properties of T
function decorate_keys(obj) {
  return Object.keys(obj);
}
/**
 * This is a methods decorator which keeps all type information.
 */


function decorateMethods(section, decorateMethod) {
  return decorate_keys(section).reduce((acc, methodName) => {
    const method = section[methodName]; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    acc[methodName] = decorateMethod(method);
    return acc;
  }, {});
}
/**
 * This is a section decorator which keeps all type information.
 */


function decorateSections(allSections, decorateMethod) {
  return decorate_keys(allSections).reduce((acc, sectionName) => {
    acc[sectionName] = decorateMethods(allSections[sectionName], decorateMethod);
    return acc;
  }, {});
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/util/validate.js
// Copyright 2017-2019 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


function sig({
  method,
  section
}, args) {
  return `${section}.${method}(${args.join(', ')})`;
}

function doDoubleMap(creator, args) {
  const {
    key1,
    key2
  } = creator.meta.type.asDoubleMap;
  (0,index_js_.assert)(args.length === 2, () => `${sig(creator, [key1, key2])} is a double map, requiring 2 arguments, ${args.length} found`); // pass as tuple

  return [creator, args];
}

function doMap(creator, args) {
  const {
    key
  } = creator.meta.type.asMap;
  (0,index_js_.assert)(args.length === 1, () => `${sig(creator, [key])} is a map, requiring 1 argument, ${args.length} found`); // expand

  return args.length ? [creator, args[0]] : [creator];
}

function doNMap(creator, args) {
  const {
    keyVec
  } = creator.meta.type.asNMap;
  (0,index_js_.assert)(args.length === keyVec.length, () => `${sig(creator, keyVec)} is a multi map, requiring ${keyVec.length} arguments, ${args.length} found`); // pass as tuple

  return [creator, args];
} // sets up the arguments in the form of [creator, args] ready to be used in a storage
// call. Additionally, it verifies that the correct number of arguments have been passed


function extractStorageArgs(creator, _args) {
  const args = _args.filter(arg => !(0,index_js_.isUndefined)(arg));

  if (creator.meta.type.isDoubleMap) {
    return doDoubleMap(creator, args);
  } else if (creator.meta.type.isMap) {
    return doMap(creator, args);
  } else if (creator.meta.type.isNMap) {
    return doNMap(creator, args);
  }

  (0,index_js_.assert)(args.length === 0, () => `${sig(creator, [])} does not take any arguments, ${args.length} found`); // no args

  return [creator];
}
// EXTERNAL MODULE: ../../node_modules/eventemitter3/index.js
var eventemitter3 = __webpack_require__(10161);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/Events.js


// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


var _eventemitter = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("eventemitter");

class Events {
  constructor() {
    Object.defineProperty(this, _eventemitter, {
      writable: true,
      value: new eventemitter3()
    });
  }

  emit(type, ...args) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].emit(type, ...args);
  }
  /**
   * @description Attach an eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.on('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.on('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */


  on(type, handler) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].on(type, handler);

    return this;
  }
  /**
   * @description Remove the given eventemitter handler
   *
   * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to unregister.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const handler = (): void => {
   *  console.log('Connected !);
   * };
   *
   * // Start listening
   * api.on('connected', handler);
   *
   * // Stop listening
   * api.off('connected', handler);
   * ```
   */


  off(type, handler) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].removeListener(type, handler);

    return this;
  }
  /**
   * @description Attach an one-time eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.once('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.once('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */


  once(type, handler) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].once(type, handler);

    return this;
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/Decorate.js




function Decorate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Decorate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Decorate_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Decorate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

















// the max amount of keys/values that we will retrieve at once
const PAGE_SIZE_K = 768; // limited since the trie lookups are heavy

const PAGE_SIZE_V = 256; // limited since the data may be very large

const Decorate_l = (0,index_js_.logger)('api/init');
let instanceCounter = 0;

var Decorate_instanceId = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("instanceId");

var _registry = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("registry");

class Decorate extends Events {
  // HACK Use BN import so decorateDerive works... yes, wtf.

  /**
   * This is the one and only method concrete children classes need to implement.
   * It's a higher-order function, which takes one argument
   * `method: Method extends (...args: any[]) => Observable<any>`
   * (and one optional `options`), and should return the user facing method.
   * For example:
   * - For ApiRx, `decorateMethod` should just be identity, because the input
   * function is already an Observable
   * - For ApiPromise, `decorateMethod` should return a function that takes all
   * the parameters from `method`, adds an optional `callback` argument, and
   * returns a Promise.
   *
   * We could easily imagine other user-facing interfaces, which are simply
   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
   * via `decorateMethod`.
   */

  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(options, type, decorateMethod) {
    var _options$source;

    super();
    Object.defineProperty(this, Decorate_instanceId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _registry, {
      writable: true,
      value: void 0
    });
    this.__phantom = new bn(0);
    this._consts = {};
    this._derive = void 0;
    this._errors = {};
    this._events = {};
    this._extrinsics = void 0;
    this._extrinsicType = extrinsic_constants/* DEFAULT_VERSION */.eQ;
    this._genesisHash = void 0;
    this._isConnected = void 0;
    this._isReady = false;
    this._options = void 0;
    this._query = {};
    this._queryMulti = void 0;
    this._rpc = void 0;
    this._rpcCore = void 0;
    this._runtimeChain = void 0;
    this._runtimeMetadata = void 0;
    this._runtimeVersion = void 0;
    this._rx = {
      consts: {},
      query: {},
      tx: {}
    };
    this._type = void 0;
    this._decorateMethod = void 0;

    this._rxDecorateMethod = method => {
      return method;
    };

    (0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId] = `${++instanceCounter}`;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new create_registry/* TypeRegistry */.P();
    this._rx.registry = (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry];
    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new ws/* WsProvider */.U();
    this._decorateMethod = decorateMethod;
    this._options = options;
    this._type = type; // The RPC interface decorates the known interfaces on init

    this._rpcCore = new RpcCore((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry], thisProvider, this._options.rpc);
    this._isConnected = new x_rxjs_index_js_.BehaviorSubject(this._rpcCore.provider.isConnected);
    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @description Return the current used registry
   */


  get registry() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry];
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createType(type, ...params) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry].createType(type, ...params);
  }
  /**
   * @description Register additional user-defined of chain-specific types in the type registry
   */


  registerTypes(types) {
    types && (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry].register(types);
  }
  /**
   * @returns `true` if the API operates with subscriptions
   */


  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @returns `true` if the API decorate multi-key queries
   */


  get supportMulti() {
    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
  }

  injectMetadata(metadata, fromEmpty, registry) {
    const decoratedMeta = expandMetadata(registry || (0,classPrivateFieldLooseBase/* default */.Z)(this, _registry)[_registry], metadata);

    if (fromEmpty || !this._extrinsics) {
      this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);
      this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);
    } else {
      augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);
      augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);
    } // this API


    augmentObject('query', this._decorateStorage(decoratedMeta, this._decorateMethod), this._query, fromEmpty);
    augmentObject('consts', decoratedMeta.consts, this._consts, fromEmpty);
    augmentObject('errors', decoratedMeta.errors, this._errors, fromEmpty);
    augmentObject('events', decoratedMeta.events, this._events, fromEmpty); // rx

    augmentObject(null, this._decorateStorage(decoratedMeta, this._rxDecorateMethod), this._rx.query, fromEmpty);
    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
  }

  _decorateFunctionMeta(input, output) {
    output.meta = input.meta;
    output.method = input.method;
    output.section = input.section;
    output.toJSON = input.toJSON;

    if (input.callIndex) {
      output.callIndex = input.callIndex;
    }

    return output;
  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following
  // manner to cater for both old and new:
  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
  //   - when non-zero, remove anything that is not in the array (we don't do this)


  _filterRpc(rpcMethods, additional) {
    const methods = rpcMethods.methods.map(t => t.toString()); // add any specific user-base RPCs

    if (Object.keys(additional).length !== 0) {
      this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces


      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);

      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);
    }

    this._filterRpcMethods(methods);
  }

  _filterRpcMethods(exposed) {
    const hasResults = exposed.length !== 0;
    const allKnown = [...this._rpcCore.mapping.entries()];
    const allKeys = allKnown.reduce((allKeys, [, {
      alias,
      endpoint,
      method,
      pubsub,
      section
    }]) => {
      allKeys.push(`${section}_${method}`);

      if (pubsub) {
        allKeys.push(`${section}_${pubsub[1]}`);
        allKeys.push(`${section}_${pubsub[2]}`);
      }

      if (alias) {
        allKeys.push(...alias);
      }

      if (endpoint) {
        allKeys.push(endpoint);
      }

      return allKeys;
    }, []);
    const unknown = exposed.filter(k => !allKeys.includes(k));
    const deletion = allKnown.filter(([k]) => hasResults && !exposed.includes(k) && k !== 'rpc_methods');

    if (unknown.length) {
      Decorate_l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);
    } // loop through all entries we have (populated in decorate) and filter as required
    // only remove when we have results and method missing, or with no results if optional


    deletion.forEach(([, {
      method,
      section
    }]) => {
      delete this._rpc[section][method];
      delete this._rx.rpc[section][method];
    });
  }

  _decorateRpc(rpc, decorateMethod, input = {}) {
    return rpc.sections.reduce((out, _sectionName) => {
      const sectionName = _sectionName;

      if (!out[sectionName]) {
        // out and section here are horrors to get right from a typing perspective :(
        out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {
          //  skip subscriptions where we have a non-subscribe interface
          if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {
            section[methodName] = decorateMethod(method, {
              methodName
            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

            section[methodName].json = decorateMethod(method.json, {
              methodName
            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

            section[methodName].raw = decorateMethod(method.raw, {
              methodName
            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

            section[methodName].meta = method.meta;
          }

          return section;
        }, {});
      }

      return out;
    }, input);
  } // only be called if supportMulti is true


  _decorateMulti(decorateMethod) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return decorateMethod(calls => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(calls.map(arg => Array.isArray(arg) ? [arg[0].creator, ...arg.slice(1)] : [arg.creator])));
  }

  _decorateExtrinsics({
    tx
  }, decorateMethod) {
    const creator = createSubmittable(this._type, this._rx, decorateMethod);
    return Object.entries(tx).reduce((out, [name, section]) => {
      out[name] = Object.entries(section).reduce((out, [name, method]) => {
        out[name] = this._decorateExtrinsicEntry(method, creator);
        return out;
      }, {});
      return out;
    }, creator);
  }

  _decorateExtrinsicEntry(method, creator) {
    const decorated = (...params) => creator(method(...params)); // pass through the `.is`


    decorated.is = other => method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return


    return this._decorateFunctionMeta(method, decorated);
  }

  _decorateStorage({
    query
  }, decorateMethod) {
    return Object.entries(query).reduce((out, [name, section]) => {
      out[name] = Object.entries(section).reduce((out, [name, method]) => {
        out[name] = this._decorateStorageEntry(method, decorateMethod);
        return out;
      }, {});
      return out;
    }, {});
  }

  _decorateStorageEntry(creator, decorateMethod) {
    // get the storage arguments, with DoubleMap as an array entry, otherwise spread
    const getArgs = args => extractStorageArgs(creator, args); // Disable this where it occurs for each field we are decorating

    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */


    const decorated = this._decorateStorageCall(creator, decorateMethod);

    decorated.creator = creator;
    decorated.at = decorateMethod((hash, ...args) => this._rpcCore.state.getStorage(getArgs(args), hash));
    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));

    decorated.is = key => key.section === creator.section && key.method === creator.method;

    decorated.key = (...args) => (0,index_js_.u8aToHex)((0,index_js_.compactStripLength)(creator(creator.meta.type.isPlain ? undefined : creator.meta.type.isMap ? args[0] : creator.meta.type.isDoubleMap ? [args[0], args[1]] : args))[1]);

    decorated.keyPrefix = (...keys) => (0,index_js_.u8aToHex)(creator.keyPrefix(...keys));

    decorated.range = decorateMethod((range, ...args) => this._decorateStorageRange(decorated, args, range));
    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));
    decorated.sizeAt = decorateMethod((hash, ...args) => this._rpcCore.state.getStorageSize(getArgs(args), hash)); // FIXME NMap support
    // .keys() & .entries() only available on map types

    if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {
      decorated.entries = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], (...args) => this._retrieveMapEntries(creator, null, args)));
      decorated.entriesAt = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], (hash, ...args) => this._retrieveMapEntries(creator, hash, args)));
      decorated.entriesPaged = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));
      decorated.keys = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], (...args) => this._retrieveMapKeys(creator, null, args)));
      decorated.keysAt = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], (hash, ...args) => this._retrieveMapKeys(creator, hash, args)));
      decorated.keysPaged = decorateMethod((0,memo/* memo */.X)((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));
    }

    if (this.supportMulti) {
      // When using double map storage function, user need to pass double map key as an array
      decorated.multi = decorateMethod(args => this._retrieveMulti(args.map(arg => [creator, arg])));
    }
    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */


    return this._decorateFunctionMeta(creator, decorated);
  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)
  // we make a subscription, alternatively we push this through a single-shot query


  _decorateStorageCall(creator, decorateMethod) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return decorateMethod((...args) => {
      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([extractStorageArgs(creator, args)]).pipe((0,operators/* map */.UI)(([data]) => data) // extract first/only result from list
      ) : this._rpcCore.state.getStorage(extractStorageArgs(creator, args));
    }, {
      methodName: creator.method,
      overrideNoSub: (...args) => this._rpcCore.state.getStorage(extractStorageArgs(creator, args))
    });
  }

  _decorateStorageRange(decorated, args, range) {
    const outputType = (0,StorageKey/* unwrapStorageType */.P)(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);
    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe((0,operators/* map */.UI)(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));
  } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes


  _retrieveMulti(keys) {
    if (!keys.length) {
      return (0,x_rxjs_index_js_.of)([]);
    }

    const queryCall = this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
    return (0,x_rxjs_index_js_.combineLatest)((0,index_js_.arrayChunk)(keys, PAGE_SIZE_V).map(keys => queryCall(keys))).pipe((0,operators/* map */.UI)(index_js_.arrayFlatten));
  }

  _retrieveMapKeys({
    iterKey,
    meta,
    method,
    section
  }, at, args) {
    (0,index_js_.assert)(iterKey && (meta.type.isMap || meta.type.isDoubleMap || meta.type.isNMap), 'keys can only be retrieved on maps, linked maps and double maps');
    const headKey = iterKey(...args).toHex();
    const startSubject = new x_rxjs_index_js_.BehaviorSubject(headKey);
    const queryCall = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);
    return startSubject.pipe((0,operators/* switchMap */.wt)(queryCall), (0,operators/* map */.UI)(keys => keys.map(key => key.setMeta(meta, section, method))), (0,operators/* tap */.bw)(keys => {
      setTimeout(() => {
        keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();
      }, 0);
    }), (0,operators/* toArray */.qo)(), // toArray since we want to startSubject to be completed
    (0,operators/* map */.UI)(index_js_.arrayFlatten));
  }

  _retrieveMapKeysPaged({
    iterKey,
    meta,
    method,
    section
  }, opts) {
    (0,index_js_.assert)(iterKey && (meta.type.isMap || meta.type.isDoubleMap || meta.type.isNMap), 'keys can only be retrieved on maps, linked maps and double maps');
    const headKey = iterKey(...opts.args).toHex();
    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe((0,operators/* map */.UI)(keys => keys.map(key => key.setMeta(meta, section, method))));
  }

  _retrieveMapEntries(entry, at, args) {
    const query = at ? keyset => this._rpcCore.state.queryStorageAt(keyset, at) : keyset => this._rpcCore.state.queryStorageAt(keyset);
    return this._retrieveMapKeys(entry, at, args).pipe((0,operators/* switchMap */.wt)(keys => keys.length ? (0,x_rxjs_index_js_.combineLatest)((0,index_js_.arrayChunk)(keys, PAGE_SIZE_V).map(query)).pipe((0,operators/* map */.UI)(valsArr => (0,index_js_.arrayFlatten)(valsArr).map((value, index) => [keys[index], value]))) : (0,x_rxjs_index_js_.of)([])));
  }

  _retrieveMapEntriesPaged(entry, opts) {
    return this._retrieveMapKeysPaged(entry, opts).pipe((0,operators/* switchMap */.wt)(keys => keys.length ? this._rpcCore.state.queryStorageAt(keys).pipe((0,operators/* map */.UI)(valsArr => valsArr.map((value, index) => [keys[index], value]))) : (0,x_rxjs_index_js_.of)([])));
  }

  _decorateDeriveRx(decorateMethod) {
    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;

    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();

    const derives = Decorate_objectSpread(Decorate_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName !== null && specName !== void 0 ? specName : '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive


    const derive = decorateDerive((0,classPrivateFieldLooseBase/* default */.Z)(this, Decorate_instanceId)[Decorate_instanceId], this._rx, derives);
    return decorateSections(derive, decorateMethod);
  }

  _decorateDerive(decorateMethod) {
    return decorateSections(this._rx.derive, decorateMethod);
  }
  /**
   * Put the `this.onCall` function of ApiRx here, because it is needed by
   * `api._rx`.
   */


}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/Init.js




function Init_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Init_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Init_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Init_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0









const KEEPALIVE_INTERVAL = 10000;
const Init_l = (0,index_js_.logger)('api/init');

var _healthTimer = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("healthTimer");

var _registries = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("registries");

var _updateSub = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("updateSub");

var _onProviderConnect = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onProviderConnect");

var _onProviderDisconnect = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onProviderDisconnect");

var _onProviderError = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onProviderError");

class Init extends Decorate {
  constructor(options, type, decorateMethod) {
    super(options, type, decorateMethod); // all injected types added to the registry for overrides

    Object.defineProperty(this, _healthTimer, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _registries, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _updateSub, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _onProviderConnect, {
      writable: true,
      value: async () => {
        this.emit('connected');

        this._isConnected.next(true);

        try {
          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0,util_crypto_index_js_.cryptoWaitReady)()]);

          if (hasMeta && !this._isReady && cryptoReady) {
            this._isReady = true;
            this.emit('ready', this);
          }

          (0,classPrivateFieldLooseBase/* default */.Z)(this, _healthTimer)[_healthTimer] = setInterval(() => {
            this._rpcCore.system.health().toPromise().catch(() => undefined);
          }, KEEPALIVE_INTERVAL);
        } catch (_error) {
          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
          Init_l.error(error);
          this.emit('error', error);
        }
      }
    });
    Object.defineProperty(this, _onProviderDisconnect, {
      writable: true,
      value: () => {
        this.emit('disconnected');

        this._isConnected.next(false);

        this._unsubscribeHealth();
      }
    });
    Object.defineProperty(this, _onProviderError, {
      writable: true,
      value: error => {
        this.emit('error', error);
      }
    });
    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.
    // Do right up-front, so we get in the user types before we are actually
    // doing anything on-chain, this ensures we have the overrides in-place

    if (!options.source) {
      this.registerTypes(options.types);
    } else {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries] = (0,classPrivateFieldLooseBase/* default */.Z)(options.source, _registries)[_registries];
    }

    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);

    if (this.supportMulti) {
      this._queryMulti = this._decorateMulti(this._decorateMethod);
      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
    }

    this._rx.signer = options.signer;

    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));

    if (this.hasSubscriptions) {
      this._rpcCore.provider.on('disconnected', (0,classPrivateFieldLooseBase/* default */.Z)(this, _onProviderDisconnect)[_onProviderDisconnect]);

      this._rpcCore.provider.on('error', (0,classPrivateFieldLooseBase/* default */.Z)(this, _onProviderError)[_onProviderError]);

      this._rpcCore.provider.on('connected', (0,classPrivateFieldLooseBase/* default */.Z)(this, _onProviderConnect)[_onProviderConnect]);
    } else {
      Init_l.warn('Api will be available in a limited mode since the provider does not support subscriptions');
    } // If the provider was instantiated earlier, and has already emitted a
    // 'connected' event, then the `on('connected')` won't fire anymore. To
    // cater for this case, we call manually `this._onProviderConnect`.


    if (this._rpcCore.provider.isConnected) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _onProviderConnect)[_onProviderConnect]();
    }
  }
  /**
   * @description Decorates a registry based on the runtime version
   */


  _initRegistry(registry, chain, version, metadata, chainProps) {
    registry.setChainProperties(chainProps || this.registry.getChainProperties());
    registry.setKnownTypes(this._options);
    registry.register((0,types_known/* getSpecTypes */.kh)(registry, chain, version.specName, version.specVersion));
    registry.setHasher((0,types_known/* getSpecHasher */.ve)(registry, chain, version.specName)); // for bundled types, pull through the aliases defined

    if (registry.knownTypes.typesBundle) {
      registry.knownTypes.typesAlias = (0,types_known/* getSpecAlias */.Xn)(registry, chain, version.specName);
    }

    registry.setMetadata(metadata, undefined, Init_objectSpread(Init_objectSpread({}, (0,types_known/* getSpecExtensions */.oR)(registry, chain, version.specName)), this._options.signedExtensions || {}));
    return registry;
  }
  /**
   * @description Sets up a registry based on the block hash defined
   */


  async getBlockRegistry(blockHash) {
    const existingViaHash = (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].find(({
      lastBlockHash
    }) => lastBlockHash && (0,index_js_.u8aEq)(lastBlockHash, blockHash));

    if (existingViaHash) {
      return existingViaHash;
    } // ensure we have everything required


    (0,index_js_.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into
    // the registry swap, so getHeader & getRuntimeVersion should not be historic

    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {
      number: index_js_.BN_ZERO,
      parentHash: this._genesisHash
    } : await this._rpcCore.chain.getHeader.json(blockHash).toPromise());
    (0,index_js_.assert)(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history

    const [firstVersion, lastVersion] = (0,types_known/* getUpgradeVersion */.ur)(this._genesisHash, header.number);
    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {
      specName: this._runtimeVersion.specName,
      specVersion: firstVersion.specVersion
    } : await this._rpcCore.state.getRuntimeVersion.json(header.parentHash).toPromise()); // check for pre-existing registries

    const existingViaVersion = (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].find(({
      specVersion
    }) => specVersion.eq(version.specVersion));

    if (existingViaVersion) {
      existingViaVersion.lastBlockHash = blockHash;
      return existingViaVersion;
    } // nothing has been found, construct new


    const metadata = new Metadata/* Metadata */.S(this.registry, await this._rpcCore.state.getMetadata.raw(header.parentHash).toPromise());

    const registry = this._initRegistry(new create_registry/* TypeRegistry */.P(blockHash), this._runtimeChain, version, metadata); // add our new registry


    const result = {
      isDefault: false,
      lastBlockHash: blockHash,
      metadata,
      metadataConsts: null,
      registry,
      specVersion: version.specVersion
    };

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries
    // this._detectCapabilities(registry, blockHash);


    return result;
  }

  async _loadMeta() {
    var _this$_options$source;

    // on re-connection to the same chain, we don't want to re-do everything from chain again
    if (this._isReady) {
      return true;
    }

    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively
    // just use the values from the source instance provided


    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);
    return this._initFromMeta(this._runtimeMetadata);
  } // eslint-disable-next-line @typescript-eslint/require-await


  async _metaFromSource(source) {
    this._extrinsicType = source.extrinsicVersion;
    this._runtimeChain = source.runtimeChain;
    this._runtimeVersion = source.runtimeVersion;
    const methods = []; // manually build a list of all available methods in this RPC, we are
    // going to filter on it to align the cloned RPC without making a call

    Object.keys(source.rpc).forEach(section => {
      Object.keys(source.rpc[section]).forEach(method => {
        methods.push(`${section}_${method}`);
      });
    });

    this._filterRpcMethods(methods);

    return [source.genesisHash, source.runtimeMetadata];
  }

  _detectCapabilities(registry, blockHash) {
    detectedCapabilities(this._rx, blockHash).toPromise().then(types => {
      if (Object.keys(types).length) {
        registry.register(types);
        Init_l.debug(() => `Capabilities detected${blockHash ? ` (${(0,index_js_.u8aToHex)((0,index_js_.u8aToU8a)(blockHash))})` : ''}: ${(0,index_js_.stringify)(types)}`);
      }
    }).catch(undefined);
    return true;
  } // subscribe to metadata updates, inject the types on changes


  _subscribeUpdates() {
    if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {
      return;
    }

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0,operators/* switchMap */.wt)(version => {
      var _this$_runtimeVersion;

      return (// only retrieve the metadata when the on-chain version has been changed
        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? (0,x_rxjs_index_js_.of)(false) : this._rpcCore.state.getMetadata().pipe((0,operators/* map */.UI)(metadata => {
          Init_l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
          this._runtimeMetadata = metadata;
          this._runtimeVersion = version;
          this._rx.runtimeVersion = version; // update the default registry version

          const thisRegistry = (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].find(({
            isDefault
          }) => isDefault);

          (0,index_js_.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions

          thisRegistry.metadata = metadata;
          thisRegistry.metadataConsts = null;
          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly

          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);

          this.injectMetadata(metadata, false, thisRegistry.registry);
          return this._detectCapabilities(thisRegistry.registry);
        }))
      );
    })).subscribe();
  }

  async _metaFromChain(optMetadata) {
    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]); // set our chain version & genesisHash as returned

    this._runtimeChain = chain;
    this._runtimeVersion = runtimeVersion;
    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options

    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;
    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata/* Metadata */.S(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise()); // initializes the registry & RPC

    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);

    this._filterRpc(rpcMethods, (0,types_known/* getSpecRpc */.KM)(this.registry, chain, runtimeVersion.specName));

    this._subscribeUpdates(); // setup the initial registry, when we have none


    if (!(0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].length) {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _registries)[_registries].push({
        isDefault: true,
        lastBlockHash: null,
        metadata,
        metadataConsts: null,
        registry: this.registry,
        specVersion: runtimeVersion.specVersion
      });
    } // get unique types & validate


    metadata.getUniqTypes(false);
    return [genesisHash, metadata];
  }

  _initFromMeta(metadata) {
    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();
    this._rx.extrinsicType = this._extrinsicType;
    this._rx.genesisHash = this._genesisHash;
    this._rx.runtimeVersion = this._runtimeVersion; // must be set here
    // inject metadata and adjust the types as detected

    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx

    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities

    this._detectCapabilities(this.registry);

    return true;
  }

  _unsubscribeHealth() {
    if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _healthTimer)[_healthTimer]) {
      clearInterval((0,classPrivateFieldLooseBase/* default */.Z)(this, _healthTimer)[_healthTimer]);
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _healthTimer)[_healthTimer] = null;
    }
  }

  _unsubscribeUpdates() {
    if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSub)[_updateSub]) {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSub)[_updateSub].unsubscribe();

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _updateSub)[_updateSub] = null;
    }
  }

  _unsubscribe() {
    this._unsubscribeHealth();

    this._unsubscribeUpdates();
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/Getters.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0




function assertResult(value) {
  return (0,index_js_.assertReturn)(value, 'Api needs to be initialized before using, listen on \'ready\'');
}

class Getters extends Init {
  /**
   * @description Contains the parameter types (constants) of all modules.
   *
   * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
   *
   * @example
   * <BR>
   *
   * ```javascript
   * console.log(api.consts.democracy.enactmentPeriod.toString())
   * ```
   */
  get consts() {
    return assertResult(this._consts);
  }
  /**
   * @description Derived results that are injected into the API, allowing for combinations of various query results.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.derive.chain.bestNumber((number) => {
   *   console.log('best number', number);
   * });
   * ```
   */


  get derive() {
    return assertResult(this._derive);
  }
  /**
   * @description Errors from metadata
   */


  get errors() {
    return assertResult(this._errors);
  }
  /**
   * @description Events from metadata
   */


  get events() {
    return assertResult(this._events);
  }
  /**
   * @description  Returns the version of extrinsics in-use on this chain
   */


  get extrinsicVersion() {
    return this._extrinsicType;
  }
  /**
   * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
   */


  get genesisHash() {
    return assertResult(this._genesisHash);
  }
  /**
   * @description `true` when subscriptions are supported
   */


  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @description true is the underlying provider is connected
   */


  get isConnected() {
    return this._isConnected.getValue();
  }
  /**
   * @description The library information name & version (from package.json)
   */


  get libraryInfo() {
    return `${packageInfo/* packageInfo.name */.b.name} v${packageInfo/* packageInfo.version */.b.version}`;
  }
  /**
   * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
   *
   * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.query.system.account(<accountId>, ([nonce, balance]) => {
   *   console.log('new free balance', balance.free, 'new nonce', nonce);
   * });
   * ```
   */


  get query() {
    return assertResult(this._query);
  }
  /**
   * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const unsub = await api.queryMulti(
   *   [
   *     // you can include the storage without any parameters
   *     api.query.balances.totalIssuance,
   *     // or you can pass parameters to the storage query
   *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
   *   ],
   *   ([existential, [, { free }]]) => {
   *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
   *
   *     unsub();
   *   }
   * );
   * ```
   */


  get queryMulti() {
    return assertResult(this._queryMulti);
  }
  /**
   * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
   *
   * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.rpc.chain.subscribeNewHeads((header) => {
   *   console.log('new header', header);
   * });
   * ```
   */


  get rpc() {
    return assertResult(this._rpc);
  }
  /**
   * @description Contains the chain information for the current node.
   */


  get runtimeChain() {
    return assertResult(this._runtimeChain);
  }
  /**
   * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
   */


  get runtimeMetadata() {
    return assertResult(this._runtimeMetadata);
  }
  /**
   * @description Contains the version information for the current runtime.
   */


  get runtimeVersion() {
    return assertResult(this._runtimeVersion);
  }
  /**
   * @description The underlying Rx API interface
   */


  get rx() {
    return assertResult(this._rx);
  }
  /**
   * @description The type of this API instance, either 'rxjs' or 'promise'
   */


  get type() {
    return this._type;
  }
  /**
   * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.tx.balances
   *   .transfer(<recipientId>, <balance>)
   *   .signAndSend(<keyPair>, ({status}) => {
   *     console.log('tx status', status.asFinalized.toHex());
   *   });
   * ```
   */


  get tx() {
    return assertResult(this._extrinsics);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/base/index.js


function base_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function base_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { base_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { base_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


class ApiBase extends Getters {
  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(options = {}, type, decorateMethod) {
    super(options, type, decorateMethod);
  }
  /**
   * @description Connect from the underlying provider, halting all network traffic
   */


  connect() {
    return this._rpcCore.connect();
  }
  /**
   * @description Disconnect from the underlying provider, halting all network traffic
   */


  disconnect() {
    this._unsubscribe();

    return this._rpcCore.disconnect();
  }
  /**
   * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
   */


  findCall(callIndex) {
    return this.registry.findMetaCall((0,index_js_.u8aToU8a)(callIndex));
  }
  /**
   * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
   */


  findError(errorIndex) {
    return this.registry.findMetaError((0,index_js_.u8aToU8a)(errorIndex));
  }
  /**
   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
   */


  setSigner(signer) {
    this._rx.signer = signer;
  }
  /**
   * @description Signs a raw signer payload, string or Uint8Array
   */


  async sign(address, data, {
    signer
  } = {}) {
    if ((0,index_js_.isString)(address)) {
      const _signer = signer || this._rx.signer;

      (0,index_js_.assert)(_signer === null || _signer === void 0 ? void 0 : _signer.signRaw, 'No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
      return (await _signer.signRaw(base_objectSpread(base_objectSpread({
        type: 'bytes'
      }, data), {}, {
        address
      }))).signature;
    }

    return (0,index_js_.u8aToHex)(address.sign((0,index_js_.u8aToU8a)(data.data)));
  }

}

/***/ }),

/***/ 20762:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ packageInfo)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/api',
  version: '4.13.1'
};

/***/ }),

/***/ 7253:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "G": () => (/* binding */ ApiPromise),
  "g": () => (/* binding */ decorateMethod)
});

// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
var classPrivateFieldLooseBase = __webpack_require__(89539);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var classPrivateFieldLooseKey = __webpack_require__(38879);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
// EXTERNAL MODULE: consume shared module (default) @polkadot/x-rxjs@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/x-rxjs/index.js)
var x_rxjs_index_js_ = __webpack_require__(365);
// EXTERNAL MODULE: ../../node_modules/@polkadot/x-rxjs/cjs/operators.js
var operators = __webpack_require__(3191);
// EXTERNAL MODULE: ../../node_modules/@polkadot/api/base/index.js + 128 modules
var base = __webpack_require__(87982);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/promise/Combinator.js


// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


var _allHasFired = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("allHasFired");

var _callback = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("callback");

var _fired = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("fired");

var _fns = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("fns");

var _isActive = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("isActive");

var _results = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("results");

var _subscriptions = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("subscriptions");

class Combinator {
  constructor(fns, callback) {
    Object.defineProperty(this, _allHasFired, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _callback, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _fired, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _fns, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _isActive, {
      writable: true,
      value: true
    });
    Object.defineProperty(this, _results, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _subscriptions, {
      writable: true,
      value: []
    });
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _callback)[_callback] = callback; // eslint-disable-next-line @typescript-eslint/require-await

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions] = fns.map(async (input, index) => {
      const [fn, ...args] = Array.isArray(input) ? input : [input];

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _fired)[_fired].push(false);

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _fns)[_fns].push(fn); // Not quite 100% how to have a variable number at the front here
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/ban-types


      return fn(...args, this._createCallback(index));
    });
  }

  _allHasFired() {
    var _classPrivateFieldLoo;

    (_classPrivateFieldLoo = (0,classPrivateFieldLooseBase/* default */.Z)(this, _allHasFired))[_allHasFired] || (_classPrivateFieldLoo[_allHasFired] = (0,classPrivateFieldLooseBase/* default */.Z)(this, _fired)[_fired].filter(hasFired => !hasFired).length === 0);
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _allHasFired)[_allHasFired];
  }

  _createCallback(index) {
    return value => {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _fired)[_fired][index] = true;
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _results)[_results][index] = value;

      this._triggerUpdate();
    };
  }

  _triggerUpdate() {
    if (!(0,classPrivateFieldLooseBase/* default */.Z)(this, _isActive)[_isActive] || !(0,index_js_.isFunction)((0,classPrivateFieldLooseBase/* default */.Z)(this, _callback)[_callback]) || !this._allHasFired()) {
      return;
    }

    try {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _callback)[_callback]((0,classPrivateFieldLooseBase/* default */.Z)(this, _results)[_results]);
    } catch (error) {// swallow, we don't want the handler to trip us up
    }
  }

  unsubscribe() {
    if (!(0,classPrivateFieldLooseBase/* default */.Z)(this, _isActive)[_isActive]) {
      return;
    }

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _isActive)[_isActive] = false; // eslint-disable-next-line @typescript-eslint/no-misused-promises

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions].forEach(async subscription => {
      try {
        const unsubscribe = await subscription;

        if ((0,index_js_.isFunction)(unsubscribe)) {
          unsubscribe();
        }
      } catch (error) {// ignore
      }
    });
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api/promise/index.js




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0






// extract the arguments and callback params from a value array possibly containing a callback
function extractArgs(args, needsCallback) {
  let callback;
  const actualArgs = args.slice(); // If the last arg is a function, we pop it, put it into callback.
  // actualArgs will then hold the actual arguments to be passed to `method`

  if (args.length && (0,index_js_.isFunction)(args[args.length - 1])) {
    callback = actualArgs.pop();
  } // When we need a subscription, ensure that a valid callback is actually passed


  (0,index_js_.assert)(!needsCallback || (0,index_js_.isFunction)(callback), 'Expected a callback to be passed with subscriptions');
  return [actualArgs, callback];
} // a Promise completion tracker, wrapping an isComplete variable that ensures the promise only resolves once


function promiseTracker(resolve, reject) {
  let isCompleted = false;
  return {
    reject: error => {
      if (!isCompleted) {
        isCompleted = true;
        reject(error);
      }

      return x_rxjs_index_js_.EMPTY;
    },
    resolve: value => {
      if (!isCompleted) {
        isCompleted = true;
        resolve(value);
      }
    }
  };
} // Decorate a call for a single-shot result - retrieve and then immediate unsubscribe


function decorateCall(method, actualArgs) {
  return new Promise((resolve, reject) => {
    // single result tracker - either reject with Error or resolve with Codec result
    const tracker = promiseTracker(resolve, reject); // encoding errors reject immediately, any result unsubscribes and resolves

    const subscription = method(...actualArgs).pipe((0,operators/* catchError */.KQ)(error => tracker.reject(error))).subscribe(result => {
      tracker.resolve(result);
      setTimeout(() => subscription.unsubscribe(), 0);
    });
  });
} // Decorate a subscription where we have a result callback specified


function decorateSubscribe(method, actualArgs, resultCb) {
  return new Promise((resolve, reject) => {
    // either reject with error or resolve with unsubscribe callback
    const tracker = promiseTracker(resolve, reject); // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback

    const subscription = method(...actualArgs).pipe((0,operators/* catchError */.KQ)(error => tracker.reject(error)), (0,operators/* tap */.bw)(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe(result => {
      // queue result (back of queue to clear current)
      setTimeout(() => resultCb(result), 0);
    });
  });
}
/**
 * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent
 */


function decorateMethod(method, options) {
  const needsCallback = options && options.methodName && options.methodName.includes('subscribe');
  return function (...args) {
    const [actualArgs, resultCb] = extractArgs(args, !!needsCallback);
    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall((options === null || options === void 0 ? void 0 : options.overrideNoSub) || method, actualArgs);
  };
}
/**
 * # @polkadot/api/promise
 *
 * ## Overview
 *
 * @name ApiPromise
 * @description
 * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.
 *
 * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.
 *
 * @see [[ApiRx]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * // initialise via static create
 * const api = await ApiPromise.create();
 *
 * // make a subscription to the network head
 * api.rpc.chain.subscribeNewHeads((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { ApiPromise, WsProvider } from '@polkadot/api';
 *
 * // initialise a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialise via isReady & new with specific provider
 * const api = await new ApiPromise({ provider }).isReady;
 *
 * // retrieve the block target time
 * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();
 * let last = 0;
 *
 * // subscribe to the current block timestamp, updates automatically (callback provided)
 * api.query.timestamp.now((timestamp) => {
 *   const elapsed = last
 *     ? `, ${timestamp.toNumber() - last}s since last`
 *     : '';
 *
 *   last = timestamp.toNumber();
 *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);
 * });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * ApiPromise.create().then((api) => {
 *   const [nonce] = await api.query.system.account(keyring.alice.address);
 *
 *   api.tx.balances
 *     // create transfer
 *     transfer(keyring.bob.address, 12345)
 *     // sign the transcation
 *     .sign(keyring.alice, { nonce })
 *     // send the transaction (optional status callback)
 *     .send((status) => {
 *       console.log(`current status ${status.type}`);
 *     })
 *     // retrieve the submitted extrinsic hash
 *     .then((hash) => {
 *       console.log(`submitted with hash ${hash}`);
 *     });
 * });
 * ```
 */

var _isReadyPromise = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("isReadyPromise");

var _isReadyOrErrorPromise = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("isReadyOrErrorPromise");

class ApiPromise extends base/* ApiBase */.q {
  /**
   * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
   * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
   * provider (see the constructor arguments)
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * Api.create().then(async (api) => {
   *   const timestamp = await api.query.timestamp.now();
   *
   *   console.log(`lastest block timestamp ${timestamp}`);
   * });
   * ```
   */
  static create(options) {
    const instance = new ApiPromise(options);

    if (options && options.throwOnConnect) {
      return instance.isReadyOrError;
    } // Swallow any rejections on isReadyOrError
    // (in Node 15.x this creates issues, when not being looked at)


    instance.isReadyOrError.catch(() => {// ignore
    });
    return instance.isReady;
  }
  /**
   * @description Creates an instance of the ApiPromise class
   * @param options Options to create an instance. This can be either [[ApiOptions]] or
   * an [[WsProvider]].
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * new Api().isReady.then((api) => {
   *   api.rpc.subscribeNewHeads((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * });
   * ```
   */


  constructor(options) {
    super(options, 'promise', decorateMethod);
    Object.defineProperty(this, _isReadyPromise, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isReadyOrErrorPromise, {
      writable: true,
      value: void 0
    });
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyPromise)[_isReadyPromise] = new Promise(resolve => {
      super.once('ready', () => resolve(this));
    });
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyOrErrorPromise)[_isReadyOrErrorPromise] = new Promise((resolve, reject) => {
      const tracker = promiseTracker(resolve, reject);
      super.once('ready', () => tracker.resolve(this));
      super.once('error', e => tracker.reject(e));
    });
  }
  /**
   * @description Promise that resolves the first time we are connected and loaded
   */


  get isReady() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyPromise)[_isReadyPromise];
  }
  /**
   * @description Promise that resolves if we can connect, or reject if there is an error
   */


  get isReadyOrError() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyOrErrorPromise)[_isReadyOrErrorPromise];
  }
  /**
   * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
   */


  clone() {
    return new ApiPromise(_objectSpread(_objectSpread({}, this._options), {}, {
      source: this
    }));
  }
  /**
   * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
   * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
   * @param callback A callback that will return an Array of all the values this combinator has been applied to
   * @example
   * <BR>
   *
   * ```javascript
   * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
   *
   * // combines values from balance & nonce as it updates
   * api.combineLatest([
   *   api.rpc.chain.subscribeNewHeads,
   *   (cb) => api.query.system.account(address, cb)
   * ], ([head, [balance, nonce]]) => {
   *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
   * });
   * ```
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async combineLatest(fns, callback) {
    const combinator = new Combinator(fns, callback);
    return () => {
      combinator.unsubscribe();
    };
  }

}

/***/ }),

/***/ 70242:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ SubmittableResult)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const recordIdentity = record => record;

function filterAndApply(events, section, methods, onFound) {
  return events.filter(({
    event
  }) => section === event.section && methods.includes(event.method)).map(record => onFound(record));
}

function extractError(events = []) {
  return filterAndApply(events, 'system', ['ExtrinsicFailed'], ({
    event: {
      data
    }
  }) => data[0])[0];
}

function extractInfo(events = []) {
  return filterAndApply(events, 'system', ['ExtrinsicFailed', 'ExtrinsicSuccess'], ({
    event: {
      data,
      method
    }
  }) => method === 'ExtrinsicSuccess' ? data[0] : data[1])[0];
}

class SubmittableResult {
  constructor({
    dispatchError,
    dispatchInfo,
    events,
    internalError,
    status
  }) {
    this.dispatchError = void 0;
    this.dispatchInfo = void 0;
    this.internalError = void 0;
    this.events = void 0;
    this.status = void 0;
    this.dispatchError = dispatchError || extractError(events);
    this.dispatchInfo = dispatchInfo || extractInfo(events);
    this.events = events || [];
    this.internalError = internalError;
    this.status = status;
  }

  get isCompleted() {
    return this.isError || this.status.isInBlock || this.status.isFinalized;
  }

  get isError() {
    return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
  }

  get isFinalized() {
    return this.status.isFinalized;
  }

  get isInBlock() {
    return this.status.isInBlock;
  }

  get isWarning() {
    return this.status.isRetracted;
  }
  /**
   * @description Filters EventRecords for the specified method & section (there could be multiple)
   */


  filterRecords(section, method) {
    return filterAndApply(this.events, section, Array.isArray(method) ? method : [method], recordIdentity);
  }
  /**
   * @description Finds an EventRecord for the specified method & section
   */


  findRecord(section, method) {
    return this.filterRecords(section, method)[0];
  }
  /**
   * @description Creates a human representation of the output
   */


  toHuman(isExtended) {
    var _this$dispatchError, _this$dispatchInfo, _this$internalError;

    return {
      dispatchError: (_this$dispatchError = this.dispatchError) === null || _this$dispatchError === void 0 ? void 0 : _this$dispatchError.toHuman(),
      dispatchInfo: (_this$dispatchInfo = this.dispatchInfo) === null || _this$dispatchInfo === void 0 ? void 0 : _this$dispatchInfo.toHuman(),
      events: this.events.map(event => event.toHuman(isExtended)),
      internalError: (_this$internalError = this.internalError) === null || _this$internalError === void 0 ? void 0 : _this$internalError.message.toString(),
      status: this.status.toHuman(isExtended)
    };
  }

}

/***/ }),

/***/ 67162:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ packageInfo)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/rpc-core',
  version: '4.13.1'
};

/***/ }),

/***/ 54141:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ drr)
/* harmony export */ });
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13948);
/* harmony import */ var _polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3191);
/* harmony import */ var _refCountDelay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50192);
// Copyright 2017-2021 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0



const l = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.logger)('drr');

const CMP = (a, b) => (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.stringify)({
  t: a
}) === (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.stringify)({
  t: b
});

const ERR = error => {
  l.error(error.message);
  throw error;
};

const NOOP = () => undefined;
/**
 * Shorthand for distinctUntilChanged(), publishReplay(1) and refCount().
 *
 * @ignore
 * @internal
 */


const drr = ({
  delay,
  skipChange = false,
  skipTimeout = false
} = {}) => source$ => source$.pipe((0,_polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .catchError */ .KQ)(ERR), skipChange ? (0,_polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .tap */ .bw)(NOOP) : (0,_polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .distinctUntilChanged */ .xb)(CMP), (0,_polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .publishReplay */ ._g)(1), skipTimeout ? (0,_polkadot_x_rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .refCount */ .Gz)() : (0,_refCountDelay_js__WEBPACK_IMPORTED_MODULE_2__/* .refCountDelay */ .f)(delay));

/***/ }),

/***/ 50192:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": () => (/* binding */ refCountDelay)
/* harmony export */ });
/* harmony import */ var _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(365);
// Copyright 2017-2021 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */

function refCountDelay(delay = 1750) {
  return source => {
    // state: 0 = disconnected, 1 = disconnecting, 2 = connecting, 3 = connected
    let [state, refCount, connection, scheduler] = [0, 0, _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_0__.Subscription.EMPTY, _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_0__.Subscription.EMPTY];
    return new _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable(ob => {
      source.subscribe(ob);

      if (refCount++ === 0) {
        if (state === 1) {
          scheduler.unsubscribe();
        } else {
          connection = source.connect();
        }

        state = 3;
      }

      return () => {
        if (--refCount === 0) {
          if (state === 2) {
            state = 0;
            scheduler.unsubscribe();
          } else {
            // state === 3
            state = 1;
            scheduler = _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_0__.asapScheduler.schedule(() => {
              state = 0;
              connection.unsubscribe();
            }, delay);
          }
        }
      };
    });
  };
}

/***/ }),

/***/ 11082:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ packageInfo)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/rpc-provider',
  version: '4.13.1'
};

/***/ }),

/***/ 73406:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "U": () => (/* binding */ WsProvider)
});

// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
var classPrivateFieldLooseBase = __webpack_require__(89539);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var classPrivateFieldLooseKey = __webpack_require__(38879);
// EXTERNAL MODULE: ../../node_modules/eventemitter3/index.js
var eventemitter3 = __webpack_require__(10161);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
// EXTERNAL MODULE: ../../node_modules/@polkadot/x-global/index.js
var x_global = __webpack_require__(64513);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-ws/browser.js
// Copyright 2017-2021 @polkadot/x-ws authors & contributors
// SPDX-License-Identifier: Apache-2.0


const WebSocket = x_global/* xglobal.WebSocket */.U.WebSocket;
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-provider/coder/index.js


// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0


function formatErrorData(data) {
  if ((0,index_js_.isUndefined)(data)) {
    return '';
  }

  const formatted = `: ${(0,index_js_.isString)(data) ? data.replace(/Error\("/g, '').replace(/\("/g, '(').replace(/"\)/g, ')').replace(/\(/g, ', ').replace(/\)/g, '') : (0,index_js_.stringify)(data)}`; // We need some sort of cut-off here since these can be very large and
  // very nested, pick a number and trim the result display to it

  return formatted.length <= 256 ? formatted : `${formatted.substr(0, 255)}`;
}
/** @internal */


var _id = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("id");

class RpcCoder {
  constructor() {
    Object.defineProperty(this, _id, {
      writable: true,
      value: 0
    });
  }

  decodeResponse(response) {
    (0,index_js_.assert)(response, 'Empty response object received');
    (0,index_js_.assert)(response.jsonrpc === '2.0', 'Invalid jsonrpc field in decoded object');
    const isSubscription = !(0,index_js_.isUndefined)(response.params) && !(0,index_js_.isUndefined)(response.method);
    (0,index_js_.assert)((0,index_js_.isNumber)(response.id) || isSubscription && ((0,index_js_.isNumber)(response.params.subscription) || (0,index_js_.isString)(response.params.subscription)), 'Invalid id field in decoded object');

    this._checkError(response.error);

    (0,index_js_.assert)(!(0,index_js_.isUndefined)(response.result) || isSubscription, 'No result found in JsonRpc response');

    if (isSubscription) {
      this._checkError(response.params.error);

      return response.params.result;
    }

    return response.result;
  }

  encodeJson(method, params) {
    return (0,index_js_.stringify)(this.encodeObject(method, params));
  }

  encodeObject(method, params) {
    return {
      id: ++(0,classPrivateFieldLooseBase/* default */.Z)(this, _id)[_id],
      jsonrpc: '2.0',
      method,
      params
    };
  }

  getId() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _id)[_id];
  }

  _checkError(error) {
    if (error) {
      const {
        code,
        data,
        message
      } = error;
      throw new Error(`${code}: ${message}${formatErrorData(data)}`);
    }
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-provider/defaults.js
// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
const HTTP_URL = 'http://127.0.0.1:9933';
const WS_URL = 'ws://127.0.0.1:9944';
/* harmony default export */ const defaults = ({
  HTTP_URL,
  WS_URL
});
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-provider/ws/errors.js
// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// from https://stackoverflow.com/questions/19304157/getting-the-reason-why-websockets-closed-with-close-code-1006
const known = {
  1000: 'Normal Closure',
  1001: 'Going Away',
  1002: 'Protocol Error',
  1003: 'Unsupported Data',
  1004: '(For future)',
  1005: 'No Status Received',
  1006: 'Abnormal Closure',
  1007: 'Invalid frame payload data',
  1008: 'Policy Violation',
  1009: 'Message too big',
  1010: 'Missing Extension',
  1011: 'Internal Error',
  1012: 'Service Restart',
  1013: 'Try Again Later',
  1014: 'Bad Gateway',
  1015: 'TLS Handshake'
};

function getUnmapped(code) {
  if (code <= 1999) {
    return '(For WebSocket standard)';
  } else if (code <= 2999) {
    return '(For WebSocket extensions)';
  } else if (code <= 3999) {
    return '(For libraries and frameworks)';
  } else if (code <= 4999) {
    return '(For applications)';
  }
}

function getWSErrorString(code) {
  if (code >= 0 && code <= 999) {
    return '(Unused)';
  }

  return known[code] || getUnmapped(code) || '(Unknown)';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/rpc-provider/ws/index.js




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable camelcase */







const ALIASES = {
  chain_finalisedHead: 'chain_finalizedHead',
  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',
  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'
};
const RETRY_DELAY = 2500;
const l = (0,index_js_.logger)('api-ws');

function eraseRecord(record, cb) {
  Object.keys(record).forEach(key => {
    if (cb) {
      cb(record[key]);
    }

    delete record[key];
  });
}
/**
 * # @polkadot/rpc-provider/ws
 *
 * @name WsProvider
 *
 * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import { WsProvider } from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 *
 * @see [[HttpProvider]]
 */


var _coder = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("coder");

var _endpoints = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("endpoints");

var _headers = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("headers");

var _eventemitter = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("eventemitter");

var _handlers = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("handlers");

var _isReadyPromise = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("isReadyPromise");

var _waitingForId = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("waitingForId");

var _autoConnectMs = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("autoConnectMs");

var _endpointIndex = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("endpointIndex");

var _isConnected = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("isConnected");

var _subscriptions = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("subscriptions");

var _websocket = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("websocket");

var _emit = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("emit");

var _onSocketClose = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketClose");

var _onSocketError = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketError");

var _onSocketMessage = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketMessage");

var _onSocketMessageResult = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketMessageResult");

var _onSocketMessageSubscribe = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketMessageSubscribe");

var _onSocketOpen = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("onSocketOpen");

var _resubscribe = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("resubscribe");

class WsProvider {
  /**
   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
   * @param {boolean} autoConnect Whether to connect automatically or not.
   */
  constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}) {
    Object.defineProperty(this, _coder, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpoints, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _headers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _eventemitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _isReadyPromise, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _waitingForId, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _autoConnectMs, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpointIndex, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isConnected, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _subscriptions, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _websocket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emit, {
      writable: true,
      value: (type, ...args) => {
        (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].emit(type, ...args);
      }
    });
    Object.defineProperty(this, _onSocketClose, {
      writable: true,
      value: event => {
        const error = new Error(`disconnected from ${(0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints][(0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);

        if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs] > 0) {
          l.error(error.message);
        }

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _isConnected)[_isConnected] = false;

        if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket]) {
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onclose = null;
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onerror = null;
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onmessage = null;
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onopen = null;
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket] = null;
        }

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _emit)[_emit]('disconnected'); // reject all hanging requests


        eraseRecord((0,classPrivateFieldLooseBase/* default */.Z)(this, _handlers)[_handlers], h => h.callback(error, undefined));
        eraseRecord((0,classPrivateFieldLooseBase/* default */.Z)(this, _waitingForId)[_waitingForId]);

        if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs] > 0) {
          setTimeout(() => {
            this.connectWithRetry().catch(() => {// does not throw
            });
          }, (0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs]);
        }
      }
    });
    Object.defineProperty(this, _onSocketError, {
      writable: true,
      value: error => {
        l.debug(() => ['socket error', error]);

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _emit)[_emit]('error', error);
      }
    });
    Object.defineProperty(this, _onSocketMessage, {
      writable: true,
      value: message => {
        l.debug(() => ['received', message.data]);
        const response = JSON.parse(message.data);
        return (0,index_js_.isUndefined)(response.method) ? (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketMessageResult)[_onSocketMessageResult](response) : (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);
      }
    });
    Object.defineProperty(this, _onSocketMessageResult, {
      writable: true,
      value: response => {
        const handler = (0,classPrivateFieldLooseBase/* default */.Z)(this, _handlers)[_handlers][response.id];

        if (!handler) {
          l.debug(() => `Unable to find handler for id=${response.id}`);
          return;
        }

        try {
          const {
            method,
            params,
            subscription
          } = handler;

          const result = (0,classPrivateFieldLooseBase/* default */.Z)(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update
          // immediately if we have some queued results already


          handler.callback(null, result);

          if (subscription) {
            const subId = `${subscription.type}::${result}`;
            (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {
              method,
              params
            }); // if we have a result waiting for this subscription already

            if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _waitingForId)[_waitingForId][subId]) {
              (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe]((0,classPrivateFieldLooseBase/* default */.Z)(this, _waitingForId)[_waitingForId][subId]);
            }
          }
        } catch (error) {
          handler.callback(error, undefined);
        }

        delete (0,classPrivateFieldLooseBase/* default */.Z)(this, _handlers)[_handlers][response.id];
      }
    });
    Object.defineProperty(this, _onSocketMessageSubscribe, {
      writable: true,
      value: response => {
        const method = ALIASES[response.method] || response.method || 'invalid';
        const subId = `${method}::${response.params.subscription}`;

        const handler = (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions][subId];

        if (!handler) {
          // store the JSON, we could have out-of-order subid coming in
          (0,classPrivateFieldLooseBase/* default */.Z)(this, _waitingForId)[_waitingForId][subId] = response;
          l.debug(() => `Unable to find handler for subscription=${subId}`);
          return;
        } // housekeeping


        delete (0,classPrivateFieldLooseBase/* default */.Z)(this, _waitingForId)[_waitingForId][subId];

        try {
          const result = (0,classPrivateFieldLooseBase/* default */.Z)(this, _coder)[_coder].decodeResponse(response);

          handler.callback(null, result);
        } catch (error) {
          handler.callback(error, undefined);
        }
      }
    });
    Object.defineProperty(this, _onSocketOpen, {
      writable: true,
      value: () => {
        (0,index_js_.assert)(!(0,index_js_.isNull)((0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');
        l.debug(() => ['connected to', (0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints][(0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex]]]);
        (0,classPrivateFieldLooseBase/* default */.Z)(this, _isConnected)[_isConnected] = true;

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _emit)[_emit]('connected');

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _resubscribe)[_resubscribe]();

        return true;
      }
    });
    Object.defineProperty(this, _resubscribe, {
      writable: true,
      value: () => {
        const subscriptions = (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions];

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions] = {};
        Promise.all(Object.keys(subscriptions).map(async id => {
          const {
            callback,
            method,
            params,
            type
          } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where
          // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
          // are not included (and will not be re-broadcast)

          if (type.startsWith('author_')) {
            return;
          }

          try {
            await this.subscribe(type, method, params, callback);
          } catch (error) {
            l.error(error);
          }
        })).catch(l.error);
      }
    });
    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];
    (0,index_js_.assert)(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');
    endpoints.forEach(endpoint => {
      (0,index_js_.assert)(/^(wss|ws):\/\//.test(endpoint), () => `Endpoint should start with 'ws://', received '${endpoint}'`);
    });
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter] = new eventemitter3();
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _coder)[_coder] = new RpcCoder();
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex] = -1;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints] = endpoints;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _headers)[_headers] = headers;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket] = null;

    if (autoConnectMs > 0) {
      this.connectWithRetry().catch(() => {// does not throw
      });
    }

    (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyPromise)[_isReadyPromise] = new Promise(resolve => {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].once('connected', () => {
        resolve(this);
      });
    });
  }
  /**
   * @summary `true` when this provider supports subscriptions
   */


  get hasSubscriptions() {
    return true;
  }
  /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */


  get isConnected() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _isConnected)[_isConnected];
  }
  /**
   * @description Promise that resolves the first time we are connected and loaded
   */


  get isReady() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _isReadyPromise)[_isReadyPromise];
  }
  /**
   * @description Returns a clone of the object
   */


  clone() {
    return new WsProvider((0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints]);
  }
  /**
   * @summary Manually connect
   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
   * connect manually using this method.
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async connect() {
    try {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex] = ((0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex] + 1) % (0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints].length;
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket] = typeof x_global/* xglobal.WebSocket */.U.WebSocket !== 'undefined' && (0,index_js_.isChildClass)(x_global/* xglobal.WebSocket */.U.WebSocket, WebSocket) ? new WebSocket((0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints][(0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore - WS may be an instance of w3cwebsocket, which supports headers
      : new WebSocket((0,classPrivateFieldLooseBase/* default */.Z)(this, _endpoints)[_endpoints][(0,classPrivateFieldLooseBase/* default */.Z)(this, _endpointIndex)[_endpointIndex]], undefined, undefined, (0,classPrivateFieldLooseBase/* default */.Z)(this, _headers)[_headers], undefined, {
        // default: true
        fragmentOutgoingMessages: true,
        // default: 16K (bump, the Node has issues with too many fragments, e.g. on setCode)
        fragmentationThreshold: 256 * 1024,
        // default: 8MB (however Polkadot api.query.staking.erasStakers.entries(356) is over that)
        maxReceivedMessageSize: 16 * 1024 * 1024
      });
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onclose = (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketClose)[_onSocketClose];
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onerror = (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketError)[_onSocketError];
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onmessage = (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketMessage)[_onSocketMessage];
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].onopen = (0,classPrivateFieldLooseBase/* default */.Z)(this, _onSocketOpen)[_onSocketOpen];
    } catch (error) {
      l.error(error);

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _emit)[_emit]('error', error);

      throw error;
    }
  }
  /**
   * @description Connect, never throwing an error, but rather forcing a retry
   */


  async connectWithRetry() {
    if ((0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs] > 0) {
      try {
        await this.connect();
      } catch (error) {
        setTimeout(() => {
          this.connectWithRetry().catch(() => {// does not throw
          });
        }, (0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs]);
      }
    }
  }
  /**
   * @description Manually disconnect from the connection, clearing autoconnect logic
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async disconnect() {
    try {
      (0,index_js_.assert)(!(0,index_js_.isNull)((0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket]), 'Cannot disconnect on a non-connected websocket'); // switch off autoConnect, we are in manual mode now

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].close(1000);
    } catch (error) {
      l.error(error);

      (0,classPrivateFieldLooseBase/* default */.Z)(this, _emit)[_emit]('error', error);

      throw error;
    }
  }
  /**
   * @summary Listens on events after having subscribed using the [[subscribe]] function.
   * @param  {ProviderInterfaceEmitted} type Event
   * @param  {ProviderInterfaceEmitCb}  sub  Callback
   * @return unsubscribe function
   */


  on(type, sub) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].on(type, sub);

    return () => {
      (0,classPrivateFieldLooseBase/* default */.Z)(this, _eventemitter)[_eventemitter].removeListener(type, sub);
    };
  }
  /**
   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
   * @param method The RPC methods to execute
   * @param params Encoded parameters as applicable for the method
   * @param subscription Subscription details (internally used)
   */


  send(method, params, subscription) {
    return new Promise((resolve, reject) => {
      try {
        (0,index_js_.assert)(this.isConnected && !(0,index_js_.isNull)((0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket]), 'WebSocket is not connected');

        const json = (0,classPrivateFieldLooseBase/* default */.Z)(this, _coder)[_coder].encodeJson(method, params);

        const id = (0,classPrivateFieldLooseBase/* default */.Z)(this, _coder)[_coder].getId();

        const callback = (error, result) => {
          error ? reject(error) : resolve(result);
        };

        l.debug(() => ['calling', method, json]);
        (0,classPrivateFieldLooseBase/* default */.Z)(this, _handlers)[_handlers][id] = {
          callback,
          method,
          params,
          subscription
        };

        (0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket].send(json);
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * @name subscribe
   * @summary Allows subscribing to a specific event.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const provider = new WsProvider('ws://127.0.0.1:9944');
   * const rpc = new Rpc(provider);
   *
   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
   *   console.log(values)
   * }).then((subscriptionId) => {
   *   console.log('balance changes subscription id: ', subscriptionId)
   * })
   * ```
   */


  subscribe(type, method, params, callback) {
    return this.send(method, params, {
      callback,
      type
    });
  }
  /**
   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
   */


  async unsubscribe(type, method, id) {
    const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub
    // the assigned id now does not match what the API user originally received. It has
    // a slight complication in solving - since we cannot rely on the send id, but rather
    // need to find the actual subscription id to map it

    if ((0,index_js_.isUndefined)((0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions][subscription])) {
      l.debug(() => `Unable to find active subscription=${subscription}`);
      return false;
    }

    delete (0,classPrivateFieldLooseBase/* default */.Z)(this, _subscriptions)[_subscriptions][subscription];

    try {
      return this.isConnected && !(0,index_js_.isNull)((0,classPrivateFieldLooseBase/* default */.Z)(this, _websocket)[_websocket]) ? this.send(method, [id]) : true;
    } catch (error) {
      return false;
    }
  }

}

/***/ }),

/***/ 39764:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51119);
/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26248);


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

const jsonrpc = {};
Object.keys(_definitions_js__WEBPACK_IMPORTED_MODULE_1__).filter(key => Object.keys(_definitions_js__WEBPACK_IMPORTED_MODULE_1__[key].rpc || {}).length !== 0).forEach(_section => {
  jsonrpc[_section] = {};
  Object.entries(_definitions_js__WEBPACK_IMPORTED_MODULE_1__[_section].rpc).forEach(([method, def]) => {
    const isSubscription = !!def.pubsub;
    const section = def.aliasSection || _section; // allow for section overrides

    if (!jsonrpc[section]) {
      jsonrpc[section] = {};
    }

    jsonrpc[section][method] = _objectSpread(_objectSpread({}, def), {}, {
      isSubscription,
      jsonrpc: `${section}_${method}`,
      method,
      section
    });
  });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jsonrpc);

/***/ }),

/***/ 64513:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ xglobal)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/x-fetch authors & contributors
// SPDX-License-Identifier: Apache-2.0

const xglobal = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : undefined;

/***/ }),

/***/ 3191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
// Copyright 2017-2021 @polkadot/x-rxjs authors & contributors
// SPDX-License-Identifier: Apache-2.0

// This is not great, but while having esm files, rxjs doesn't quite play nicely with
// Node.js esm files. (Hopefully this improves in 7.0, although no exports map as of yet)

const operators = __webpack_require__(64546);

__webpack_unused_export__ = operators.audit;
__webpack_unused_export__ = operators.auditTime;
__webpack_unused_export__ = operators.buffer;
__webpack_unused_export__ = operators.bufferCount;
__webpack_unused_export__ = operators.bufferTime;
__webpack_unused_export__ = operators.bufferToggle;
__webpack_unused_export__ = operators.bufferWhen;
exports.KQ = operators.catchError;
__webpack_unused_export__ = operators.combineAll;
__webpack_unused_export__ = operators.combineLatest;
__webpack_unused_export__ = operators.concat;
__webpack_unused_export__ = operators.concatAll;
__webpack_unused_export__ = operators.concatMap;
__webpack_unused_export__ = operators.concatMapTo;
__webpack_unused_export__ = operators.count;
__webpack_unused_export__ = operators.debounce;
__webpack_unused_export__ = operators.debounceTime;
__webpack_unused_export__ = operators.defaultIfEmpty;
__webpack_unused_export__ = operators.delay;
__webpack_unused_export__ = operators.delayWhen;
__webpack_unused_export__ = operators.dematerialize;
__webpack_unused_export__ = operators.distinct;
exports.xb = operators.distinctUntilChanged;
__webpack_unused_export__ = operators.distinctUntilKeyChanged;
__webpack_unused_export__ = operators.elementAt;
__webpack_unused_export__ = operators.endWith;
__webpack_unused_export__ = operators.every;
__webpack_unused_export__ = operators.exhaust;
__webpack_unused_export__ = operators.exhaustMap;
__webpack_unused_export__ = operators.expand;
__webpack_unused_export__ = operators.filter;
__webpack_unused_export__ = operators.finalize;
__webpack_unused_export__ = operators.find;
__webpack_unused_export__ = operators.findIndex;
exports.Ps = operators.first;
__webpack_unused_export__ = operators.groupBy;
__webpack_unused_export__ = operators.ignoreElements;
__webpack_unused_export__ = operators.isEmpty;
__webpack_unused_export__ = operators.last;
exports.UI = operators.map;
exports.hZ = operators.mapTo;
__webpack_unused_export__ = operators.materialize;
__webpack_unused_export__ = operators.max;
__webpack_unused_export__ = operators.merge;
__webpack_unused_export__ = operators.mergeAll;
exports.zg = operators.mergeMap;
__webpack_unused_export__ = operators.flatMap;
__webpack_unused_export__ = operators.mergeMapTo;
__webpack_unused_export__ = operators.mergeScan;
__webpack_unused_export__ = operators.min;
__webpack_unused_export__ = operators.multicast;
__webpack_unused_export__ = operators.observeOn;
__webpack_unused_export__ = operators.onErrorResumeNext;
__webpack_unused_export__ = operators.pairwise;
__webpack_unused_export__ = operators.partition;
__webpack_unused_export__ = operators.pluck;
__webpack_unused_export__ = operators.publish;
__webpack_unused_export__ = operators.publishBehavior;
__webpack_unused_export__ = operators.publishLast;
exports._g = operators.publishReplay;
__webpack_unused_export__ = operators.race;
__webpack_unused_export__ = operators.reduce;
__webpack_unused_export__ = operators.repeat;
__webpack_unused_export__ = operators.repeatWhen;
__webpack_unused_export__ = operators.retry;
__webpack_unused_export__ = operators.retryWhen;
exports.Gz = operators.refCount;
__webpack_unused_export__ = operators.sample;
__webpack_unused_export__ = operators.sampleTime;
__webpack_unused_export__ = operators.scan;
__webpack_unused_export__ = operators.sequenceEqual;
__webpack_unused_export__ = operators.share;
__webpack_unused_export__ = operators.shareReplay;
__webpack_unused_export__ = operators.single;
__webpack_unused_export__ = operators.skip;
__webpack_unused_export__ = operators.skipLast;
__webpack_unused_export__ = operators.skipUntil;
__webpack_unused_export__ = operators.skipWhile;
exports.O4 = operators.startWith;
__webpack_unused_export__ = operators.subscribeOn;
__webpack_unused_export__ = operators.switchAll;
exports.wt = operators.switchMap;
__webpack_unused_export__ = operators.switchMapTo;
exports.qn = operators.take;
__webpack_unused_export__ = operators.takeLast;
__webpack_unused_export__ = operators.takeUntil;
__webpack_unused_export__ = operators.takeWhile;
exports.bw = operators.tap;
__webpack_unused_export__ = operators.throttle;
__webpack_unused_export__ = operators.throttleTime;
__webpack_unused_export__ = operators.throwIfEmpty;
__webpack_unused_export__ = operators.timeInterval;
__webpack_unused_export__ = operators.timeout;
__webpack_unused_export__ = operators.timeoutWith;
__webpack_unused_export__ = operators.timestamp;
exports.qo = operators.toArray;
__webpack_unused_export__ = operators.window;
__webpack_unused_export__ = operators.windowCount;
__webpack_unused_export__ = operators.windowTime;
__webpack_unused_export__ = operators.windowToggle;
__webpack_unused_export__ = operators.windowWhen;
__webpack_unused_export__ = operators.withLatestFrom;
__webpack_unused_export__ = operators.zip;
__webpack_unused_export__ = operators.zipAll;


/***/ }),

/***/ 10161:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 79250:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": () => (/* binding */ catchError)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2995);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93694);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .SimpleInnerSubscriber */ .IY(this);
            this.add(innerSubscriber);
            var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .innerSubscribe */ .ft)(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .SimpleOuterSubscriber */ .Ds));
//# sourceMappingURL=catchError.js.map


/***/ }),

/***/ 64805:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ switchMap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2995);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92188);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97238);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93694);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return (0,_observable_from__WEBPACK_IMPORTED_MODULE_0__/* .from */ .D)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleInnerSubscriber */ .IY(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .innerSubscribe */ .ft)(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleOuterSubscriber */ .Ds));
//# sourceMappingURL=switchMap.js.map


/***/ }),

/***/ 64546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "audit": () => (/* reexport */ audit),
  "auditTime": () => (/* reexport */ auditTime),
  "buffer": () => (/* reexport */ buffer),
  "bufferCount": () => (/* reexport */ bufferCount),
  "bufferTime": () => (/* reexport */ bufferTime),
  "bufferToggle": () => (/* reexport */ bufferToggle),
  "bufferWhen": () => (/* reexport */ bufferWhen),
  "catchError": () => (/* reexport */ catchError/* catchError */.K),
  "combineAll": () => (/* reexport */ combineAll),
  "combineLatest": () => (/* reexport */ combineLatest_combineLatest),
  "concat": () => (/* reexport */ concat_concat),
  "concatAll": () => (/* reexport */ concatAll/* concatAll */.u),
  "concatMap": () => (/* reexport */ concatMap),
  "concatMapTo": () => (/* reexport */ concatMapTo),
  "count": () => (/* reexport */ count),
  "debounce": () => (/* reexport */ debounce),
  "debounceTime": () => (/* reexport */ debounceTime),
  "defaultIfEmpty": () => (/* reexport */ defaultIfEmpty),
  "delay": () => (/* reexport */ delay),
  "delayWhen": () => (/* reexport */ delayWhen),
  "dematerialize": () => (/* reexport */ dematerialize),
  "distinct": () => (/* reexport */ distinct),
  "distinctUntilChanged": () => (/* reexport */ distinctUntilChanged),
  "distinctUntilKeyChanged": () => (/* reexport */ distinctUntilKeyChanged),
  "elementAt": () => (/* reexport */ elementAt),
  "endWith": () => (/* reexport */ endWith),
  "every": () => (/* reexport */ every),
  "exhaust": () => (/* reexport */ exhaust),
  "exhaustMap": () => (/* reexport */ exhaustMap),
  "expand": () => (/* reexport */ expand),
  "filter": () => (/* reexport */ filter/* filter */.h),
  "finalize": () => (/* reexport */ finalize),
  "find": () => (/* reexport */ find),
  "findIndex": () => (/* reexport */ findIndex),
  "first": () => (/* reexport */ first),
  "flatMap": () => (/* reexport */ mergeMap/* flatMap */.VS),
  "groupBy": () => (/* reexport */ groupBy/* groupBy */.v),
  "ignoreElements": () => (/* reexport */ ignoreElements),
  "isEmpty": () => (/* reexport */ isEmpty),
  "last": () => (/* reexport */ last),
  "map": () => (/* reexport */ map/* map */.U),
  "mapTo": () => (/* reexport */ mapTo),
  "materialize": () => (/* reexport */ materialize),
  "max": () => (/* reexport */ max),
  "merge": () => (/* reexport */ merge_merge),
  "mergeAll": () => (/* reexport */ mergeAll/* mergeAll */.J),
  "mergeMap": () => (/* reexport */ mergeMap/* mergeMap */.zg),
  "mergeMapTo": () => (/* reexport */ mergeMapTo),
  "mergeScan": () => (/* reexport */ mergeScan),
  "min": () => (/* reexport */ min),
  "multicast": () => (/* reexport */ multicast),
  "observeOn": () => (/* reexport */ observeOn/* observeOn */.QV),
  "onErrorResumeNext": () => (/* reexport */ onErrorResumeNext),
  "pairwise": () => (/* reexport */ pairwise),
  "partition": () => (/* reexport */ partition),
  "pluck": () => (/* reexport */ pluck),
  "publish": () => (/* reexport */ publish),
  "publishBehavior": () => (/* reexport */ publishBehavior),
  "publishLast": () => (/* reexport */ publishLast),
  "publishReplay": () => (/* reexport */ publishReplay),
  "race": () => (/* reexport */ race_race),
  "reduce": () => (/* reexport */ reduce),
  "refCount": () => (/* reexport */ refCount/* refCount */.x),
  "repeat": () => (/* reexport */ repeat),
  "repeatWhen": () => (/* reexport */ repeatWhen),
  "retry": () => (/* reexport */ retry),
  "retryWhen": () => (/* reexport */ retryWhen),
  "sample": () => (/* reexport */ sample),
  "sampleTime": () => (/* reexport */ sampleTime),
  "scan": () => (/* reexport */ scan),
  "sequenceEqual": () => (/* reexport */ sequenceEqual),
  "share": () => (/* reexport */ share),
  "shareReplay": () => (/* reexport */ shareReplay),
  "single": () => (/* reexport */ single),
  "skip": () => (/* reexport */ skip),
  "skipLast": () => (/* reexport */ skipLast),
  "skipUntil": () => (/* reexport */ skipUntil),
  "skipWhile": () => (/* reexport */ skipWhile),
  "startWith": () => (/* reexport */ startWith),
  "subscribeOn": () => (/* reexport */ subscribeOn),
  "switchAll": () => (/* reexport */ switchAll),
  "switchMap": () => (/* reexport */ switchMap/* switchMap */.w),
  "switchMapTo": () => (/* reexport */ switchMapTo),
  "take": () => (/* reexport */ take),
  "takeLast": () => (/* reexport */ takeLast),
  "takeUntil": () => (/* reexport */ takeUntil),
  "takeWhile": () => (/* reexport */ takeWhile),
  "tap": () => (/* reexport */ tap),
  "throttle": () => (/* reexport */ throttle),
  "throttleTime": () => (/* reexport */ throttleTime),
  "throwIfEmpty": () => (/* reexport */ throwIfEmpty),
  "timeInterval": () => (/* reexport */ timeInterval),
  "timeout": () => (/* reexport */ timeout),
  "timeoutWith": () => (/* reexport */ timeoutWith),
  "timestamp": () => (/* reexport */ timestamp),
  "toArray": () => (/* reexport */ toArray),
  "window": () => (/* reexport */ window_window),
  "windowCount": () => (/* reexport */ windowCount),
  "windowTime": () => (/* reexport */ windowTime),
  "windowToggle": () => (/* reexport */ windowToggle),
  "windowWhen": () => (/* reexport */ windowWhen),
  "withLatestFrom": () => (/* reexport */ withLatestFrom),
  "zip": () => (/* reexport */ zip_zip),
  "zipAll": () => (/* reexport */ zipAll)
});

// EXTERNAL MODULE: ../../node_modules/rxjs/node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(2995);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(93694);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/audit.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(duration, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = undefined;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = undefined;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function () {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=audit.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(20646);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(13254);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/auditTime.js
/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */



function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return audit(function () { return (0,timer/* timer */.H)(duration, scheduler); });
}
//# sourceMappingURL=auditTime.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/buffer.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add((0,innerSubscribe/* innerSubscribe */.ft)(closingNotifier, new innerSubscribe/* SimpleInnerSubscriber */.IY(_this)));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function () {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=buffer.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(91881);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/bufferCount.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber/* Subscriber */.L));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=bufferCount.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/isScheduler.js
var isScheduler = __webpack_require__(14070);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/bufferTime.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */




function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = scheduler_async/* async */.P;
    if ((0,isScheduler/* isScheduler */.K)(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber/* Subscriber */.L));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/Subscription.js
var Subscription = __webpack_require__(51586);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js + 1 modules
var subscribeToResult = __webpack_require__(10505);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(96807);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */




function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add((0,subscribeToResult/* subscribeToResult */.D)(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription/* Subscription */.w();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = (0,subscribeToResult/* subscribeToResult */.D)(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L));
//# sourceMappingURL=bufferToggle.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
/** PURE_IMPORTS_START tslib,_Subscription,_innerSubscribe PURE_IMPORTS_END */



function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = undefined;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function () {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription/* Subscription */.w();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add((0,innerSubscribe/* innerSubscribe */.ft)(closingNotifier, new innerSubscribe/* SimpleInnerSubscriber */.IY(this)));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=bufferWhen.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(79250);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(20097);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/combineAll.js
/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

function combineAll(project) {
    return function (source) { return source.lift(new combineLatest/* CombineLatestOperator */.Ms(project)); };
}
//# sourceMappingURL=combineAll.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/isArray.js
var util_isArray = __webpack_require__(93073);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/from.js
var observable_from = __webpack_require__(97238);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/combineLatest.js
/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */



var none = {};
function combineLatest_combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && (0,util_isArray/* isArray */.k)(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call((0,observable_from/* from */.D)([source].concat(observables)), new combineLatest/* CombineLatestOperator */.Ms(project)); };
}
//# sourceMappingURL=combineLatest.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(24245);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/concat.js
/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

function concat_concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat/* concat.apply */.z.apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=concat.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/concatAll.js
var concatAll = __webpack_require__(90430);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(71710);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/concatMap.js
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return (0,mergeMap/* mergeMap */.zg)(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

function concatMapTo(innerObservable, resultSelector) {
    return concatMap(function () { return innerObservable; }, resultSelector);
}
//# sourceMappingURL=concatMapTo.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/count.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=count.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/debounce.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = (0,innerSubscribe/* innerSubscribe */.ft)(duration, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=debounce.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/debounceTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber/* Subscriber */.L));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=defaultIfEmpty.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/util/isDate.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(38781);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/delay.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    var absoluteDelay = isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification/* Notification.createNext */.P.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification/* Notification.createComplete */.P.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber/* Subscriber */.L));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/Observable.js + 1 modules
var Observable = __webpack_require__(19939);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/delayWhen.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = (0,subscribeToResult/* subscribeToResult */.D)(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable/* Observable */.y));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=delayWhen.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/dematerialize.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=dematerialize.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/distinct.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add((0,innerSubscribe/* innerSubscribe */.ft)(flushes, new innerSubscribe/* SimpleInnerSubscriber */.IY(_this)));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function () {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));

//# sourceMappingURL=distinct.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=distinctUntilChanged.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
//# sourceMappingURL=distinctUntilKeyChanged.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = __webpack_require__(9120);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(72730);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyError = __webpack_require__(44397);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */



function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
var ThrowIfEmptyOperator = /*@__PURE__*/ (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber/* Subscriber */.L));
function defaultErrorFactory() {
    return new EmptyError/* EmptyError */.K();
}
//# sourceMappingURL=throwIfEmpty.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(84773);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/take.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return (0,empty/* empty */.c)();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=take.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/elementAt.js
/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */





function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe((0,filter/* filter */.h)(function (v, i) { return i === index; }), take(1), hasDefaultValue
            ? defaultIfEmpty(defaultValue)
            : throwIfEmpty(function () { return new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W(); }));
    };
}
//# sourceMappingURL=elementAt.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(16612);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/endWith.js
/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */


function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return (0,concat/* concat */.z)(source, of.of.apply(void 0, array)); };
}
//# sourceMappingURL=endWith.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/every.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=every.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/exhaust.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add((0,innerSubscribe/* innerSubscribe */.ft)(value, new innerSubscribe/* SimpleInnerSubscriber */.IY(this)));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=exhaust.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(92188);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return (0,observable_from/* from */.D)(project(a, i)).pipe((0,map/* map */.U)(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=exhaustMap.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/expand.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());

var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add((0,innerSubscribe/* innerSubscribe */.ft)(result, new innerSubscribe/* SimpleInnerSubscriber */.IY(this)));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (innerValue) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));

//# sourceMappingURL=expand.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/finalize.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription/* Subscription */.w(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=finalize.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/find.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());

var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber/* Subscriber */.L));

//# sourceMappingURL=find.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/findIndex.js
/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new FindValueOperator(predicate, source, true, thisArg)); };
}
//# sourceMappingURL=findIndex.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(36930);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/first.js
/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */






function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? (0,filter/* filter */.h)(function (v, i) { return predicate(v, i, source); }) : identity/* identity */.y, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError/* EmptyError */.K(); })); };
}
//# sourceMappingURL=first.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/groupBy.js
var groupBy = __webpack_require__(60453);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=ignoreElements.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/isEmpty.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=isEmpty.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/takeLast.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return (0,empty/* empty */.c)();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=takeLast.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/last.js
/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */






function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? (0,filter/* filter */.h)(function (v, i) { return predicate(v, i, source); }) : identity/* identity */.y, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError/* EmptyError */.K(); })); };
}
//# sourceMappingURL=last.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/mapTo.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=mapTo.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/materialize.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification/* Notification.createNext */.P.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification/* Notification.createError */.P.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification/* Notification.createComplete */.P.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=materialize.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/scan.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=scan.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/pipe.js
var pipe = __webpack_require__(1199);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/reduce.js
/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */




function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return (0,pipe/* pipe */.z)(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return (0,pipe/* pipe */.z)(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);
    };
}
//# sourceMappingURL=reduce.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/max.js
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce(max);
}
//# sourceMappingURL=max.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(97686);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/merge.js
/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

function merge_merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge/* merge.apply */.T.apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=merge.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js
var mergeAll = __webpack_require__(97258);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return (0,mergeMap/* mergeMap */.zg)(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return (0,mergeMap/* mergeMap */.zg)(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/mergeScan.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());

var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));

//# sourceMappingURL=mergeScan.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/min.js
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce(min);
}
//# sourceMappingURL=min.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = __webpack_require__(89386);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/multicast.js
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable/* connectableObservableDescriptor */.N);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/observeOn.js
var observeOn = __webpack_require__(49433);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_innerSubscribe PURE_IMPORTS_END */




function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && (0,util_isArray/* isArray */.k)(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = undefined;
    if (nextSources.length === 1 && isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return from(source).lift(new OnErrorResumeNextOperator(nextSources));
}
var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(next, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=onErrorResumeNext.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/pairwise.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=pairwise.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/not.js
var not = __webpack_require__(65683);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/partition.js
/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */


function partition(predicate, thisArg) {
    return function (source) {
        return [
            (0,filter/* filter */.h)(predicate, thisArg)(source),
            (0,filter/* filter */.h)((0,not/* not */.f)(predicate, thisArg))(source)
        ];
    };
}
//# sourceMappingURL=partition.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/pluck.js
/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return (0,map/* map */.U)(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(61194);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/publish.js
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        multicast(function () { return new Subject/* Subject */.xQ(); }, selector) :
        multicast(new Subject/* Subject */.xQ());
}
//# sourceMappingURL=publish.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(64580);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */


function publishBehavior(value) {
    return function (source) { return multicast(new BehaviorSubject/* BehaviorSubject */.X(value))(source); };
}
//# sourceMappingURL=publishBehavior.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject = __webpack_require__(93866);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/publishLast.js
/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */


function publishLast() {
    return function (source) { return multicast(new AsyncSubject/* AsyncSubject */.c())(source); };
}
//# sourceMappingURL=publishLast.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject = __webpack_require__(61048);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/publishReplay.js
/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */


function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject/* ReplaySubject */.t(bufferSize, windowTime, scheduler);
    return function (source) { return multicast(function () { return subject; }, selector)(source); };
}
//# sourceMappingURL=publishReplay.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(32219);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/race.js
/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */


function race_race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && (0,util_isArray/* isArray */.k)(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race/* race.apply */.S3.apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=race.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/repeat.js
/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */



function repeat(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) {
        if (count === 0) {
            return (0,empty/* empty */.c)();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=repeat.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function () {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function () {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next(undefined);
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject/* Subject */.xQ();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(retries, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
    };
    return RepeatWhenSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=repeatWhen.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/retry.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function retry(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=retry.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/retryWhen.js
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject/* Subject */.xQ();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(retries, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
            }
            else {
                this.errors = undefined;
                this.retriesSubscription = undefined;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RetryWhenSubscriber.prototype.notifyNext = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=retryWhen.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(46840);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/sample.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add((0,innerSubscribe/* innerSubscribe */.ft)(this.notifier, new innerSubscribe/* SimpleInnerSubscriber */.IY(sampleSubscriber)));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=sample.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/sampleTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber/* Subscriber */.L));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());

var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber/* Subscriber */.L));

var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=sequenceEqual.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/share.js
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new Subject/* Subject */.xQ();
}
function share() {
    return function (source) { return (0,refCount/* refCount */.x)()(multicast(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/shareReplay.js
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler,
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject/* ReplaySubject */.t(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) {
                    subject.next(value);
                },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
            if (isComplete) {
                subscription = undefined;
            }
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            innerSub = undefined;
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/single.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */



function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError/* EmptyError */.K);
        }
    };
    return SingleSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=single.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/skip.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=skip.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/skipLast.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */



function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber/* Subscriber */.L(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=skipLast.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/skipUntil.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function () {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=skipUntil.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/skipWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=skipWhile.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/startWith.js
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if ((0,isScheduler/* isScheduler */.K)(scheduler)) {
        array.pop();
        return function (source) { return (0,concat/* concat */.z)(array, source, scheduler); };
    }
    else {
        return function (source) { return (0,concat/* concat */.z)(array, source); };
    }
}
//# sourceMappingURL=startWith.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/scheduler/asap.js + 3 modules
var asap = __webpack_require__(74858);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/isNumeric.js
var isNumeric = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap/* asap */.e;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!(0,isNumeric/* isNumeric */.k)(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap/* asap */.e;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap/* asap */.e;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable/* Observable */.y));

//# sourceMappingURL=SubscribeOnObservable.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(64805);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/switchAll.js
/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */


function switchAll() {
    return (0,switchMap/* switchMap */.w)(identity/* identity */.y);
}
//# sourceMappingURL=switchAll.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? (0,switchMap/* switchMap */.w)(function () { return innerObservable; }, resultSelector) : (0,switchMap/* switchMap */.w)(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/takeUntil.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(this.notifier, new innerSubscribe/* SimpleInnerSubscriber */.IY(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=takeUntil.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/takeWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=takeWhile.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/noop.js
var noop = __webpack_require__(54582);
// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/isFunction.js
var isFunction = __webpack_require__(77371);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/tap.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop/* noop */.Z;
        _this._tapError = noop/* noop */.Z;
        _this._tapComplete = noop/* noop */.Z;
        _this._tapError = error || noop/* noop */.Z;
        _this._tapComplete = complete || noop/* noop */.Z;
        if ((0,isFunction/* isFunction */.m)(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop/* noop */.Z;
            _this._tapError = observerOrNext.error || noop/* noop */.Z;
            _this._tapComplete = observerOrNext.complete || noop/* noop */.Z;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=tap.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/throttle.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = (0,innerSubscribe/* innerSubscribe */.ft)(duration, new innerSubscribe/* SimpleInnerSubscriber */.IY(this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=throttle.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/throttleTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(throttleTime_dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber/* Subscriber */.L));
function throttleTime_dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(86542);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/timeInterval.js
/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */




function timeInterval(scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return function (source) {
        return (0,defer/* defer */.P)(function () {
            return source.pipe(scan(function (_a, value) {
                var current = _a.current;
                return ({ value: value, current: scheduler.now(), last: current });
            }, { current: scheduler.now(), value: undefined, last: undefined }), (0,map/* map */.U)(function (_a) {
                var current = _a.current, last = _a.last, value = _a.value;
                return new TimeInterval(value, current - last);
            }));
        });
    };
}
var TimeInterval = /*@__PURE__*/ (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

//# sourceMappingURL=timeInterval.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutError = __webpack_require__(35915);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */




function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return function (source) {
        var absoluteTimeout = isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add((0,innerSubscribe/* innerSubscribe */.ft)(withObservable, new innerSubscribe/* SimpleInnerSubscriber */.IY(subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=timeoutWith.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(34236);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/timeout.js
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return timeoutWith(due, (0,throwError/* throwError */._)(new TimeoutError/* TimeoutError */.W()), scheduler);
}
//# sourceMappingURL=timeout.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/timestamp.js
/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */


function timestamp(scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async/* async */.P;
    }
    return (0,map/* map */.U)(function (value) { return new Timestamp(value, scheduler.now()); });
}
var Timestamp = /*@__PURE__*/ (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());

//# sourceMappingURL=timestamp.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/toArray.js
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce(toArrayReducer, []);
}
//# sourceMappingURL=toArray.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/window.js
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function window_window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add((0,innerSubscribe/* innerSubscribe */.ft)(this.windowBoundaries, new innerSubscribe/* SimpleInnerSubscriber */.IY(windowSubscriber)));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject/* Subject */.xQ();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function () {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function () {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject/* Subject */.xQ();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds));
//# sourceMappingURL=window.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/windowCount.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */



function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject/* Subject */.xQ()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject/* Subject */.xQ();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber/* Subscriber */.L));
//# sourceMappingURL=windowCount.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/windowTime.js
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */






function windowTime(windowTimeSpan) {
    var scheduler = scheduler_async/* async */.P;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if ((0,isScheduler/* isScheduler */.K)(arguments[3])) {
        scheduler = arguments[3];
    }
    if ((0,isScheduler/* isScheduler */.K)(arguments[2])) {
        scheduler = arguments[2];
    }
    else if ((0,isNumeric/* isNumeric */.k)(arguments[2])) {
        maxWindowSize = Number(arguments[2]);
    }
    if ((0,isScheduler/* isScheduler */.K)(arguments[1])) {
        scheduler = arguments[1];
    }
    else if ((0,isNumeric/* isNumeric */.k)(arguments[1])) {
        windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject/* Subject */.xQ));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber/* Subscriber */.L));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/windowToggle.js
/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = (0,subscribeToResult/* subscribeToResult */.D)(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject/* Subject */.xQ();
            var subscription = new Subscription/* Subscription */.w();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = (0,subscribeToResult/* subscribeToResult */.D)(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L));
//# sourceMappingURL=windowToggle.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/windowWhen.js
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new windowWhen_WindowOperator(closingSelector));
    };
}
var windowWhen_WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new windowWhen_WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var windowWhen_WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject/* Subject */.xQ();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = (0,subscribeToResult/* subscribeToResult */.D)(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L));
//# sourceMappingURL=windowWhen.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6/* __extends */.ZT(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add((0,subscribeToResult/* subscribeToResult */.D)(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L));
//# sourceMappingURL=withLatestFrom.js.map

// EXTERNAL MODULE: ../../node_modules/rxjs/_esm5/internal/observable/zip.js
var zip = __webpack_require__(71131);
;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/zip.js
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zip_zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip/* zip.apply */.$R.apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=zip.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/internal/operators/zipAll.js
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zipAll(project) {
    return function (source) { return source.lift(new zip/* ZipOperator */.mx(project)); };
}
//# sourceMappingURL=zipAll.js.map

;// CONCATENATED MODULE: ../../node_modules/rxjs/_esm5/operators/index.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */







































































































//# sourceMappingURL=index.js.map


/***/ })

}]);