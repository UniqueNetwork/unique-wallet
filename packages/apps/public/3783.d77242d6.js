((typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] || []).push([[3783],{

/***/ 51119:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ _defineProperty)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ 3783:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "BN_BILLION": () => (/* reexport */ BN_BILLION),
  "BN_EIGHT": () => (/* reexport */ BN_EIGHT),
  "BN_FIVE": () => (/* reexport */ BN_FIVE),
  "BN_FOUR": () => (/* reexport */ BN_FOUR),
  "BN_HUNDRED": () => (/* reexport */ BN_HUNDRED),
  "BN_MAX_INTEGER": () => (/* reexport */ BN_MAX_INTEGER),
  "BN_MILLION": () => (/* reexport */ BN_MILLION),
  "BN_NINE": () => (/* reexport */ BN_NINE),
  "BN_ONE": () => (/* reexport */ BN_ONE),
  "BN_QUINTILL": () => (/* reexport */ BN_QUINTILL),
  "BN_SEVEN": () => (/* reexport */ BN_SEVEN),
  "BN_SIX": () => (/* reexport */ BN_SIX),
  "BN_TEN": () => (/* reexport */ BN_TEN),
  "BN_THOUSAND": () => (/* reexport */ BN_THOUSAND),
  "BN_THREE": () => (/* reexport */ BN_THREE),
  "BN_TWO": () => (/* reexport */ BN_TWO),
  "BN_ZERO": () => (/* reexport */ BN_ZERO),
  "arrayChunk": () => (/* reexport */ arrayChunk),
  "arrayFilter": () => (/* reexport */ arrayFilter),
  "arrayFlatten": () => (/* reexport */ arrayFlatten),
  "assert": () => (/* reexport */ assert),
  "assertReturn": () => (/* reexport */ assertReturn),
  "bnFromHex": () => (/* reexport */ hexToBn),
  "bnMax": () => (/* reexport */ bnMax),
  "bnMin": () => (/* reexport */ bnMin),
  "bnSqrt": () => (/* reexport */ bnSqrt),
  "bnToBn": () => (/* reexport */ bnToBn),
  "bnToHex": () => (/* reexport */ bnToHex),
  "bnToU8a": () => (/* reexport */ bnToU8a),
  "bufferToU8a": () => (/* reexport */ bufferToU8a),
  "calcSi": () => (/* reexport */ calcSi),
  "compactAddLength": () => (/* reexport */ compactAddLength),
  "compactFromU8a": () => (/* reexport */ compactFromU8a),
  "compactStripLength": () => (/* reexport */ compactStripLength),
  "compactToU8a": () => (/* reexport */ compactToU8a),
  "detectPackage": () => (/* reexport */ detectPackage),
  "extractTime": () => (/* reexport */ extractTime),
  "findSi": () => (/* reexport */ findSi),
  "formatBalance": () => (/* reexport */ formatBalance),
  "formatDate": () => (/* reexport */ formatDate),
  "formatDecimal": () => (/* reexport */ formatDecimal),
  "formatElapsed": () => (/* reexport */ formatElapsed),
  "formatNumber": () => (/* reexport */ formatNumber),
  "hexAddPrefix": () => (/* reexport */ hexAddPrefix),
  "hexFixLength": () => (/* reexport */ hexFixLength),
  "hexHasPrefix": () => (/* reexport */ hexHasPrefix),
  "hexStripPrefix": () => (/* reexport */ hexStripPrefix),
  "hexToBn": () => (/* reexport */ hexToBn),
  "hexToNumber": () => (/* reexport */ hexToNumber),
  "hexToString": () => (/* reexport */ hexToString),
  "hexToU8a": () => (/* reexport */ hexToU8a),
  "isAscii": () => (/* reexport */ isAscii),
  "isBigInt": () => (/* reexport */ isBigInt),
  "isBn": () => (/* reexport */ isBn),
  "isBoolean": () => (/* reexport */ isBoolean),
  "isBuffer": () => (/* reexport */ isBuffer),
  "isChildClass": () => (/* reexport */ isChildClass),
  "isError": () => (/* reexport */ isError),
  "isFunction": () => (/* reexport */ isFunction),
  "isHex": () => (/* reexport */ isHex),
  "isInstanceOf": () => (/* reexport */ isInstanceOf),
  "isIp": () => (/* reexport */ isIp),
  "isJsonObject": () => (/* reexport */ isJsonObject),
  "isNull": () => (/* reexport */ isNull),
  "isNumber": () => (/* reexport */ isNumber),
  "isObject": () => (/* reexport */ isObject),
  "isObservable": () => (/* reexport */ isObservable),
  "isString": () => (/* reexport */ isString),
  "isTestChain": () => (/* reexport */ isTestChain),
  "isToBn": () => (/* reexport */ isToBn),
  "isU8a": () => (/* reexport */ isU8a),
  "isUndefined": () => (/* reexport */ isUndefined),
  "isUtf8": () => (/* reexport */ isUtf8),
  "isWasm": () => (/* reexport */ isWasm),
  "logger": () => (/* reexport */ logger),
  "loggerFormat": () => (/* reexport */ loggerFormat),
  "memoize": () => (/* reexport */ memoize),
  "numberToHex": () => (/* reexport */ numberToHex),
  "numberToU8a": () => (/* reexport */ numberToU8a),
  "packageInfo": () => (/* reexport */ util_packageInfo_packageInfo),
  "promisify": () => (/* reexport */ promisify),
  "stringCamelCase": () => (/* reexport */ stringCamelCase),
  "stringLowerFirst": () => (/* reexport */ stringLowerFirst),
  "stringShorten": () => (/* reexport */ stringShorten),
  "stringToHex": () => (/* reexport */ stringToHex),
  "stringToU8a": () => (/* reexport */ stringToU8a),
  "stringUpperFirst": () => (/* reexport */ stringUpperFirst),
  "stringify": () => (/* reexport */ stringify),
  "u8aConcat": () => (/* reexport */ u8aConcat),
  "u8aEq": () => (/* reexport */ u8aEq),
  "u8aFixLength": () => (/* reexport */ u8aFixLength),
  "u8aSorted": () => (/* reexport */ u8aSorted),
  "u8aToBn": () => (/* reexport */ u8aToBn),
  "u8aToBuffer": () => (/* reexport */ u8aToBuffer),
  "u8aToHex": () => (/* reexport */ u8aToHex),
  "u8aToString": () => (/* reexport */ u8aToString),
  "u8aToU8a": () => (/* reexport */ u8aToU8a)
});

;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textdecoder/packageInfo.js
// Copyright 2017-2021 @polkadot/x-textdecoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/x-textdecoder',
  version: '6.7.1'
};
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textencoder/packageInfo.js
// Copyright 2017-2021 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo_packageInfo = {
  name: '@polkadot/x-textencoder',
  version: '6.7.1'
};
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/packageInfo.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const util_packageInfo_packageInfo = {
  name: '@polkadot/util',
  version: '6.7.1'
};
// EXTERNAL MODULE: ../../node_modules/@polkadot/x-global/index.js
var x_global = __webpack_require__(64513);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/function.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line @typescript-eslint/ban-types

/**
 * @name isFunction
 * @summary Tests for a `function`.
 * @description
 * Checks to see if the input value is a JavaScript function.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isFunction } from '@polkadot/util';
 *
 * isFunction(() => false); // => true
 * ```
 */
function isFunction(value) {
  return typeof value === 'function';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/string.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isString
 * @summary Tests for a string.
 * @description
 * Checks to see if the input value is a JavaScript string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isString } from '@polkadot/util';
 *
 * console.log('isString', isString('test')); // => true
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/undefined.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isUndefined
 * @summary Tests for a `undefined` values.
 * @description
 * Checks to see if the input value is `undefined`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUndefined } from '@polkadot/util';
 *
 * console.log('isUndefined', isUndefined(void(0))); // => true
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isUndefined(value) {
  return typeof value === 'undefined';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/assert.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name assert
 * @summary Checks for a valid test, if not Error is thrown.
 * @description
 * Checks that `test` is a truthy value. If value is falsy (`null`, `undefined`, `false`, ...), it throws an Error with the supplied `message`. When `test` passes, `true` is returned.
 * @example
 * <BR>
 *
 * ```javascript
 * const { assert } from '@polkadot/util';
 *
 * assert(true, 'True should be true'); // passes
 * assert(false, 'False should not be true'); // Error thrown
 * assert(false, () => 'message'); // Error with 'message'
 * ```
 */
function assert(condition, message) {
  if (!condition) {
    throw new Error(isFunction(message) ? message() : message);
  }
}
/**
 * @name assertReturn
 * @summart Returns when the value is not undefined, otherwise throws assertion error
 */

function assertReturn(value, message) {
  assert(!isUndefined(value), message);
  return value;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/versionDetect.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0




const DEDUPE = 'Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:';
/** @internal */

function getEntry(name) {
  const _global = x_global/* xglobal */.U;

  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }

  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }

  return _global.__polkadotjs[name];
}

function getVersionLength(all) {
  return all.reduce((max, {
    version
  }) => Math.max(max, version.length), 0);
}
/** @internal */


function flattenInfos(all) {
  const verLength = getVersionLength(all);
  return all.map(({
    name,
    version
  }) => `\t${version.padEnd(verLength)}\t${name}`).join('\n');
}
/** @internal */


function flattenVersions(entry) {
  const all = entry.map(version => isString(version) ? {
    version
  } : version);
  const verLength = getVersionLength(all);
  return all.map(({
    path,
    version
  }) => `\t${version.padEnd(verLength)}\t${!path || path.length < 5 ? '<unknown>' : path}`).join('\n');
}
/** @internal */


function getPath(pathOrFn) {
  if (isFunction(pathOrFn)) {
    try {
      return pathOrFn() || '';
    } catch (error) {
      return '';
    }
  }

  return pathOrFn || '';
}
/**
 * @name detectPackage
 * @summary Checks that a specific package is only imported once
 */


function detectPackage({
  name,
  version
}, pathOrFn, deps = []) {
  assert(name.startsWith('@polkadot'), () => `Invalid package descriptor ${name}`);
  const entry = getEntry(name);
  entry.push({
    path: getPath(pathOrFn),
    version
  });

  if (entry.length !== 1) {
    console.warn(`${name} has multiple versions, ensure that there is only one installed.\n${DEDUPE}\n${flattenVersions(entry)}`);
  } else {
    const mismatches = deps.filter(d => d && d.version !== version);

    if (mismatches.length) {
      console.warn(`${name} requires direct dependencies exactly matching version ${version}.\n${DEDUPE}\n${flattenInfos(mismatches)}`);
    }
  }
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/detectPackage.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// For esm, this should be import.meta.url or to get the same behavior as __dirname, we can use
//
//   new URL(import.meta.url).pathname)
//
// The issue is the WP4 has "some" issues with import.meta.url. So because of bundlers, we can't have
// nice things... In this case it is even worse since import.meta.url won't even make it compile, so
// there is a complete dead end with usage thereof
//
// When that is fixed, a solution is to have both .js & .mjs files, with the following content -
//
// cjs: util.detectPackage(packageInfo, () => __dirname);
// esm: detectPackage(packageInfo, () => import.meta.url);
//
// With the above we additionally need a .d.ts to just export the packageInfo




detectPackage(util_packageInfo_packageInfo, typeof __dirname !== 'undefined' && __dirname, [packageInfo, packageInfo_packageInfo]);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/array/chunk.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name arrayChunk
 * @summary Split T[] into T[][] based on the defind size
 * @description
 * Returns a set ao arrays based on the chunksize
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayChunk } from '@polkadot/util';
 *
 * arrayChunk([1, 2, 3, 4, 5]); // [[1, 2], [3, 4], [5]]
 * ```
 */
function arrayChunk(array, chunkSize) {
  const outputSize = Math.ceil(array.length / chunkSize);
  const output = Array(outputSize);

  for (let index = 0; index < outputSize; index++) {
    const offset = index * chunkSize;
    output[index] = array.slice(offset, offset + chunkSize);
  }

  return output;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/null.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isNull
 * @summary Tests for a `null` values.
 * @description
 * Checks to see if the input value is `null`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isNull } from '@polkadot/util';
 *
 * console.log('isNull', isNull(null)); // => true
 * ```
 */
function isNull(value) {
  return value === null;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/array/filter.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name arrayFilter
 * @summary Filters undefined and (optionally) null values from an array
 * @description
 * Returns a new array with all `undefined` values removed. Optionally, when `allowNulls = false`, it removes the `null` values as well
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayFilter } from '@polkadot/util';
 *
 * arrayFilter([0, void 0, true, null, false, '']); // [0, true, null, false, '']
 * arrayFilter([0, void 0, true, null, false, ''], false); // [0, true, false, '']
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

function arrayFilter(array, allowNulls = true) {
  return array.filter(value => !isUndefined(value) && (allowNulls || !isNull(value)));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/array/flatten.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is supposed to be a faster concat...
// https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki

/**
 * @name arrayFlatten
 * @summary Merge T[][] into T[]
 * @description
 * Returns a new array with all arrays merged into one
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayFlatten } from '@polkadot/util';
 *
 * arrayFlatten([[1, 2], [3, 4], [5]]); // [1, 2, 3, 4, 5]
 * ```
 */
function arrayFlatten(arrays) {
  // pre-allocate based on the combined size
  const output = new Array(arrays.reduce((length, array) => length + array.length, 0));
  let index = -1;

  for (let a = 0; a < arrays.length; a++) {
    const array = arrays[a]; // instead of pushing, we just set the entries

    for (let e = 0; e < array.length; e++) {
      output[++index] = array[e];
    }
  }

  return output;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/array/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods that operates on arrays
 */



// EXTERNAL MODULE: ../../node_modules/bn.js/lib/bn.js
var lib_bn = __webpack_require__(62197);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/consts.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name BN_ZERO
 * @summary BN constant for 0.
 */

const BN_ZERO = new lib_bn(0);
/**
 * @name BN_ONE
 * @summary BN constant for 1.
 */

const BN_ONE = new lib_bn(1);
/**
 * @name BN_TWO
 * @summary BN constant for 2.
 */

const BN_TWO = new lib_bn(2);
/**
 * @name BN_THREE
 * @summary BN constant for 3.
 */

const BN_THREE = new lib_bn(3);
/**
 * @name BN_FOUR
 * @summary BN constant for 4.
 */

const BN_FOUR = new lib_bn(4);
/**
 * @name BN_FIVE
 * @summary BN constant for 5.
 */

const BN_FIVE = new lib_bn(5);
/**
 * @name BN_SIX
 * @summary BN constant for 6.
 */

const BN_SIX = new lib_bn(6);
/**
 * @name BN_SEVEN
 * @summary BN constant for 7.
 */

const BN_SEVEN = new lib_bn(7);
/**
 * @name BN_EIGHT
 * @summary BN constant for 8.
 */

const BN_EIGHT = new lib_bn(8);
/**
 * @name BN_NINE
 * @summary BN constant for 9.
 */

const BN_NINE = new lib_bn(9);
/**
 * @name BN_TEN
 * @summary BN constant for 10.
 */

const BN_TEN = new lib_bn(10);
/**
 * @name BN_HUNDRED
 * @summary BN constant for 100.
 */

const BN_HUNDRED = new lib_bn(100);
/**
 * @name BN_THOUSAND
 * @summary BN constant for 1,000.
 */

const BN_THOUSAND = new lib_bn(1000);
/**
 * @name BN_MILLION
 * @summary BN constant for 1,000,000.
 */

const BN_MILLION = new lib_bn(1000000);
/**
 * @name BN_BILLION
 * @summary BN constant for 1,000,000,000.
 */

const BN_BILLION = new lib_bn(1000000000);
/**
 * @name BN_QUINTILL
 * @summary BN constant for 1,000,000,000,000,000,000.
 */

const BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
/**
 * @name BN_MAX_INTEGER
 * @summary BN constant for MAX_SAFE_INTEGER
 */

const BN_MAX_INTEGER = new lib_bn(Number.MAX_SAFE_INTEGER);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/boolean.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isBoolean
 * @summary Tests for a boolean value.
 * @description
 * Checks to see if the input value is a JavaScript boolean.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBoolean } from '@polkadot/util';
 *
 * isBoolean(false); // => true
 * ```
 */
function isBoolean(value) {
  return typeof value === 'boolean';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/hex.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const HEX_REGEX = /^0x[a-fA-F0-9]+$/;
/**
 * @name isHex
 * @summary Tests for a hex string.
 * @description
 * Checks to see if the input value is a `0x` prefixed hex string. Optionally (`bitLength` !== -1) checks to see if the bitLength is correct.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isHex } from '@polkadot/util';
 *
 * isHex('0x1234'); // => true
 * isHex('0x1234', 8); // => false
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function isHex(value, bitLength = -1, ignoreLength = false) {
  const isValidHex = value === '0x' || isString(value) && HEX_REGEX.test(value.toString());

  if (isValidHex && bitLength !== -1) {
    return value.length === 2 + Math.ceil(bitLength / 4);
  }

  return isValidHex && (ignoreLength || value.length % 2 === 0);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/hasPrefix.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name hexHasPrefix
 * @summary Tests for the existence of a `0x` prefix.
 * @description
 * Checks for a valid hex input value and if the start matched `0x`
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexHasPrefix } from '@polkadot/util';
 *
 * console.log('has prefix', hexHasPrefix('0x1234')); // => true
 * ```
 */

function hexHasPrefix(value) {
  return !!(value && isHex(value, -1, true) && value.substr(0, 2) === '0x');
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/stripPrefix.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const UNPREFIX_HEX_REGEX = /^[a-fA-F0-9]+$/;
/**
 * @name hexStripPrefix
 * @summary Strips any leading `0x` prefix.
 * @description
 * Tests for the existence of a `0x` prefix, and returns the value without the prefix. Un-prefixed values are returned as-is.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexStripPrefix } from '@polkadot/util';
 *
 * console.log('stripped', hexStripPrefix('0x1234')); // => 1234
 * ```
 */

function hexStripPrefix(value) {
  if (!value) {
    return '';
  } else if (hexHasPrefix(value)) {
    return value.substr(2);
  } else if (UNPREFIX_HEX_REGEX.test(value)) {
    return value;
  }

  throw new Error(`Invalid hex ${value} passed to hexStripPrefix`);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/toBn.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0




function reverse(value) {
  return (value.match(/.{1,2}/g) || []).reverse().join('');
}
/**
 * @name hexToBn
 * @summary Creates a BN.js object from a hex string.
 * @description
 * `null` inputs returns a `BN(0)` result. Hex input values return the actual value converted to a BN. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @param _value The value to convert
 * @param _options Options to pass while converting
 * @param _options.isLe Convert using Little Endian
 * @param _options.isNegative Convert using two's complement
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToBn } from '@polkadot/util';
 *
 * hexToBn('0x123480001f'); // => BN(0x123480001f)
 * ```
 */


function hexToBn(value, options = {
  isLe: false,
  isNegative: false
}) {
  if (!value) {
    return new lib_bn(0);
  }

  const _options = _objectSpread({
    isLe: false,
    isNegative: false
  }, isBoolean(options) ? {
    isLe: options
  } : options);

  const _value = hexStripPrefix(value); // FIXME: Use BN's 3rd argument `isLe` once this issue is fixed
  // https://github.com/indutny/bn.js/issues/208


  const bn = new lib_bn((_options.isLe ? reverse(_value) : _value) || '00', 16); // fromTwos takes as parameter the number of bits, which is the hex length
  // multiplied by 4.

  return _options.isNegative ? bn.fromTwos(_value.length * 4) : bn;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/util.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


function checkMaxMin(type, items) {
  assert(items.length >= 1, 'Must provide one or more BN arguments');
  return items.reduce((a, v) => lib_bn[type](a, v), items[0]);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/max.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bnMax
 * @summary Finds and returns the highest value in an array of BNs.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnMax } from '@polkadot/util';
 *
 * bnMax([new BN(1), new BN(3), new BN(2)]).toString(); // => '3'
 * ```
 */

function bnMax(...items) {
  return checkMaxMin('max', items);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/min.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bnMin
 * @summary Finds and returns the smallest value in an array of BNs.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnMin } from '@polkadot/util';
 *
 * bnMin([new BN(1), new BN(3), new BN(2)]).toString(); // => '1'
 * ```
 */

function bnMin(...items) {
  return checkMaxMin('min', items);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/bigInt.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isBigInt
 * @summary Tests for a `BigInt` object instance.
 * @description
 * Checks to see if the input object is an instance of `BigInt`
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBigInt } from '@polkadot/util';
 *
 * console.log('isBigInt', isBigInt(123_456n)); // => true
 * ```
 */
function isBigInt(value) {
  return typeof value === 'bigint';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/toBn.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

function isToBn(value) {
  return !!value && isFunction(value.toBn);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/toBn.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0





/**
 * @name bnToBn
 * @summary Creates a BN value from a BN, BigInt, string (base 10 or hex) or number input.
 * @description
 * `null` inputs returns a `0x0` result, BN values returns the value, numbers returns a BN representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnToBn } from '@polkadot/util';
 *
 * bnToBn(0x1234); // => BN(0x1234)
 * bnToBn(new BN(0x1234)); // => BN(0x1234)
 * ```
 */

function bnToBn(value) {
  if (!value) {
    return new lib_bn(0);
  } else if (isHex(value)) {
    return hexToBn(value.toString());
  } else if (isBigInt(value)) {
    return new lib_bn(value.toString());
  }

  return lib_bn.isBN(value) ? value : isToBn(value) ? value.toBn() : new lib_bn(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/sqrt.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0




const SQRT_MAX_SAFE_INTEGER = new lib_bn(94906265);
/**
 * @name bnSqrt
 * @summary Calculates the integer square root of a BN
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnSqrt } from '@polkadot/util';
 *
 * bnSqrt(new BN(16)).toString(); // => '4'
 * ```
 */

function bnSqrt(value) {
  const n = bnToBn(value);
  assert(n.gte(BN_ZERO), 'square root of negative numbers is not supported'); // https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root/
  // shortcut <= 2^53 - 1 to use the JS utils

  if (n.lte(BN_MAX_INTEGER)) {
    return new lib_bn(Math.floor(Math.sqrt(n.toNumber())));
  } // Use sqrt(MAX_SAFE_INTEGER) as starting point. since we already know the
  // output will be larger than this, we expect this to be a safe start


  let x0 = SQRT_MAX_SAFE_INTEGER.clone();

  while (true) {
    const x1 = n.div(x0).iadd(x0).ishrn(1);

    if (x0.eq(x1) || x0.eq(x1.sub(BN_ONE))) {
      return x0;
    }

    x0 = x1;
  }
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/number.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isNumber
 * @summary Tests for a JavaScript number.
 * @description
 * Checks to see if the input value is a valid number.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isNumber } from '@polkadot/util';
 *
 * console.log('isNumber', isNumber(1234)); // => true
 * ```
 */
function isNumber(value) {
  return typeof value === 'number';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/toHex.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ALPHABET = new Array(256).fill(0).map((_, n) => n.toString(16).padStart(2, '0'));
/** @internal */

function extract(value) {
  const result = new Array(value.length);

  for (let i = 0; i < value.length; i++) {
    result[i] = ALPHABET[value[i]];
  }

  return result.join('');
}
/** @internal */


function trim(value, halfLength) {
  return `${u8aToHex(value.subarray(0, halfLength), -1, false)}â€¦${u8aToHex(value.subarray(value.length - halfLength), -1, false)}`;
}
/**
 * @name u8aToHex
 * @summary Creates a hex string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToHex } from '@polkadot/util';
 *
 * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f
 * ```
 */


function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const prefix = isPrefixed ? '0x' : '';

  if (!(value !== null && value !== void 0 && value.length)) {
    return prefix;
  }

  const byteLength = Math.ceil(bitLength / 8);
  return prefix + (byteLength > 0 && value.length > byteLength ? trim(value, Math.ceil(byteLength / 2)) : extract(value));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/toU8a.js


function toU8a_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function toU8a_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { toU8a_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { toU8a_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



function createEmpty(byteLength, options) {
  return options.bitLength === -1 ? new Uint8Array() : new Uint8Array(byteLength);
}

function createValue(valueBn, byteLength, {
  isLe,
  isNegative
}) {
  const output = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output.set(bn.toArray(isLe ? 'le' : 'be', byteLength), 0);
  return output;
}
/**
 * @name bnToU8a
 * @summary Creates a Uint8Array object from a BN.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `Uint8Array` result. `BN` input values return the actual bytes value converted to a `Uint8Array`. Optionally convert using little-endian format if `isLE` is set.
 * @example
 * <BR>
 *
 * ```javascript
 * import { bnToU8a } from '@polkadot/util';
 *
 * bnToU8a(new BN(0x1234)); // => [0x12, 0x34]
 * ```
 */


function bnToU8a(value, arg1 = {
  bitLength: -1,
  isLe: true,
  isNegative: false
}, arg2) {
  const options = toU8a_objectSpread({
    bitLength: -1,
    isLe: true,
    isNegative: false
  }, isNumber(arg1) ? {
    bitLength: arg1,
    isLe: arg2
  } : arg1);

  const valueBn = bnToBn(value);
  const byteLength = options.bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((options.bitLength || 0) / 8);
  return value ? createValue(valueBn, byteLength, options) : createEmpty(byteLength, options);
}


;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/toHex.js


function toHex_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function toHex_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { toHex_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { toHex_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



const ZERO_STR = '0x00';

function bnToHex(value, arg1 = {
  bitLength: -1,
  isLe: false,
  isNegative: false
}, arg2) {
  if (!value) {
    return ZERO_STR;
  }

  const _options = toHex_objectSpread({
    isLe: false,
    isNegative: false
  }, isNumber(arg1) ? {
    bitLength: arg1,
    isLe: arg2
  } : arg1);

  return u8aToHex(bnToU8a(value, _options));
}


;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/bn/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods to convert to and from `BN` objects
 */








;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/buffer/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bufferToU8a
 * @summary Creates a Uint8Array value from a Buffer object.
 * @description
 * `null` inputs returns an empty result, `Buffer` values return the actual value as a `Uint8Array`. Anything that is not a `Buffer` object throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { bufferToU8a } from '@polkadot/util';
 *
 * bufferToU8a(Buffer.from([1, 2, 3]));
 * ```
 */
function bufferToU8a(buffer) {
  return new Uint8Array(buffer || []);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/buffer/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods to convert to and from `Buffer` objects
 */

;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name hexToU8a
 * @summary Creates a Uint8Array object from a hex string.
 * @description
 * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToU8a } from '@polkadot/util';
 *
 * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])
 * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])
 * ```
 */

function hexToU8a(_value, bitLength = -1) {
  if (!_value) {
    return new Uint8Array();
  }

  assert(isHex(_value), () => `Expected hex value to convert, found '${_value}'`);
  const value = hexStripPrefix(_value);
  const valLength = value.length / 2;
  const bufLength = Math.ceil(bitLength === -1 ? valLength : bitLength / 8);
  const result = new Uint8Array(bufLength);
  const offset = Math.max(0, bufLength - valLength);

  for (let index = 0; index < bufLength; index++) {
    result[index + offset] = parseInt(value.substr(index * 2, 2), 16);
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/buffer.js
/* provided dependency */ var Buffer = __webpack_require__(48834)["Buffer"];
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isBuffer
 * @summary Tests for a `Buffer` object instance.
 * @description
 * Checks to see if the input object is an instance of `Buffer`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBuffer } from '@polkadot/util';
 *
 * console.log('isBuffer', isBuffer(Buffer.from([]))); // => true
 * ```
 */
function isBuffer(value) {
  return Buffer.isBuffer(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/instanceOf.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isInstanceOf
 * @summary Tests for a instance of a class.
 * @description
 * Checks to see if the input value is an instance of the test class.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isInstanceOf } from '@polkadot/util';
 *
 * console.log('isInstanceOf', isInstanceOf(new Array(0), Array)); // => true
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isInstanceOf(value, clazz) {
  return value instanceof clazz;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/u8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isU8a
 * @summary Tests for a `Uint8Array` object instance.
 * @description
 * Checks to see if the input object is an instance of `Uint8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUint8Array } from '@polkadot/util';
 *
 * console.log('isU8a', isU8a([])); // => false
 * ```
 */

function isU8a(value) {
  return isInstanceOf(value, Uint8Array);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textencoder/fallback.js
// Copyright 2017-2021 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is very limited, only handling Ascii values
class TextEncoder {
  encode(value) {
    const u8a = new Uint8Array(value.length);

    for (let i = 0; i < value.length; i++) {
      u8a[i] = value.charCodeAt(i);
    }

    return u8a;
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textencoder/browser.js
// Copyright 2017-2021 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0



const browser_TextEncoder = typeof x_global/* xglobal.TextEncoder */.U.TextEncoder === 'undefined' ? TextEncoder : x_global/* xglobal.TextEncoder */.U.TextEncoder;
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const encoder = new browser_TextEncoder();
/**
 * @name stringToU8a
 * @summary Creates a Uint8Array object from a utf-8 string.
 * @description
 * String input values return the actual encoded `UInt8Array`. `null` or `undefined` values returns an empty encoded array.
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringToU8a } from '@polkadot/util';
 *
 * stringToU8a('hello'); // [0x68, 0x65, 0x6c, 0x6c, 0x6f]
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0







/**
 * @name u8aToU8a
 * @summary Creates a Uint8Array value from a Uint8Array, Buffer, string or hex input.
 * @description
 * `null` or `undefined` inputs returns a `[]` result, Uint8Array values returns the value, hex strings returns a Uint8Array representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToU8a } from '@polkadot/util';
 *
 * u8aToU8a(new Uint8Array([0x12, 0x34]); // => Uint8Array([0x12, 0x34])
 * u8aToU8a(0x1234); // => Uint8Array([0x12, 0x34])
 * ```
 */

function u8aToU8a(value) {
  if (!value) {
    return new Uint8Array();
  } else if (isString(value)) {
    return isHex(value) ? hexToU8a(value) : stringToU8a(value);
  } else if (Array.isArray(value) || isBuffer(value)) {
    return new Uint8Array(value);
  }

  assert(isU8a(value), () => `Unable to convert ${value.toString()} (typeof ${typeof value}) to a Uint8Array`);
  return value;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/concat.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name u8aConcat
 * @summary Creates a concatenated Uint8Array from the inputs.
 * @description
 * Concatenates the input arrays into a single `UInt8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { { u8aConcat } from '@polkadot/util';
 *
 * u8aConcat(
 *   new Uint8Array([1, 2, 3]),
 *   new Uint8Array([4, 5, 6])
 * ); // [1, 2, 3, 4, 5, 6]
 * ```
 */

function u8aConcat(...list) {
  let length = 0;
  let offset = 0;
  const u8as = new Array(list.length);

  for (let i = 0; i < list.length; i++) {
    u8as[i] = u8aToU8a(list[i]);
    length += u8as[i].length;
  }

  const result = new Uint8Array(length);

  for (let i = 0; i < u8as.length; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/compact/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0




const MAX_U8 = new lib_bn(2).pow(new lib_bn(8 - 2)).subn(1);
const MAX_U16 = new lib_bn(2).pow(new lib_bn(16 - 2)).subn(1);
const MAX_U32 = new lib_bn(2).pow(new lib_bn(32 - 2)).subn(1);
/**
 * @name compactToU8a
 * @description Encodes a number into a compact representation
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactToU8a } from '@polkadot/util';
 *
 * console.log(compactToU8a(511, 32)); // Uint8Array([0b11111101, 0b00000111])
 * ```
 */

function compactToU8a(_value) {
  const value = bnToBn(_value);

  if (value.lte(MAX_U8)) {
    return new Uint8Array([value.toNumber() << 2]);
  } else if (value.lte(MAX_U16)) {
    return bnToU8a(value.shln(2).iadd(BN_ONE), 16, true);
  } else if (value.lte(MAX_U32)) {
    return bnToU8a(value.shln(2).iadd(BN_TWO), 32, true);
  }

  const u8a = bnToU8a(value);
  let length = u8a.length; // adjust to the minimum number of bytes

  while (u8a[length - 1] === 0) {
    length--;
  }

  assert(length >= 4, 'Invalid length, previous checks match anything less than 2^30');
  return u8aConcat( // subtract 4 as minimum (also catered for in decoding)
  [(length - 4 << 2) + 0b11], u8a.subarray(0, length));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/compact/addLength.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name compactAddLength
 * @description Adds a length prefix to the input value
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactAddLength } from '@polkadot/util';
 *
 * console.log(compactAddLength(new Uint8Array([0xde, 0xad, 0xbe, 0xef]))); // Uint8Array([4 << 2, 0xde, 0xad, 0xbe, 0xef])
 * ```
 */

function compactAddLength(input) {
  return u8aConcat(compactToU8a(input.length), input);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/toBn.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name u8aToBn
 * @summary Creates a BN from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.
 * @param value The value to convert
 * @param options Options to pass while converting
 * @param options.isLe Convert using Little Endian
 * @param options.isNegative Convert using two's complement
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToBn } from '@polkadot/util';
 *
 * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f
 * ```
 */

function u8aToBn(value, options = {
  isLe: true,
  isNegative: false
}) {
  return hexToBn(u8aToHex(value), options);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/compact/fromU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name compactFromU8a
 * @description Retrievs the offset and encoded length from a compact-prefixed value
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactFromU8a } from '@polkadot/util';
 *
 * const [offset, length] = compactFromU8a(new Uint8Array([254, 255, 3, 0]));
 *
 * console.log('value offset=', offset, 'length=', length); // 4, 0xffff
 * ```
 */

function compactFromU8a(_input) {
  const input = u8aToU8a(_input);
  const flag = input[0] & 0b11;

  if (flag === 0b00) {
    return [1, new lib_bn(input[0]).ishrn(2)];
  } else if (flag === 0b01) {
    return [2, u8aToBn(input.slice(0, 2), true).ishrn(2)];
  } else if (flag === 0b10) {
    return [4, u8aToBn(input.slice(0, 4), true).ishrn(2)];
  }

  const offset = 1 + new lib_bn(input[0]).ishrn(2) // clear flag
  .iadd(BN_FOUR) // add 4 for base length
  .toNumber();
  return [offset, u8aToBn(input.subarray(1, offset), true)];
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/compact/stripLength.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name compactStripLength
 * @description Removes the length prefix, returning both the total length (including the value + compact encoding) and the decoded value with the correct length
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactStripLength } from '@polkadot/util';
 *
 * console.log(compactStripLength(new Uint8Array([2 << 2, 0xde, 0xad]))); // [2, Uint8Array[0xde, 0xad]]
 * ```
 */

function compactStripLength(input) {
  const [offset, length] = compactFromU8a(input);
  const total = offset + length.toNumber();
  return [total, input.subarray(offset, total)];
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/compact/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description
 * Encoding and decoding of parity-codec compact numbers. The codec is created
 * to take up the least amount of space for a specific number. It performs the
 * same function as Length, however differs in that it uses a variable number of
 * bytes to do the actual encoding. From the Rust implementation for compact
 * encoding:
 *
 *     0b00 00 00 00 / 00 00 00 00 / 00 00 00 00 / 00 00 00 00
 * (0 ... 2**6 - 1)    (u8)
 *     xx xx xx 00
 * (2**6 ... 2**14 - 1)  (u8, u16)  low LH high
 *     yL yL yL 01 / yH yH yH yL
 * (2**14 ... 2**30 - 1)  (u16, u32)  low LMMH high
 *     zL zL zL 10 / zM zM zM zL / zM zM zM zM / zH zH zH zM
 * (2**30 ... 2**536 - 1)  (u32, u64, u128, U256, U512, U520) straight LE-encoded
 *     nn nn nn 11 [ / zz zz zz zz ]{4 + n}
 *
 * Note: we use *LOW BITS* of the LSB in LE encoding to encode the 2 bit key.
 */




;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/extractTime.js


function extractTime_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function extractTime_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { extractTime_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { extractTime_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const HRS = 60 * 60;
const DAY = HRS * 24;
/**
 * @name addTime
 * @summary Add together two Time arrays
 */

function addTime(a, b) {
  return {
    days: a.days + b.days,
    hours: a.hours + b.hours,
    milliseconds: a.milliseconds + b.milliseconds,
    minutes: a.minutes + b.minutes,
    seconds: a.seconds + b.seconds
  };
}

const ZERO = {
  days: 0,
  hours: 0,
  milliseconds: 0,
  minutes: 0,
  seconds: 0
};

function extractDays(milliseconds, hrs) {
  const days = Math.floor(hrs / 24);
  return addTime(extractTime_objectSpread(extractTime_objectSpread({}, ZERO), {}, {
    days
  }), extractTime(milliseconds - days * DAY * 1000));
}

function extractHrs(milliseconds, mins) {
  const hrs = mins / 60;

  if (hrs < 24) {
    const hours = Math.floor(hrs);
    return addTime(extractTime_objectSpread(extractTime_objectSpread({}, ZERO), {}, {
      hours
    }), extractTime(milliseconds - hours * HRS * 1000));
  }

  return extractDays(milliseconds, hrs);
}

function extractMins(milliseconds, secs) {
  const mins = secs / 60;

  if (mins < 60) {
    const minutes = Math.floor(mins);
    return addTime(extractTime_objectSpread(extractTime_objectSpread({}, ZERO), {}, {
      minutes
    }), extractTime(milliseconds - minutes * 60 * 1000));
  }

  return extractHrs(milliseconds, mins);
}

function extractSecs(milliseconds) {
  const secs = milliseconds / 1000;

  if (secs < 60) {
    const seconds = Math.floor(secs);
    return addTime(extractTime_objectSpread(extractTime_objectSpread({}, ZERO), {}, {
      seconds
    }), extractTime(milliseconds - seconds * 1000));
  }

  return extractMins(milliseconds, secs);
}
/**
 * @name extractTime
 * @summary Convert a quantity of seconds to Time array representing accumulated {days, minutes, hours, seconds, milliseconds}
 * @example
 * <BR>
 *
 * ```javascript
 * import { extractTime } from '@polkadot/util';
 *
 * const { days, minutes, hours, seconds, milliseconds } = extractTime(6000); // 0, 0, 10, 0, 0
 * ```
 */


function extractTime(milliseconds) {
  if (!milliseconds) {
    return ZERO;
  } else if (milliseconds < 1000) {
    return extractTime_objectSpread(extractTime_objectSpread({}, ZERO), {}, {
      milliseconds
    });
  }

  return extractSecs(milliseconds);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/formatDecimal.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line prefer-regex-literals
const NUMBER_REGEX = new RegExp('(\\d+?)(?=(\\d{3})+(?!\\d)|$)', 'g');
function formatDecimal(value) {
  // We can do this by adjusting the regx, however for the sake of clarity
  // we rather strip and re-add the negative sign in the output
  const isNegative = value[0].startsWith('-');
  const matched = isNegative ? value.substr(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
  return matched ? `${isNegative ? '-' : ''}${matched.join(',')}` : value;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/si.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const SI_MID = 8;
const SI = [{
  power: -24,
  text: 'yocto',
  value: 'y'
}, {
  power: -21,
  text: 'zepto',
  value: 'z'
}, {
  power: -18,
  text: 'atto',
  value: 'a'
}, {
  power: -15,
  text: 'femto',
  value: 'f'
}, {
  power: -12,
  text: 'pico',
  value: 'p'
}, {
  power: -9,
  text: 'nano',
  value: 'n'
}, {
  power: -6,
  text: 'micro',
  value: 'Âµ'
}, {
  power: -3,
  text: 'milli',
  value: 'm'
}, {
  power: 0,
  text: 'Unit',
  value: '-'
}, // position 8
{
  power: 3,
  text: 'Kilo',
  value: 'k'
}, {
  power: 6,
  text: 'Mill',
  value: 'M'
}, // Mega, M
{
  power: 9,
  text: 'Bill',
  value: 'B'
}, // Giga, G
{
  power: 12,
  text: 'Tril',
  value: 'T'
}, // Tera, T
{
  power: 15,
  text: 'Peta',
  value: 'P'
}, {
  power: 18,
  text: 'Exa',
  value: 'E'
}, {
  power: 21,
  text: 'Zeta',
  value: 'Z'
}, {
  power: 24,
  text: 'Yotta',
  value: 'Y'
}]; // Given a SI type (e.g. k, m, Y) find the SI definition

function findSi(type) {
  // use a loop here, better RN support (which doesn't have [].find)
  for (let i = 0; i < SI.length; i++) {
    if (SI[i].value === type) {
      return SI[i];
    }
  }

  return SI[SI_MID];
}
function calcSi(text, decimals, forceUnit) {
  if (forceUnit) {
    return findSi(forceUnit);
  }

  const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/formatBalance.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0





const DEFAULT_DECIMALS = 0;
const DEFAULT_UNIT = SI[SI_MID].text;
let defaultDecimals = DEFAULT_DECIMALS;
let defaultUnit = DEFAULT_UNIT; // Formats a string/number with <prefix>.<postfix><type> notation

function _formatBalance(input, options = true, optDecimals = defaultDecimals) {
  let text = bnToBn(input).toString();

  if (text.length === 0 || text === '0') {
    return '0';
  } // strip the negative sign so we can work with clean groupings, re-add this in the
  // end when we return the result (from here on we work with positive numbers)


  const isNegative = text[0].startsWith('-');

  if (isNegative) {
    text = text.substr(1);
  } // extract options - the boolean case is for backwards-compat


  const {
    decimals = optDecimals,
    forceUnit = undefined,
    withSi = true,
    withSiFull = false,
    withUnit = true
  } = isBoolean(options) ? {
    withSi: options
  } : options; // NOTE We start at midpoint (8) minus 1 - this means that values display as
  // 123.456 instead of 0.123k (so always 6 relevant). Additionally we use ceil
  // so there are at most 3 decimal before the decimal separator

  const si = calcSi(text, decimals, forceUnit);
  const mid = text.length - (decimals + si.power);
  const prefix = text.substr(0, mid);
  const padding = mid < 0 ? 0 - mid : 0;
  const postfix = `${`${new Array(padding + 1).join('0')}${text}`.substr(mid < 0 ? 0 : mid)}0000`.substr(0, 4);
  const units = withSi || withSiFull ? si.value === '-' ? withUnit ? ` ${isBoolean(withUnit) ? si.text : withUnit}` : '' : ` ${withSiFull ? si.text : si.value}${withUnit ? `${withSiFull ? ' ' : ''}${isBoolean(withUnit) ? SI[SI_MID].text : withUnit}` : ''}` : '';
  return `${isNegative ? '-' : ''}${formatDecimal(prefix || '0')}.${postfix}${units}`;
}

const formatBalance = _formatBalance; // eslint-disable-next-line @typescript-eslint/unbound-method

formatBalance.calcSi = (text, decimals = defaultDecimals) => calcSi(text, decimals); // eslint-disable-next-line @typescript-eslint/unbound-method


formatBalance.findSi = findSi; // eslint-disable-next-line @typescript-eslint/unbound-method

formatBalance.getDefaults = () => {
  return {
    decimals: defaultDecimals,
    unit: defaultUnit
  };
}; // get allowable options to display in a dropdown
// eslint-disable-next-line @typescript-eslint/unbound-method


formatBalance.getOptions = (decimals = defaultDecimals) => {
  return SI.filter(({
    power
  }) => power < 0 ? decimals + power >= 0 : true);
}; // Sets the default decimals to use for formatting (ui-wide)
// eslint-disable-next-line @typescript-eslint/unbound-method


formatBalance.setDefaults = ({
  decimals,
  unit
}) => {
  defaultDecimals = isUndefined(decimals) ? defaultDecimals : Array.isArray(decimals) ? decimals[0] : decimals;
  defaultUnit = isUndefined(unit) ? defaultUnit : Array.isArray(unit) ? unit[0] : unit;
  SI[SI_MID].text = defaultUnit;
};


;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/formatDate.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function zeroPad(value) {
  return value.toString().padStart(2, '0');
}

function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/formatElapsed.js
// Copyright 2017-2021 @polkadot/ui-util authors & contributors
// SPDX-License-Identifier: Apache-2.0


function formatValue(elapsed) {
  if (elapsed < 15) {
    return `${elapsed.toFixed(1)}s`;
  } else if (elapsed < 60) {
    return `${elapsed | 0}s`;
  } else if (elapsed < 3600) {
    return `${elapsed / 60 | 0}m`;
  }

  return `${elapsed / 3600 | 0}h`;
}

function formatElapsed(now, value) {
  const tsNow = now && now.getTime() || 0;
  const tsValue = value instanceof Date ? value.getTime() : bnToBn(value).toNumber();
  return tsNow && tsValue ? formatValue(Math.max(Math.abs(tsNow - tsValue), 0) / 1000) : '0.0s';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/formatNumber.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


function formatNumber(value) {
  return formatDecimal(bnToBn(value).toString());
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/format/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0






;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/addPrefix.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name hexAddPrefix
 * @summary Adds the `0x` prefix to string values.
 * @description
 * Returns a `0x` prefixed string from the input value. If the input is already prefixed, it is returned unchanged.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexAddPrefix } from '@polkadot/util';
 *
 * console.log('With prefix', hexAddPrefix('0a0b12')); // => 0x0a0b12
 * ```
 */

function hexAddPrefix(value) {
  if (value && hexHasPrefix(value)) {
    return value;
  }

  return `0x${value && value.length % 2 === 1 ? '0' : ''}${value || ''}`;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/fixLength.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name hexFixLength
 * @summary Shifts a hex string to a specific bitLength
 * @description
 * Returns a `0x` prefixed string with the specified number of bits contained in the return value. (If bitLength is -1, length checking is not done). Values with more bits are trimmed to the specified length. Input values with less bits are returned as-is by default. When `withPadding` is set, shorter values are padded with `0`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexFixLength } from '@polkadot/util';
 *
 * console.log('fixed', hexFixLength('0x12', 16)); // => 0x12
 * console.log('fixed', hexFixLength('0x12', 16, true)); // => 0x0012
 * console.log('fixed', hexFixLength('0x0012', 8)); // => 0x12
 * ```
 */

function hexFixLength(value, bitLength = -1, withPadding = false) {
  const strLength = Math.ceil(bitLength / 4);
  const hexLength = strLength + 2;
  return hexAddPrefix(bitLength === -1 || value.length === hexLength || !withPadding && value.length < hexLength ? hexStripPrefix(value) : value.length > hexLength ? hexStripPrefix(value).slice(-1 * strLength) : `${'0'.repeat(strLength)}${hexStripPrefix(value)}`.slice(-1 * strLength));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/toNumber.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name hexToNumber
 * @summary Creates a Number value from a Buffer object.
 * @description
 * `null` inputs returns an NaN result, `hex` values return the actual value as a `Number`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToNumber } from '@polkadot/util';
 *
 * hexToNumber('0x1234'); // => 0x1234
 * ```
 */

function hexToNumber(value) {
  return value ? hexToBn(value).toNumber() : NaN;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textdecoder/fallback.js
// Copyright 2017-2021 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is very limited, only handling Ascii values
class TextDecoder {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,no-useless-constructor
  constructor(_) {// nothing
  }

  decode(value) {
    return value.reduce((str, code) => {
      return str + String.fromCharCode(code);
    }, '');
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/x-textdecoder/browser.js
// Copyright 2017-2021 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0



const browser_TextDecoder = typeof x_global/* xglobal.TextDecoder */.U.TextDecoder === 'undefined' ? TextDecoder : x_global/* xglobal.TextDecoder */.U.TextDecoder;
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/toString.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const decoder = new browser_TextDecoder('utf-8');
/**
 * @name u8aToString
 * @summary Creates a utf-8 string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual decoded utf-8 string. `null` or `undefined` values returns an empty string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToString } from '@polkadot/util';
 *
 * u8aToString(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // hello
 * ```
 */

function u8aToString(value) {
  return !(value !== null && value !== void 0 && value.length) ? '' : decoder.decode(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/toString.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name hexToU8a
 * @summary Creates a Uint8Array object from a hex string.
 * @description
 * Hex input values return the actual bytes value converted to a string. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToString } from '@polkadot/util';
 *
 * hexToU8a('0x68656c6c6f'); // hello
 * ```
 */

function hexToString(_value) {
  return u8aToString(hexToU8a(_value));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/hex/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Internal utilities to create and test for hex values
 */








;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/ascii.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


const FORMAT = [9, 10, 13];
/**
 * @name isAscii
 * @summary Tests if the input is printable ASCII
 * @description
 * Checks to see if the input string or Uint8Array is printable ASCII, 32-127 + formatters
 */

function isAscii(value) {
  return value ? !u8aToU8a(value).some(byte => byte >= 127 || byte < 32 && !FORMAT.includes(byte)) : isString(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/bn.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isBn
 * @summary Tests for a `BN` object instance.
 * @description
 * Checks to see if the input object is an instance of `BN` (bn.js).
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { isBn } from '@polkadot/util';
 *
 * console.log('isBn', isBn(new BN(1))); // => true
 * ```
 */

function isBn(value) {
  return lib_bn.isBN(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/childClass.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isChildClass
 * @summary Tests if the child extends the parent Class
 * @description
 * Checks to see if the child Class extends the parent Class
 * @example
 * <BR>
 *
 * ```javascript
 * import { isChildClass } from '@polkadot/util';
 *
 * console.log('isChildClass', isChildClass(BN, BN); // => true
 * console.log('isChildClass', isChildClass(BN, Uint8Array); // => false
 * ```
 */
function isChildClass(Parent, Child) {
  // https://stackoverflow.com/questions/30993434/check-if-a-constructor-inherits-another-in-es6/30993664
  return Child // eslint-disable-next-line no-prototype-builtins
  ? Parent === Child || Parent.isPrototypeOf(Child) : false;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/error.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isError
 * @summary Tests for a `Error` object instance.
 * @description
 * Checks to see if the input object is an instance of `Error`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isError } from '@polkadot/util';
 *
 * console.log('isError', isError(new Error('message'))); // => true
 * ```
 */

function isError(value) {
  return isInstanceOf(value, Error);
}
// EXTERNAL MODULE: ../../node_modules/ip-regex/index.js
var ip_regex = __webpack_require__(22263);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/ip.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name isIp
 * @summary Tests if the value is a valid IP address
 * @description
 * Checks to see if the value is a valid IP address. Optionally check for either v4/v6
 * @example
 * <BR>
 *
 * ```javascript
 * import { isIp } from '@polkadot/util';
 *
 * isIp('192.168.0.1')); // => true
 * isIp('1:2:3:4:5:6:7:8'); // => true
 * isIp('192.168.0.1', 'v6')); // => false
 * isIp('1:2:3:4:5:6:7:8', 'v4'); // => false
 * ```
 */
function isIp(value, type) {
  if (type === 'v4') {
    return ip_regex.v4({
      exact: true
    }).test(value);
  } else if (type === 'v6') {
    return ip_regex.v6({
      exact: true
    }).test(value);
  }

  return ip_regex({
    exact: true
  }).test(value);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/stringify.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

function stringify(args, space) {
  return JSON.stringify(args, (_, value) => isBigInt(value) ? value.toString() : value, space);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/jsonObject.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name isJsonObject
 * @summary Tests for a valid JSON `object`.
 * @description
 * Checks to see if the input value is a valid JSON object.
 * It returns false if the input is JSON parsable, but not an Javascript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isJsonObject } from '@polkadot/util';
 *
 * isJsonObject({}); // => true
 * isJsonObject({
 *  "Test": "1234",
 *  "NestedTest": {
 *   "Test": "5678"
 *  }
 * }); // => true
 * isJsonObject(1234); // JSON parsable, but not an object =>  false
 * isJsonObject(null); // JSON parsable, but not an object => false
 * isJsonObject('not an object'); // => false
 * ```
 */
function isJsonObject(value) {
  const str = typeof value !== 'string' ? stringify(value) : value;

  try {
    const obj = JSON.parse(str);
    return typeof obj === 'object' && obj !== null;
  } catch (e) {
    return false;
  }
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/object.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isObject
 * @summary Tests for an `object`.
 * @description
 * Checks to see if the input value is a JavaScript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isObject } from '@polkadot/util';
 *
 * isObject({}); // => true
 * isObject('something'); // => false
 * ```
 */
function isObject(value) {
  return typeof value === 'object';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/observable.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name isBObservable
 * @summary Tests for a `Observable` object instance.
 * @description
 * Checks to see if the input object is an instance of `BN` (bn.js).
 * @example
 * <BR>
 *
 * ```javascript
 * import { isObservable } from '@polkadot/util';
 *
 * console.log('isObservable', isObservable(...));
 * ```
 */
function isObservable(value) {
  return isObject(value) && isFunction(value.next);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/testChain.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const re = /(Development|Local Testnet)$/;
function isTestChain(chain) {
  if (!chain) {
    return false;
  }

  return !!re.test(chain.toString());
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/utf8.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Adapted from https://github.com/JulienPalard/is_utf8/blob/master/is_utf8.c


/**
 * @name isUtf8
 * @summary Tests if the input is valid Utf8
 * @description
 * Checks to see if the input string or Uint8Array is valid Utf8
 */

function isUtf8(value) {
  if (!value) {
    return isString(value);
  }

  const u8a = u8aToU8a(value);
  const len = u8a.length;
  let i = 0;

  while (i < len) {
    if (u8a[i] <= 0x7F)
      /* 00..7F */
      {
        i += 1;
      } else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF)
      /* C2..DF 80..BF */
      {
        if (i + 1 < len)
          /* Expect a 2nd byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF";
              // *faulty_bytes = 2;
              return false;
            }
          } else {
          // *message = "After a first byte between C2 and DF, expecting a 2nd byte.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 2;
      } else if (u8a[i] === 0xE0)
      /* E0 A0..BF 80..BF */
      {
        if (i + 2 < len)
          /* Expect a 2nd and 3rd byte */
          {
            if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte of E0, expecting a 2nd byte between A0 and BF.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte of E0, expecting a 3nd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }
          } else {
          // *message = "After a first byte of E0, expecting two following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 3;
      } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC)
      /* E1..EC 80..BF 80..BF */
      {
        if (i + 2 < len)
          /* Expect a 2nd and 3rd byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }
          } else {
          // *message = "After a first byte between E1 and EC, expecting two following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 3;
      } else if (u8a[i] === 0xED)
      /* ED 80..9F 80..BF */
      {
        if (i + 2 < len)
          /* Expect a 2nd and 3rd byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {
              // *message = "After a first byte of ED, expecting 2nd byte between 80 and 9F.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte of ED, expecting 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }
          } else {
          // *message = "After a first byte of ED, expecting two following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 3;
      } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF)
      /* EE..EF 80..BF 80..BF */
      {
        if (i + 2 < len)
          /* Expect a 2nd and 3rd byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte between EE and EF, expecting 2nd byte between 80 and BF.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte between EE and EF, expecting 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }
          } else {
          // *message = "After a first byte between EE and EF, two following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 3;
      } else if (u8a[i] === 0xF0)
      /* F0 90..BF 80..BF 80..BF */
      {
        if (i + 3 < len)
          /* Expect a 2nd, 3rd 3th byte */
          {
            if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte of F0, expecting 2nd byte between 90 and BF.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte of F0, expecting 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }

            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
              // *message = "After a first byte of F0, expecting 4th byte between 80 and BF.";
              // *faulty_bytes = 4;
              return false;
            }
          } else {
          // *message = "After a first byte of F0, expecting three following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 4;
      } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3)
      /* F1..F3 80..BF 80..BF 80..BF */
      {
        if (i + 3 < len)
          /* Expect a 2nd, 3rd 3th byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
              // *message = "After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }

            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
              // *message = "After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.";
              // *faulty_bytes = 4;
              return false;
            }
          } else {
          // *message = "After a first byte of F1, F2, or F3, expecting three following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 4;
      } else if (u8a[i] === 0xF4)
      /* F4 80..8F 80..BF 80..BF */
      {
        if (i + 3 < len)
          /* Expect a 2nd, 3rd 3th byte */
          {
            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {
              // *message = "After a first byte of F4, expecting 2nd byte between 80 and 8F.";
              // *faulty_bytes = 2;
              return false;
            }

            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
              // *message = "After a first byte of F4, expecting 3rd byte between 80 and BF.";
              // *faulty_bytes = 3;
              return false;
            }

            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
              // *message = "After a first byte of F4, expecting 4th byte between 80 and BF.";
              // *faulty_bytes = 4;
              return false;
            }
          } else {
          // *message = "After a first byte of F4, expecting three following bytes.";
          // *faulty_bytes = 1;
          return false;
        }

        i += 4;
      } else {
      // *message = "Expecting bytes in the following ranges: 00..7F C2..F4.";
      // *faulty_bytes = 1;
      return false;
    }
  }

  return true;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/eq.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


function equals(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}
/**
 * @name u8aEq
 * @summary Compares two Uint8Arrays.
 * @description
 * For `UInt8Array` (or hex string) input values true if there is a match.
 * @example
 * <BR>
 *
 * ```javascript
 * import { { u8aEq } from '@polkadot/util';
 *
 * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true
 * ```
 */


function u8aEq(a, b) {
  return equals(u8aToU8a(a), u8aToU8a(b));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/wasm.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const WASM_MAGIC = new Uint8Array([0, 97, 115, 109]); // \0asm

/**
 * @name isWasm
 * @summary Tests if the input has a WASM header
 * @description
 * Checks to see if the input Uint8Array contains a valid WASM header
 */

function isWasm(value) {
  return !!value && u8aEq(value.subarray(0, 4), WASM_MAGIC);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/is/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Type checking utilities
 */























;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/logger.js
/* provided dependency */ var process = __webpack_require__(34406);
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0








const logTo = {
  debug: 'log',
  error: 'error',
  log: 'log',
  warn: 'warn'
};

function formatOther(value) {
  if (value && isObject(value) && value.constructor === Object) {
    return Object.keys(value).reduce((result, key) => {
      result[key] = loggerFormat(value[key]);
      return result;
    }, {});
  }

  return value;
}

function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if (isBn(value)) {
    return value.toString();
  } else if (isU8a(value) || isBuffer(value)) {
    return u8aToHex(u8aToU8a(value));
  }

  return formatOther(value);
}

function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && isFunction(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }

  console[logTo[log]](formatDate(new Date()), type, ...values.map(loggerFormat).map(v => {
    if (maxSize <= 0) {
      return v;
    }

    const r = `${v}`;
    return r.length < maxSize ? v : `${r.substr(0, maxSize)} ...`;
  }));
}

function noop() {// noop
}

function parseEnv(type) {
  const env = (typeof process === 'object' ? process : {}).env || {};
  const maxSize = parseInt(env.DEBUG_MAX || '-1', 10);
  let isDebugOn = false;
  (env.DEBUG || '').toLowerCase().split(',').forEach(e => {
    if (!!e && (e === '*' || type === e || e.endsWith('*') && type.startsWith(e.slice(0, -1)))) {
      isDebugOn = true;
    }

    if (!!e && e.startsWith('-') && (type === e.slice(1) || e.endsWith('*') && type.startsWith(e.slice(1, -1)))) {
      isDebugOn = false;
    }
  });
  return [isDebugOn, isNaN(maxSize) ? -1 : maxSize];
}
/**
 * @name Logger
 * @summary Creates a consistent log interface for messages
 * @description
 * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.
 * @example
 * <BR>
 *
 * ```javascript
 * import { logger } from '@polkadot';
 *
 * const l = logger('test');
 * ```
 */


function logger(_type) {
  const type = `${_type.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(_type.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply('debug', type, values, maxSize) : noop,
    error: (...values) => apply('error', type, values),
    log: (...values) => apply('log', type, values),
    noop,
    warn: (...values) => apply('warn', type, values)
  };
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/memoize.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



function defaultGetId() {
  return 'none';
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function memoize(fn, {
  getInstanceId = defaultGetId
} = {}) {
  const cache = {};

  const memoized = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();

    if (!cache[instanceId]) {
      cache[instanceId] = {};
    }

    if (isUndefined(cache[instanceId][stringParams])) {
      cache[instanceId][stringParams] = fn(...args);
    }

    return cache[instanceId][stringParams];
  };

  memoized.unmemoize = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();

    if (cache[instanceId] && !isUndefined(cache[instanceId][stringParams])) {
      delete cache[instanceId][stringParams];
    }
  };

  return memoized;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/number/toHex.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0



/**
 * @name numberToHex
 * @summary Creates a hex value from a number.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `0x` result. `number` input values return the actual bytes value converted to a `hex`. With `bitLength` set, it converts the number to the equivalent size.
 * @example
 * <BR>
 *
 * ```javascript
 * import { numberToHex } from '@polkadot/util';
 *
 * numberToHex(0x1234); // => '0x1234'
 * numberToHex(0x1234, 32); // => 0x00001234
 * ```
 */

function numberToHex(value, bitLength = -1) {
  if (isUndefined(value) || isNull(value) || isNaN(value)) {
    return '0x';
  }

  return hexFixLength(value.toString(16), bitLength, true);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/number/toU8a.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0




/**
 * @name numberToU8a
 * @summary Creates a Uint8Array object from a number.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `Uint8Array` result. `number` input values return the actual bytes value converted to a `Uint8Array`. With `bitLength`, it converts the value to the equivalent size.
 * @example
 * <BR>
 *
 * ```javascript
 * import { numberToU8a } from '@polkadot/util';
 *
 * numberToU8a(0x1234); // => [0x12, 0x34]
 * ```
 */

function numberToU8a(value, bitLength = -1) {
  if (isUndefined(value) || isNull(value) || isNaN(value)) {
    return new Uint8Array();
  }

  return hexToU8a(numberToHex(value, bitLength));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/number/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods to convert to and from `number` values
 */


;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/promisify.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name promisify
 * @summary Wraps an async callback into a `Promise`
 * @description
 * Wraps the supplied async function `fn` that has a standard JS callback `(error: Error, result: any)` into a `Promise`, passing the supplied parameters. When `error` is set, the Promise is rejected, else the Promise resolves with the `result` value.
 * @example
 * <BR>
 *
 * ```javascript
 * const { promisify } from '@polkadot/util';
 *
 * await promisify(null, ((a, cb) => cb(null, a), true); // resolves with `true`
 * await promisify(null, (cb) => cb(new Error('error!'))); // rejects with `error!`
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function promisify(self, fn, ...params) {
  return new Promise((resolve, reject) => {
    const handler = (error, result) => {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    };

    fn.apply(self, params.concat(handler));
  });
}
// EXTERNAL MODULE: ../../node_modules/camelcase/index.js
var camelcase = __webpack_require__(78783);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/camelCase.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name stringCamelCase
 * @summary Convert a dash/dot/underscore/space separated string/String to camelCase
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function stringCamelCase(value) {
  return camelcase(value.toString());
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/lowerFirst.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name stringLowerFirst
 * @summary Lowercase the first letter of a string
 * @description
 * Lowercase the first letter of a string
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringLowerFirst } from '@polkadot/util';
 *
 * stringLowerFirst('ABC'); // => 'aBC'
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function stringLowerFirst(value) {
  return value ? value.charAt(0).toLowerCase() + value.slice(1) : '';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/shorten.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name stringShorten
 * @summary Returns a string with maximum length
 * @description
 * Checks the string against the `prefixLength`, if longer than double this, shortens it by placing `..` in the middle of it
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringShorten } from '@polkadot/util';
 *
 * stringShorten('1234567890', 2); // => 12..90
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function stringShorten(value, prefixLength = 6) {
  if (value.length <= 2 + 2 * prefixLength) {
    return value.toString();
  }

  return `${value.substr(0, prefixLength)}â€¦${value.slice(-prefixLength)}`;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/toHex.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0


/**
 * @name stringToHex
 * @summary Creates a hex string from a utf-8 string
 * @description
 * String input values return the actual encoded hex value.
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringToHex } from '@polkadot/util';
 *
 * stringToU8a('hello'); // 0x68656c6c6f
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function stringToHex(value) {
  return u8aToHex(stringToU8a(value));
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/upperFirst.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name stringUpperFirst
 * @summary Lowercase the first letter of a string
 * @description
 * Lowercase the first letter of a string
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringUpperFirst } from '@polkadot/util';
 *
 * stringUpperFirst('abc'); // => 'Abc'
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function stringUpperFirst(value) {
  return value ? value.charAt(0).toUpperCase() + value.slice(1) : '';
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/string/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods to convert to work with `string` values
 */






;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/fixLength.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name u8aFixLength
 * @summary Shifts a Uint8Array to a specific bitLength
 * @description
 * Returns a uint8Array with the specified number of bits contained in the return value. (If bitLength is -1, length checking is not done). Values with more bits are trimmed to the specified length.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aFixLength } from '@polkadot/util';
 *
 * u8aFixLength('0x12') // => 0x12
 * u8aFixLength('0x12', 16) // => 0x0012
 * u8aFixLength('0x1234', 8) // => 0x12
 * ```
 */
function u8aFixLength(value, bitLength = -1, atStart = false) {
  const byteLength = Math.ceil(bitLength / 8);

  if (bitLength === -1 || value.length === byteLength) {
    return value;
  } else if (value.length > byteLength) {
    return value.subarray(0, byteLength);
  }

  const result = new Uint8Array(byteLength);

  if (atStart) {
    result.set(value, 0);
  } else {
    result.set(value, byteLength - value.length);
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/sorted.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

function u8aSorted(u8as) {
  return u8as.sort((a, b) => {
    let i = 0;

    while (true) {
      if (isUndefined(a[i]) && isUndefined(b[i])) {
        return 0;
      } else if (isUndefined(a[i])) {
        return -1;
      } else if (isUndefined(b[i])) {
        return 1;
      }

      const cmp = a[i] - b[i];

      if (cmp !== 0) {
        return cmp;
      }

      i++;
    }
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/toBuffer.js
/* provided dependency */ var toBuffer_Buffer = __webpack_require__(48834)["Buffer"];
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name u8aToBuffer
 * @summary Creates a Buffer object from a hex string.
 * @description
 * `null` inputs returns an empty `Buffer` result. `UInt8Array` input values return the actual bytes value converted to a `Buffer`. Anything that is not a `UInt8Array` throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToBuffer } from '@polkadot/util';
 *
 * console.log('Buffer', u8aToBuffer('0x123480001f'));
 * ```
 */
function u8aToBuffer(value) {
  return toBuffer_Buffer.from(value || []);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/u8a/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods to convert to and from `Uint8Array` objects
 */









;// CONCATENATED MODULE: ../../node_modules/@polkadot/util/index.js
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @summary Utility methods for this package are split into groups
 */




















/***/ }),

/***/ 64513:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ xglobal)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/x-fetch authors & contributors
// SPDX-License-Identifier: Apache-2.0

const xglobal = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : undefined;

/***/ }),

/***/ 78783:
/***/ ((module) => {

"use strict";


const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports.default = camelCase;


/***/ }),

/***/ 22263:
/***/ ((module) => {

"use strict";


const word = '[a-fA-F\\d:]';
const b = options => options && options.includeBoundaries ?
	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
	'';

const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';

const v6seg = '[a-fA-F\\d]{1,4}';
const v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

// Pre-compile only the exact regexes because adding a global flag make regexes stateful
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);

const ip = options => options && options.exact ?
	v46Exact :
	new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, 'g');

ip.v4 = options => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');
ip.v6 = options => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');

module.exports = ip;


/***/ })

}]);